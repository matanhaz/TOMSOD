{
    "bugs info": {
        "bug counter": 115,
        "bugs": [
            {
                "issue_id": "JXPATH-201",
                "project": "Commons JXPath",
                "title": "CVE-2022-41852 RCE vulnerability in JXPathContext class functions",
                "type": "Bug",
                "description": "Those using JXPath to interpret untrusted XPath expressions may be vulnerable to a remote code execution attack. All JXPathContext class functions processing a XPath string are vulnerable except compile() and compilePath() function. The XPath expression can be used by an attacker to load any Java class from the classpath resulting in code execution.",
                "resolved": "2022-10-13",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-192",
                "project": "Commons JXPath",
                "title": "missing JXPath dependencies in pom 1.0",
                "type": "Bug",
                "description": "Hello,\r\n\r\nMaven cannot resolve commons-jxpath\u00a0 v 1.0 dependencies. So when i checked the pom.xml, i found that jxpath dependencies (groupId, artifactId) are missing.\u00a0\r\n\r\nYour help would be appreciated.\r\n\r\n\u00a0",
                "resolved": "2018-02-23",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-187",
                "project": "Commons JXPath",
                "title": "Possible endless loop in Namespace Resolving",
                "type": "Bug",
                "description": "When dealing with XML documents - org.w3c.dom - and when having a hierarchy of relative contexts, then, when trying to resolve the namespace prefix for some namespace uri, an endless loop is triggered.\nThis happens if\n* the namespace is not programatically registered with JXPathContext\n* the context used to resolve the namespace\n** has a parent context\n** and neither the context nor the parent have the namespace defined within the document\n\nI attached a patch for org/apache/commons/jxpath/ri/NamespaceResolver.java\nas well as a tar ball with a junit test and test files",
                "resolved": "2015-12-09",
                "versions": [
                    "1.3"
                ],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "JXPATH-172",
                "project": "Commons JXPath",
                "title": "Clarify JavaDoc of JXPathContext#getPointer",
                "type": "Bug",
                "description": "{quote}\nTraverses the xpath and returns a Pointer. A Pointer provides easy access to a property. If the xpath matches no properties in the graph, the pointer will be null.\n{quote}\n\nThis is not true because not {{null}} is returned but {{NullPointer}}. This makes a tremendous difference.\n",
                "resolved": "2015-11-24",
                "versions": [
                    "1.3"
                ],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "JXPATH-170",
                "project": "Commons JXPath",
                "title": "NullPointerException using org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer",
                "type": "Bug",
                "description": "Trying to use alternative xpath (for example \"homeAddress | streetNumber\") we get a NullPointerException in \norg.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.hashCode\nand\norg.apache.commons.jxpath.ri.model.dynamic.DynamicPointer.equals\ndue to not checked null value for attribute name.\n\nOriginal code:\npublic int hashCode() {\n        return System.identityHashCode(bean) + name.hashCode();\n    }\nfixed code\n\n public int hashCode() {\n        return System.identityHashCode(bean) + ((name != null) ? name.hashCode() : 0);\n    }\n\nIn a similar way for equals method.",
                "resolved": "2015-11-21",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-166",
                "project": "Commons JXPath",
                "title": "JXPathContextReferenceImpl.addNodePointerFactory not working anymore",
                "type": "Bug",
                "description": "I tried the following in a single test run in isolation:\n\n{{JXPathContextReferenceImpl.addNodePointerFactory(new ContainerPointerFactory());}}\n\nand got ExceptionInInitializer, I see a refactoring for  JXPathContext done by [~ggregory] in last (recent) revision 1523175. Reverting to previous 1234255 fixes the issue. \n\nThe refactoring contains some static-init code in JXPathContext  that creates an instance of a subclass of JXPathContext itself... seems to trigger one of the rare occasions in which a static final field might be null, as happens then in a JXPathContextReferenceImpl constructor where final field {{nodeFactories}} is null. My understanding is this: a call to any static method of {{JXPathContextReferenceImpl}} triggers load of {{JXPathContext}} class that executes static initialization code that creates a new {{JXPathContext}} that in turn is an other {{JXPathContextReferenceImpl}} with static final field null since the static initializer of its super class must still terminate. See something similar in http://stackoverflow.com/a/2547638/1536382 and http://stackoverflow.com/questions/2547713/why-static-fields-are-not-initialized-in-time\n\nMy fix is either to restore the volatile lazy initializaton just for {{compilationContext}} or, perhaps (not sure), just create a new context each time in the {{compile(xpath)}} static method.\n\n{noformat}\njava.lang.ExceptionInInitializerError\n\tat org.apache.commons.jxpath.ri.AddNodePointerFactoryTest.testAddFactory(AddNodePointerFactoryTest.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\nCaused by: java.lang.NullPointerException\n\tat org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContextReferenceImpl.java:191)\n\tat org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.<init>(JXPathContextReferenceImpl.java:178)\n\tat org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl.newContext(JXPathContextFactoryReferenceImpl.java:39)\n\tat org.apache.commons.jxpath.JXPathContext.newContext(JXPathContext.java:425)\n\tat org.apache.commons.jxpath.JXPathContext.<clinit>(JXPathContext.java:389)\n\t... 19 more\n\n{noformat}",
                "resolved": "2014-02-04",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.4",
                    "Nightly Builds"
                ]
            },
            {
                "issue_id": "JXPATH-162",
                "project": "Commons JXPath",
                "title": "Concurrency problem for JXPathContextFactory.factoryImplName static field",
                "type": "Bug",
                "description": "The static field [factoryImplName] is loaded lazily when the first call to JXPathContextFactory#getInstance() is made. This is a broken pattern when #getInstance() is called by multiple threads. My suggestion is to find the name in the static initializer:\n\nprivate static final String factoryImplName = findFactory(FACTORY_NAME_PROPERTY, DEFAULT_FACTORY_CLASS);\n    ",
                "resolved": "2015-11-22",
                "versions": [
                    "1.3"
                ],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "JXPATH-160",
                "project": "Commons JXPath",
                "title": "ValueUtils.getValue throws exception with set and index above size",
                "type": "Bug",
                "description": "ValueUtils offers a utility method to retrieve an indexed value from a collection. In case this collection is an array or a List, the method returns null if the index is above the size. If the supplied collection is a Set instead, then a NoSuchElementException is thrown if index is above size.\n\nThe desired behavior is that the result is the same for all kinds of collections and that even in the case of a Set null is returned if the index value is too large.",
                "resolved": "2015-11-24",
                "versions": [
                    "1.3",
                    "1.4"
                ],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "JXPATH-154",
                "project": "Commons JXPath",
                "title": "Resetting the default namespace causes a serious endless loop when requesting .asPath() on a node.",
                "type": "Bug",
                "description": "sample smaller case:\n{code}\n<...>\n <b:foo xmlns:b=\"bla\" xmlns=\"test111\">    <!--  No nodes are placed in the tree within ns \"test111\" but the attribute is still there.-->\n  <b:bar>a</b:bar>                         <!-- is in ns 'bla' -->\n  <test xmlns=\"\"></test>                   <!-- does not have a namespace -->\n </b:foo>\n</...>\n{code}\n\nwhen requesting .asPath() on the 'test' node, it loops in org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix(NodePointer, String), \nand if it didn't loop it would create a wrong xpath '//b:fo/null:test' DOMNodePointer.asPath().\n\n\nSo I think that the fix should be in org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.asPath()\n\n{code}\n....\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n...\n{code}\n\nshould become\n{code}\n...\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null || nsURI.length() == 0) { // check for empty string which means that the node doesn't have a namespace.\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n...\n{code}\n",
                "resolved": "2012-01-20",
                "versions": [
                    "1.3"
                ],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "JXPATH-153",
                "project": "Commons JXPath",
                "title": "Wrong entry IMPORT-PACKAGE in the file MANIFEST.MF for jdom and commons-beanutils",
                "type": "Bug",
                "description": "commons-beanutils and jdom are optional dependencies. But they are configured as required in the entry IMPORT-PACKAGE in the file MANIFEST.MF.",
                "resolved": "2012-01-21",
                "versions": [
                    "1.3"
                ],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "JXPATH-152",
                "project": "Commons JXPath",
                "title": "Concurrent access on hashmap of JXPathIntrospector",
                "type": "Bug",
                "description": "JXPathIntrospector.registerDynamicClass method can be called in static part of classes. \nIf two classes A & B try to registerDynamicClass in the same time a concurrent access exception can append on hashmap of JXPathIntrospector.\n\nReplace hashmap by concurrent hashmap or synchronized access to these hashmaps.",
                "resolved": "2012-02-24",
                "versions": [
                    "1.3"
                ],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "JXPATH-151",
                "project": "Commons JXPath",
                "title": "null handling is inconsistent",
                "type": "Bug",
                "description": "Comparing a vaule to null using unequals (\\!=) yields false!\n{noformat}\n        Map<String, Integer> m = new HashMap<String, Integer>();\n        m.put(\"a\", 1);\n        m.put(\"b\", null);\n        m.put(\"c\", 1);\n        JXPathContext c = JXPathContext.newContext(m);\n        System.out.println(c.getValue(\"a != b\") + \" should be true\");\n        System.out.println(c.getValue(\"a != c\") + \" should be false\");\n        System.out.println(c.getValue(\"a = b\") + \" should be false\");\n        System.out.println(c.getValue(\"a = c\") + \" should be true\");\n        System.out.println(c.getValue(\"not(a = b)\") + \" should be true\");\n        System.out.println(c.getValue(\"not(a = c)\") + \" should be false\");\n{noformat} \n\nOutput using 1.3:\n{color:red} false should be true{color}\nfalse should be false\nfalse should be false\ntrue should be true\ntrue should be true\nfalse should be false\n\n\nIn 1.2 it works correctly!",
                "resolved": "2011-06-08",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-149",
                "project": "Commons JXPath",
                "title": "relational operations do not function properly when comparing a non-Iterator LHS to an Iterator RHS",
                "type": "Bug",
                "description": "I have a simple JXpathContext, with the following variables: var1=0, var2=0, var3=1. When I try to evaluate the following expression - \"$var1 + $var2 <= $var3\", it returns false.",
                "resolved": "2011-06-08",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-148",
                "project": "Commons JXPath",
                "title": "false and false returns true",
                "type": "Bug",
                "description": "Map<String, Object> map = new HashMap<String, Object>();\nmap.put(\"h\", false);\nJXPathContext c = JXPathContext.newContext(map);\n\nSystem.out.println(c.getValue(\"h  and h \"));\n\nPrints: true !!! it should print false!\n\n\nSystem.out.println(c.getValue(\"h = true() and h = true()\")); although prints correctly: false",
                "resolved": "2011-06-07",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-147",
                "project": "Commons JXPath",
                "title": "Union of extension functions returning Collection not properly handled",
                "type": "Bug",
                "description": "Evaluating an xpath expression that is the union of two external functions that return a Collection doesn't return the full contents of each of the Collections.\n\nLooking through the code I found that UnionContext uses getCurrentNodePointer in setPosition which will ignores the index value that might have been set on the EvalContext when the pointer references a collection.\n\nI added \"getValuePointer()\" (as below) to the expression so the index would be respected and that seemed to cure the problem as tested by a simple test I added to ExtensionFunctionTest.java\n\n    public void testCollectionUnionReturn() {\n        String expr = \"test:collection()|test:collection()\";\n        List res = context.selectNodes(expr);\n        assertEquals(\"size \" + expr, 4, res.size());\n    }\n\nAlthough all the project tests still pass I admit to not being quite sure that this is the proper solution but it works for me.\n\n--- commons-jxpath-1.3-src/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\t2008-07-30 09:31:20.000000000 -0700\n+++ ../commons-jxpath-1.3-src/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\t2010-04-13 18:04:48.592423397 -0700\n@@ -58,7 +58,7 @@\n                 EvalContext ctx = (EvalContext) contexts[i];\n                 while (ctx.nextSet()) {\n                     while (ctx.nextNode()) {\n-                        NodePointer ptr = ctx.getCurrentNodePointer();\n+                        NodePointer ptr = ctx.getCurrentNodePointer().getValuePointer();\n                         if (!pointers.contains(ptr)) {\n                             pointers.add(ptr);\n                         }\n@@ -73,4 +73,5 @@\n         }\n         return super.setPosition(position);\n     }\n+    \n }\n",
                "resolved": "2011-06-08",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-145",
                "project": "Commons JXPath",
                "title": "Problem Setting Value to an XPath containing a \"+\" in the XPATH Name",
                "type": "Bug",
                "description": "Hi,\n\nHere is the code which fail into Exception:\n\n{code}\n    Trade trade = new Trade();\n    JXPathContext ctx = JXPathContext.newContext(trade);\n\n    ctx.setValue(\"keywords\", new Hashtable());\n    ctx.setValue(\"keywords/ExternalSystem\", \"TEST\");\n    ctx.setValue(\"keywords/A+Rate\", \"1.2\");\n{code}\n\nWhen I try to set the value of \"keywords/A+Rate\" I get the Exception:\nException in thread \"main\" org.apache.commons.jxpath.JXPathException: Exception trying to set value with xpath keywords/A+Rate; Cannot set value for xpath: keywords/A+Rate\n\nWhen I change the \"A+Rate\" to \"A-Rate\". It's OK.\n\nIs it a bug or a special feature of XPath ?\n\nThanks\n",
                "resolved": "2011-06-07",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-144",
                "project": "Commons JXPath",
                "title": "Non-existing xpath does not throw exception for LazyDynaBeans",
                "type": "Bug",
                "description": "The following code-snippet prints \"null\" when it should throw an exception:\n\nLazyDynaBean bean = new LazyDynaBean();\nJXPathContext context = JXPathContext.newContext(bean);\nSystem.out.println(context.getValue(\"nonExisting\"));\n\n\nThe problem is that in DynaBeanPropertyPointer:\n\nprotected boolean isActualProperty() {\n        DynaClass dynaClass = dynaBean.getDynaClass();\n        return dynaClass.getDynaProperty(getPropertyName()) != null;\n}\n\nReturns true, even if the property does not exist in LazyDynaBeans. \nThe issue is resolved if the implementation is changed to:\n\nprotected boolean isActualProperty() {\n        DynaClass dynaClass = dynaBean.getDynaClass();\n        if(dynaClass instanceof LazyDynaClass) {\n        \treturn ((LazyDynaClass)dynaClass).isDynaProperty(getPropertyName());\n        } else {\n        \treturn dynaClass.getDynaProperty(getPropertyName()) != null;\n        }\n}",
                "resolved": "2011-06-07",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-143",
                "project": "Commons JXPath",
                "title": "JXPathContext.iterate does not work with null value in LazyDynaBean",
                "type": "Bug",
                "description": "The following code fails with a NoSuchElementException:\n\nLazyDynaBean bean = new LazyDynaBean();\nbean.set(\"test\", null);\t\t\nJXPathContext context = JXPathContext.newContext(bean);\ncontext.iterate(\"test\").next();\n\nReplacing the value in the bean for anything but null works as expected.",
                "resolved": "2011-06-07",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-142",
                "project": "Commons JXPath",
                "title": "DynamicBean with null name property",
                "type": "Bug",
                "description": "VariablePointer.getImmediateValuePointer() on line 127 creates a DynamicPointer with name==null :\n{code}\n    public NodePointer getImmediateValuePointer() {\n        if (valuePointer == null) {\n        ...\n            if (actual) {\n        ...\n                valuePointer =\n                    NodePointer.newChildNodePointer(this, null, value);\n            }\n        ...\n        }\n        return valuePointer;\n    }\n{code}\nthen DynamicPointer.equals(...) or DynamicPointer.hashCode() throws NPE.",
                "resolved": "2011-06-07",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-140",
                "project": "Commons JXPath",
                "title": "Error in loop of NamespaceResolver",
                "type": "Bug",
                "description": "In org.apache.commons.jxpath.ri.NamespaceResolver#String getPrefix(NodePointer pointer, String namespaceURI) \n\nThe loop variable is supposed to be changed in this way:\n\ncurrentPointer = pointer.getParent();\n\nbut I think is a typo, it should be :\n\ncurrentPointer = currentPointer.getParent();\n\nI encountered an endless loop while calling toString() on a pointer\n",
                "resolved": "2011-06-07",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-139",
                "project": "Commons JXPath",
                "title": "Wrong xpath expression passed to extension function does not throw JXPathNotFoundException",
                "type": "Bug",
                "description": "If xpath expression, which do not map to bean properties, is passed to extension function, JXPathNotFoundException is not thrown. It seems inconsistent behaviour and it is difficult to test these expressions if they do not fail for example after code refactoring.\n\nHere is a test case:\n\n\n{code}\n// Extension function\npublic static class StringFunctions {\n\tpublic static String left(String param, int len) {\n\t\tSystem.out.println(\"Received: '\" + param + \"'\");\n\t\tif(param == null) return null;\n\t\treturn param.substring(0, Math.min(len, param.length()));\n\t}\n}\n{code}\n\n{code}\n// Value object to use\npublic class VO {\n\tString value = null;\n\tpublic String getValue() { return value; }\n\tpublic void setValue(String value) { this.value = value; }\n}\n\n{code}\n{code}\n@Test\npublic void testLeftFunctionWrongPath() {\n\tVO vo = new VO();\n\tvo.setValue(\"1234567890\");\n\n\tJXPathContext ctx = JXPathContext.newContext(vo);\n\n\tctx.setFunctions(new ClassFunctions(StringFunctions.class, \"util\"));\n\t\n\t// OK, StringFunctions.left() receives \"1234567890\"\n\tpath = \"util:left(value, 5)\";\n\tctx.getValue(path);\n\t\n\t// JXPathNotFoundException is not thrown, StringFunctions.left() receives an empty string\n\tString wrongPath = \"util:left(valueXXX, 5)\";\n\tctx.getValue(wrongPath);\n}\n{code}",
                "resolved": "2012-01-20",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-135",
                "project": "Commons JXPath",
                "title": "Potential infinite loop in NamespaceResolver.getPrefix()",
                "type": "Bug",
                "description": "There appears to be an inifinite loop in org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix().  While I haven't yet been able to create a minimal test app that reproduces the problem, the bug seems fairly self-evident from the code.\n\n{code}\nprotected static String getPrefix(NodePointer pointer, String namespaceURI) {\n        NodePointer currentPointer = pointer;\n        while (currentPointer != null) {\n            NodeIterator ni = currentPointer.namespaceIterator();\n            for (int position = 1; ni != null && ni.setPosition(position); position++) {\n                NodePointer nsPointer = ni.getNodePointer();\n                String uri = nsPointer.getNamespaceURI();\n                if (uri.equals(namespaceURI)) {\n                    String prefix = nsPointer.getName().getName();\n                    if (!\"\".equals(prefix)) {\n                        return prefix;\n                    }\n                }\n            }\n            currentPointer = pointer.getParent();\n        }\n        return null;\n    }\n{code}\n\nThe problem line is the last line in the loop: 'currentPointer = pointer.getParent();'.  As the 'pointer' variable never changes, the value of 'currentPointer' never changes between loop iterations after the second iteration.  Consequently if the namespace prefix is not found in the first two iterations, an infinite loop occurs.  The problem seems to be resolved by changing that line to 'currentPointer = currentPointer.getParent();'.",
                "resolved": "2010-03-03",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-133",
                "project": "Commons JXPath",
                "title": "Cloning the node pointers and '==' node pointers comparison",
                "type": "Bug",
                "description": "During the implementation of JCR nodes support in JXPath (extending NodePonter's, NodeIterator's, NodePointerFactory ) I faced with the following situation: I was running a xpath query against the context (JXPathContext instance) like:\n\ncontext.iteratePointers(\"/child::* | @ * \")\n\nAfter that I got an exception JXPathException: \"Cannot compare pointers that do not belong to the same tree: '/home' and '/home' \" thrown from NodePointer.compareNodePointers(...) method. After debugging this case I've found that for the node pointers extracted via the \"/child::* | @ * \" xpath expression NodePointer.compareTo(Object) was invoked (and consequently NodePointer.compareNodePointers(...) ). In fact all node pointers matching the \"/child::* | @ * \" xpath expression had the same node pointer (I checked it against my implementations of NodePointerFactory, NodeIterator's etc.). But as I found for these node pointers they were initialized with different clones of the same parent node pointer. And the result was that in NodePointer.compareTo(Object) method the following \"==\" comparison evaluated in false for the different clones of the same parent node pointer:\n\n        if (parent == pointer.parent) {\n            return parent == null ? 0 : parent.compareChildNodePointers(this, pointer);\n        }\n\nAs the workaround for this case I overrode the clone method for my NodePointer descendants to return 'this'. I think there is some misbalance made between the  usage of clone () method of NodePointer's and \"==\" comparison of NodePointers.\n",
                "resolved": "2010-03-02",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-129",
                "project": "Commons JXPath",
                "title": "MethodLookupUtils#matchType uses TypeUtils#canConvert which causes \"Ambiguous method call\" exception.",
                "type": "Bug",
                "description": "MethodLookupUtils#matchParameterTypes calls MethodUtils#matchType.  \n\nMethodLookupUtils#matchType includes this:\n\n        if (TypeUtils.canConvert(object, expected)) {\n            return APPROXIMATE_MATCH;\n        }\n\nThis goes through a whole process of attempting to convert types using JXPath-specific conversion routines.  However, this is not valid logic when attempting to find matching Methods since overloaded functions with \"convertable\" parameters would still have different function signatures.\n\nAn example:\n\nabstract class ExampleClass\n{\n     static final String formatISO(Calendar calendar) { return \"\"};\n     static final String formatISO(Date date) { return \"\"};\n}\n\nIf referenced from JXPath with \"ExampleClass.formatISO(pathToDateObject)\", these two functions would trigger JXPathException(\"lookupMethod() Ambiguous method call: \" + name) because apparently TypeUtils is able to convert a Calendar to a Date and vice-versa.\n\nWhen attempting to retrieve a function via signature, is it not irrelevant whether JXPath is able to convert a parameter's type or not?  Is there a way to change this behavior or provide a way to toggle this behavior similar to the setLenient() method.\n\nAlso, the word \"Ambiguous\" is spelled incorrectly as \"Ambigous\" three times in MethodLookupUtils.",
                "resolved": "2010-02-28",
                "versions": [],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "JXPATH-128",
                "project": "Commons JXPath",
                "title": "JXPath support for LazyDynaBean is broken.",
                "type": "Bug",
                "description": "The following code throws a \"java.lang.NegativeArraySizeException\":\n\nLazyDynaBean bean = new LazyDynaBean();\nJXPathContext context = JXPathContext.newContext(bean);\nIterator i = context.iterate(\"anything\");\ni.hasNext();\n\nWhich is due to the fact that in org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPropertyPointer.getPropertyNames() this code:\nboolean hasClass = dynaClass.getDynaProperty(\"class\") != null;\nassumes that hasClass is false if there is no property named \"class\". This is not true for LazyDynaClass (and therefore LazyDynaBean), which documents this feature:\n\n\"This implementation has one slightly unusual default behaviour - calling the getDynaProperty(name) method for a property which doesn't exist returns a DynaProperty rather than null. [...] For this reason the isDynaProperty(name) method has been added to this implementation in order to determine if a property actually exists.\"\n\nSo I guess a solution would be to check if it's a LazyDynaClass and check the existance of the property using \"isDynaProperty(name)\" instead.",
                "resolved": "2009-01-29",
                "versions": [
                    "1.3"
                ],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "JXPATH-125",
                "project": "Commons JXPath",
                "title": "JXPathContext.iteratePointers() does not work with multiple prefixes for a single namespace URI",
                "type": "Bug",
                "description": "Have a look at the following document:\n\n<a:doc xmlns:a=\"ns\">\n  <a:elem />\n  <b:elem xmlns:b=\"ns\" />\n</a:doc>\n\nWe have two elements 'elem' in the same namespace 'ns'.\nThey have a different prefix, however.\n\nWhen we use JXPathContext.iteratePointers() to iterate over them, the first element is returned two times. The second element is not returned.\n\nThis is because\nin class org.apache.commons.jxpath.ri.model.dom.DOMNodePointer\nin method getRelativePositionByName() (line 546)\nwe have:\n\nif (nm.equals(node.getNodeName()))\n\nIn the example, we have\nnm  == \"a:elem\" and node == \"b:elem\"\n\nThus, equals() returns false. But since 'a' and 'b' are just different prefixes for the same namespace URI, we should have 'true'.\n\nI attached a testcase which reproduces the bug.",
                "resolved": "2010-02-27",
                "versions": [
                    "1.2 Final",
                    "1.3"
                ],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "JXPATH-123",
                "project": "Commons JXPath",
                "title": "Regression:  \"fix\" made to NamespaceResolver broke existing testcases",
                "type": "Bug",
                "description": "Relatively shortly after introducing NamespaceResolver, Dmitri had changed it to wipe out the reverse mapping cache every time a new mapping was added.  The tests, however, relied upon the last added mapping to a given namespace being the preferred prefix.  The description for his change was that he was fixing a \"bug\", but since he didn't elaborate on what kind of bug I can't see how maintaining the cache is any more harmful than not maintaining it, and reverting this change clears up the test failures that for some reason are only seen on JDK 1.3.",
                "resolved": "2008-06-11",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-121",
                "project": "Commons JXPath",
                "title": "Maven compile dependency on servlet-2.2",
                "type": "Bug",
                "description": "JXPath 1.2 appears to have a \"compile\" dependency on the Servlet API version 2.2.  It should be changed in the pom.xml to be a \"provided\" dependency so that it doesn't get deployed to the web server.  Just add the <scope> as follows in the pom.xml file.\n\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>servlet-api</artifactId>\n      <version>2.2</version>\n      <scope>provided</scope>\n    </dependency>\n",
                "resolved": "2008-05-25",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-120",
                "project": "Commons JXPath",
                "title": "ClassCastException in ServletRequestHandler.setProperty()",
                "type": "Bug",
                "description": "Setting a property on a JXPath context bound to a ServletRequest throws a ClassCastException. The request parameter in ServletRequestHandler.setProperty() should be cast into a ServletRequestAndContext instead of a ServletRequest.",
                "resolved": "2008-05-02",
                "versions": [],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-118",
                "project": "Commons JXPath",
                "title": "wrongs xpath string from pointer.asPath()",
                "type": "Bug",
                "description": "Hello ! \nafter playing around awhile with JXPath and Jdom i guess i've found a bug:\n\nwhen trying to iterate over a html document parsed with jdom in this way:\n\n{code:java}\niterator = context.iteratePointers(\"/HTML[1]/BODY[1]/P[3]/TABLE[1]/TR/TD[3]\");\n                 \n                 while(iterator.hasNext()){\n                     Pointer pointer = (Pointer)iterator.next();\n                     System.out.println(\"path:\"+ pointer.asPath()+\":\"+((Content)pointer.getNode()).getValue());\n                 }\n{code}\n\ni get some wrong outputs.\n\nthis shows sometime the wrong path for example:\n/HTML[1]/BODY[1]/P[3]/TABLE[1]/TR[2]/TD[1]\nbut the value found is correct. I\n\ni would expect for example\n/HTML[1]/BODY[1]/P[3]/TABLE[1]/TR[2]/TD[3]\n\nAm i wrong or is this a bug !? \ngreetings\n  david croe\n\n\n\n",
                "resolved": "2015-11-24",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-115",
                "project": "Commons JXPath",
                "title": "Issue with attribute::",
                "type": "Bug",
                "description": "Checking test (Issue172_CountAttributeNode) I came with the following fix for the code in AttributeContext  line 72\nfrom \n-----\nif (!(nodeTest instanceof NodeNameTest)) {\n                return false;\n            }\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            \n------\n'\nto \n--- (outside method)\nprivate static final QName WILDCARD = new QName(\"\", \"*\");\n--- (in method)\n    \nfinal QName name ;\nif (nodeTest instanceof NodeTypeTest)\n{\n\t if (((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE)\n\t\t name = WILDCARD;\n\t else return false;\n}\nelse if (nodeTest instanceof NodeNameTest) {\n\tname = ((NodeNameTest) nodeTest).getNodeName();\n}\nelse\n{\n\treturn false;\n}\n\n\n",
                "resolved": "2008-02-03",
                "versions": [],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-114",
                "project": "Commons JXPath",
                "title": "node() implementation in DOM and JDOM model",
                "type": "Bug",
                "description": "I think that the code in DOMNodePointer.java, line 120 is wrong because considers only element and document to be matched by node().\nwhile instead it matches any node that pass from there.\n\ncase Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n\nshould be changed to \n\ncase Compiler.NODE_TYPE_NODE :\n                    return true;\n\nSame in JDOMNodePointer, line 391\n\n                  return true;//(node instanceof Element) || (node instanceof Document);\n\n",
                "resolved": "2008-02-02",
                "versions": [],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-113",
                "project": "Commons JXPath",
                "title": "NullPointerException in ChildContext when document only contains an empty root node",
                "type": "Bug",
                "description": "In ChildContext I get a NullPointerException, the error appears in method prepare()\n\n{code:java}\n    iterator = (startFromParentLocation ? parent.getParent() : parent).childIterator(nodeTest,\n                reverse, startFromParentLocation ? parent : null);\n{code}\n    \nshould be changed in my opinion to\n\n{code:java}\nfinal NodePointer actualParent = startFromParentLocation ? parent.getParent() : parent;\n        iterator = actualParent==null ? null : actualParent.childIterator(nodeTest,\n                reverse, startFromParentLocation ? parent : null);\n{code}\n\nThe tests triggering the error are testIssue172_CountFollowingSiblingNode and testIssue172_CountPrecedingSiblingNode",
                "resolved": "2015-11-24",
                "versions": [],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "JXPATH-111",
                "project": "Commons JXPath",
                "title": "ClassCastException in PrecedingOrFollowingContext",
                "type": "Bug",
                "description": "in PrecedingOrFollowingContext  at line 151\nI believe the code should be changed, from\n\nit = (PropertyIterator) stack.peek();\n                            \nto\n\nit = (NodeIterator) stack.peek();\n\nTest case:\n\ncount(//preceding::node())\n\n<root><a1><b1/><b2/></a1><a2/></root>\n    \n\n",
                "resolved": "2007-12-24",
                "versions": [
                    "1.3"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-110",
                "project": "Commons JXPath",
                "title": "When JXPathContext.newContext(object) holds a collection of Hibernate proxy entities, and search performed, LazyInitializationException illegal access to loading collection",
                "type": "Bug",
                "description": "In the O/R model The entity WirelessDevice has all its properties with fetch = FetchType.LAZY\n\nFirst, using annotation style Hibernate,  I find all wirelessDevices (proxies) with a named query, with some but not all of the collection properties fetched.  What this means is that a property xyz must be accessed from the wirelessDevice proxy as follows getXyz(), NOT by invoking xyz directly.  Because accessing the latter way will result in the exception \"LazyInitializationException: illegal access to loading collection.\"  However, when getXyz() is invoked, the proxy will return the correct value (because it is attached to a live Hibernate session).\n\nFYI, here is the named Hibernate query: \"select d from WirelessDevice d left join fetch d.marketData marketData left join fetch d.wirelessTechnologyTypes left join fetch d.anatomy anatomy left join fetch anatomy.geometry\".\n\nAny way when I do the following in JxPath , a LazyInitializationException occurs presumable because properties are not being accessed via getters, but rather directly:\n\n\t\tJXPathContext context = JXPathContext.newContext(blah blah);\n\t\tIterator<T> i = context.iterate(\"/wirelessDevices[marketData/operators/address/countryType/regionType/id='8']\");\n\nHEre is the exact stack trace:\n\n\norg.hibernate.LazyInitializationException 2007-12-21 18:52:07,915 -- ERROR -- illegal access to loading collection\norg.hibernate.LazyInitializationException: illegal access to loading collection\n\tat org.hibernate.collection.AbstractPersistentCollection.initialize(AbstractPersistentCollection.java:341)\n\tat org.hibernate.collection.AbstractPersistentCollection.read(AbstractPersistentCollection.java:86)\n\tat org.hibernate.collection.AbstractPersistentCollection.readSize(AbstractPersistentCollection.java:109)\n\tat org.hibernate.collection.PersistentBag.size(PersistentBag.java:225)\n\tat org.apache.commons.jxpath.util.ValueUtils.getLength(ValueUtils.java:141)\n\tat org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getLength(BeanPropertyPointer.java:196)\n\tat org.apache.commons.jxpath.ri.model.beans.PropertyIterator.getLength(PropertyIterator.java:295)\n\tat org.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPositionIndividualProperty(PropertyIterator.java:148)\n\tat org.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPosition(PropertyIterator.java:127)\n\tat org.apache.commons.jxpath.ri.axes.ChildContext.setPosition(ChildContext.java:106)\n\tat org.apache.commons.jxpath.ri.axes.ChildContext.nextNode(ChildContext.java:89)\n\tat org.apache.commons.jxpath.ri.EvalContext.nextSet(EvalContext.java:322)\n\tat org.apache.commons.jxpath.ri.EvalContext.nextSet(EvalContext.java:321)\n\tat org.apache.commons.jxpath.ri.EvalContext.nextSet(EvalContext.java:321)\n\tat org.apache.commons.jxpath.ri.EvalContext.nextSet(EvalContext.java:321)\n\tat org.apache.commons.jxpath.ri.EvalContext.performIteratorStep(EvalContext.java:159)\n\tat org.apache.commons.jxpath.ri.EvalContext.hasNext(EvalContext.java:118)\n\tat org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.contains(CoreOperationCompare.java:86)\n\tat org.apache.commons.jxpath.ri.compiler.CoreOperationCompare.equal(CoreOperationCompare.java:73)\n\tat org.apache.commons.jxpath.ri.compiler.CoreOperationEqual.computeValue(CoreOperationEqual.java:33)\n\tat org.apache.commons.jxpath.ri.axes.PredicateContext.nextNode(PredicateContext.java:81)\n\tat org.apache.commons.jxpath.ri.EvalContext.performIteratorStep(EvalContext.java:155)\n\tat org.apache.commons.jxpath.ri.EvalContext.hasNext(EvalContext.java:118)\n\tat org.apache.commons.jxpath.ri.compiler.Expression$ValueIterator.hasNext(Expression.java:128)\n\tat com.qualcomm.crowd.dao.InMemoryQueryEngine.findInMemoryEntitysByCriteria(InMemoryQueryEngine.java:50)\n\tat com.qualcomm.crowd.service.WirelessDeviceManagerImpl.findInMemoryWirelessDevicesByCriteria(WirelessDeviceManagerImpl.java:99)\n\tat com.qualcomm.crowd.service.WirelessDeviceManagerImpl.findOperatorAliasesByRegionType(WirelessDeviceManagerImpl.java:140)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:304)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:106)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)\n\tat org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)\n\tat $Proxy40.findOperatorAliasesByRegionType(Unknown Source)\n\tat com.qualcomm.crowd.controller.WirelessDeviceController.findOperatorAliasesByRegionType(WirelessDeviceController.java:298)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat org.springframework.web.servlet.mvc.multiaction.MultiActionController.invokeNamedMethod(MultiActionController.java:446)\n\tat org.springframework.web.servlet.mvc.multiaction.MultiActionController.handleRequestInternal(MultiActionController.java:384)\n\tat org.springframework.web.servlet.mvc.AbstractController.handleRequest(AbstractController.java:153)\n\tat sun.reflect.GeneratedMethodAccessor176.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:304)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)\n\tat org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:50)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:160)\n\tat org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)\n\tat org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)\n\tat $Proxy42.handleRequest(Unknown Source)\n\tat org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter.handle(SimpleControllerHandlerAdapter.java:48)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:858)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:792)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:476)\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:431)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:690)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:803)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:269)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:188)\n\tat org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:265)\n\tat org.acegisecurity.intercept.web.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:107)\n\tat org.acegisecurity.intercept.web.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:72)\n\tat org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)\n\tat org.acegisecurity.ui.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:166)\n\tat org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)\n\tat org.acegisecurity.providers.anonymous.AnonymousProcessingFilter.doFilter(AnonymousProcessingFilter.java:125)\n\tat org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)\n\tat org.acegisecurity.wrapper.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:81)\n\tat org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)\n\tat org.acegisecurity.ui.AbstractProcessingFilter.doFilter(AbstractProcessingFilter.java:271)\n\tat org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)\n\tat org.acegisecurity.ui.logout.LogoutFilter.doFilter(LogoutFilter.java:110)\n\tat org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)\n\tat org.acegisecurity.context.HttpSessionContextIntegrationFilter.doFilter(HttpSessionContextIntegrationFilter.java:249)\n\tat org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)\n\tat org.acegisecurity.util.FilterChainProxy.doFilter(FilterChainProxy.java:149)\n\tat org.acegisecurity.util.FilterToBeanProxy.doFilter(FilterToBeanProxy.java:98)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:215)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:188)\n\tat org.springframework.orm.hibernate3.support.OpenSessionInViewFilter.doFilterInternal(OpenSessionInViewFilter.java:198)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:75)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:215)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:188)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:210)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:174)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:117)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:108)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:151)\n\tat org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:870)\n\tat org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:665)\n\tat org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:528)\n\tat org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:81)\n\tat org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:685)\n\tat java.lang.Thread.run(Unknown Source)\n\n",
                "resolved": "2007-12-22",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-109",
                "project": "Commons JXPath",
                "title": "Namespaced attribute not selected with wildcard",
                "type": "Bug",
                "description": "With expression:\n\nxml/@*\n\nOn xml:\n\n<xml xmlns:x='foo' x:pop='a'/>\n\nselectSingleNode returns null, @x:* works fine.\n\nPossible Fix:\n\nIn DOMAttributeIterator, line 84\n\nif (equalStrings(testPrefix, nodePrefix)) {\n                return true;\n            }\n\nshould probably be changed to\n\nif (testPrefix==null || equalStrings(testPrefix, nodePrefix)) {\n                return true;\n            }\n",
                "resolved": "2008-02-03",
                "versions": [],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-107",
                "project": "Commons JXPath",
                "title": "RCN: Nullcheck of NodePointer.parent of value previously dereferenced in PropertyOwnerPointer.setValue(Object)",
                "type": "Bug",
                "description": "In class PropertyOwnerPointer, method setValue\n\nThe code says first \n\nif (parent.isContainer()) ...\n\nthen it checks for parent not being null.\n\nelse if (parent != null) {\n\nIf the parent could be null the first code\nwould trigger a null pointer exception.\n\nSo I think:\n\nnow the parent happens to be never null\nbut either \n1. the (parent!=null) check is unecessary \n(I don't know the exact semantics of this class)\n2. or more probably the {parent.isContainer()} block should be put inside\nthe {parent!=null} check.\n\nAn other findbugs find.\n",
                "resolved": "2007-12-11",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-106",
                "project": "Commons JXPath",
                "title": "Typo in JXPathException.getMessage()",
                "type": "Bug",
                "description": "In JXPathException, method getMessage():\n\n        if (message == null) {\n            buf.append(message).append(\"; \");\n        }\n        \nShould probably be \n\n        if (message != null) {\n            buf.append(message).append(\"; \");\n        }\n \nI am running findbugs on the project.       ",
                "resolved": "2007-12-11",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-105",
                "project": "Commons JXPath",
                "title": "BasicNodeSet.getNodes() returns values instead of nodes ?",
                "type": "Bug",
                "description": "In BasicNodeSet the method getNodes()  \nadds the values instead of the nodes, using  \n\nnodes.add(pointer.getValue()); \n\ninstead of  what I think correct:\n\nnodes.add(pointer.getNode());\n\nMichele Vivoda\n           ",
                "resolved": "2007-12-14",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-104",
                "project": "Commons JXPath",
                "title": "selectSingleNode() from a map should not select map values keyed by strings with embedded colons using namespaced element syntax",
                "type": "Bug",
                "description": "http://mail-archives.apache.org/mod_mbox/commons-user/200710.mbox/%3c5149CDBF9C1DD74EB9A1327B47BC2869028E4DAC@resmsg01.AME.ad.sag%3e\n\nSummary:  selectNodes() treats colon as ns, while selectSingleNode() treats it as part of the string key.  Which is correct is debatable, but some consistent solution must be identified/implemented.",
                "resolved": "2007-12-05",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-103",
                "project": "Commons JXPath",
                "title": "createPathAndSetValue(...) differs from createPath(...).setValue(...) : \"Factory is not set\"",
                "type": "Bug",
                "description": "Hi!\n\nIf I have a bean (as shown below), I guess it is an error that the second of the next two calls does not work:\n\n        JXPathContext.newContext(new TestBean()).createPathAndSetValue(\"/attrib\", \"val\");\n        JXPathContext.newContext(new TestBean()).createPath(\"/attrib\").setValue(\"val\");\n\nThe first one works, but the second one throws up:\norg.apache.commons.jxpath.JXPathException: Exception trying to create xpath /attrib; Factory is not set on the JXPathContext - cannot create path: /attrib\n\tat org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath(JXPathContextReferenceImpl.java:450)\n\tat org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath(JXPathContextReferenceImpl.java:427)\n\nThe bean is as follows:\n\n    public static class TestBean {\n        public String plainattrib;\n        private String attrib;\n        public String getAttrib() {\n            return attrib;\n        }\n        public void setAttrib(String attrib) {\n            this.attrib = attrib;\n        }\n    }\n\n(Don't ask: I cannot use the first method, since I have to pass around the Pointer.)\n\nThanks so much,\n\nHans-Peter\n",
                "resolved": "2007-09-24",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-102",
                "project": "Commons JXPath",
                "title": "Core rounding functions don't handle NaN or infinite values correctly",
                "type": "Bug",
                "description": "        assertXPathValue(context, \"floor('NaN')\", new Double(Double.NaN));\n        assertXPathValue(context, \"floor(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n        assertXPathValue(context, \"floor(2 div 0)\", new Double(Double.POSITIVE_INFINITY));\n\n        assertXPathValue(context, \"ceiling('NaN')\", new Double(Double.NaN));\n        assertXPathValue(context, \"ceiling(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n        assertXPathValue(context, \"ceiling(2 div 0)\", new Double(Double.POSITIVE_INFINITY));\n\n        assertXPathValue(context, \"round('NaN')\", new Double(Double.NaN));\n        assertXPathValue(context, \"round(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n        assertXPathValue(context, \"round(2 div 0)\", new Double(Double.POSITIVE_INFINITY));",
                "resolved": "2007-08-27",
                "versions": [
                    "1.3"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-101",
                "project": "Commons JXPath",
                "title": "Original context from VariableContextWrapper is not visible",
                "type": "Bug",
                "description": "variable \"context\" is not accessable outside of org.apache.commons.jxpath.ri.model package - unable to extend VariablePointerFactory.",
                "resolved": "2007-08-27",
                "versions": [
                    "1.3"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-100",
                "project": "Commons JXPath",
                "title": "Core union operation does not sort result nodes according to document order",
                "type": "Bug",
                "description": "Source document:\n<MAIN><A>avalue</A><B>bvalue</B></MAIN>\n\nAccording to string() function defintion:\n\"A node-set is converted to a string by returning the string-value of the node in the node-set that is first in document order. If the node-set is empty, an empty string is returned.\"\n\nFollowing XPath calculated incorrectly:\n string(/MAIN/B | /MAIN/A)\n\nExpected result: \"avalue\"\nActual value: \"bvalue\"\n\nReason:\nsorting of result nodes is missing from CoreOperationUnion",
                "resolved": "2007-08-27",
                "versions": [
                    "1.2 Final",
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-99",
                "project": "Commons JXPath",
                "title": "JXPath works incorrectly with CyberNeko HtmlParser",
                "type": "Bug",
                "description": "I don't know exactly where is the bug. I have an idea, that CyberNeko html parser creates some wired w3c DOM representation of html file, and that is the cause. Here is a code sample:\n// ---------------------------\n       // create CyberNeko html parser \n        DOMParser parser = new DOMParser();\n        // this page does have //input[@name='q'] field\n        parser.parse(\"http://google.com\");\n        Document doc = parser.getDocument();\n\n        // JXPATH TEST\n        JXPathContext context = JXPathContext.newContext(doc);\n        List nodes1 = context.selectNodes(\"//input[@name='q']\"); // ERROR IS HERE: call returns nothing, must return 1 node\n        List nodes2 = context.selectNodes(\"//*\"); // returnes 78 nodes\n        System.out.println(nodes1.toString());\n        System.out.println(nodes2.toString());\n\n        // XPathFactory TEST  ( for comparison )\n        // error, returns nothing\n        Object list1 = XPathFactory.newInstance().newXPath().compile(\"//input[@name='q']\").evaluate(doc, XPathConstants.NODESET);\n        // returns 79 nodes\n        Object list2 = XPathFactory.newInstance().newXPath().compile(\"//*\").evaluate(doc, XPathConstants.NODESET);\n        System.out.println(list1);\n        System.out.println(list2);\n// -----------------------------------\n\nIs it possible to fix this problem inside JXPath? Or is it only html parser problem?",
                "resolved": "2007-10-01",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-98",
                "project": "Commons JXPath",
                "title": "termination problem with empty list",
                "type": "Bug",
                "description": "a list selected by an attribute  (/html:head/model//bind[@id='findMe']) returns correct when at least one entry is found\nbut has a termination problem when empty\n\nan endless cycle: EvalContext: nextSet()->reset() nextNode() -> reset()\nseems to be the problem",
                "resolved": "2007-08-25",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-97",
                "project": "Commons JXPath",
                "title": "Incomplete handling of undefined namespaces",
                "type": "Bug",
                "description": "Mcduffey, Joe <jdmcduf@nsa.gov>\n\nCan someone tell me how to register namespaces so that attributes with namespaces does not cause the exception\n\norg.apache.common.ri.model.dom.DOMNodePointer.createAttribute\nunknown namespace prefix: xsi\n\nFor example the following\n<ElementA  A:myAttr=\"Mytype\">\n  <B:ElementB>MY VALUE</B:ElementB>\n</ElementA>\n\nWould result in the following exception:\norg.apache.common.ri.model.dom.DOMNodePointer.createAttribute\nunknown namespace prefix: A\n\nFYI: In this example there was a namespace decaration in the file and I also manually called the\nregisterNamespace(A,\"/http...\");\nregisterNamespace(B,\"/http...\");\n\nThere was no problem encountered for elements. Only attributes. Can someone help? Thanks.",
                "resolved": "2007-07-25",
                "versions": [
                    "1.2 Final",
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-95",
                "project": "Commons JXPath",
                "title": "Comparing with NaN is incorrect",
                "type": "Bug",
                "description": "'NaN' > 'NaN' is true, but should be FALSE",
                "resolved": "2007-07-11",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-94",
                "project": "Commons JXPath",
                "title": "equality test for multi-valued variables does not conform to spec",
                "type": "Bug",
                "description": "given e.g. variable d={\"a\", \"b\"}, the spec implies that \"$d = 'a'\" and that \"$d = 'b'\".  Instead of iterating the variable's components its immediate content (here, the String[]) is compared, causing the aforementioned assertions to fail.",
                "resolved": "2007-07-10",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-93",
                "project": "Commons JXPath",
                "title": "Binary operators behaviour involving node-sets is incorrect",
                "type": "Bug",
                "description": "According to XPath specification:\n\"If both objects to be compared are node-sets, then the comparison will be true if and only if there is a node in the first node-set and a node in the second node-set such that the result of performing the comparison on the string-values of the two nodes is true. If one object to be compared is a node-set and the other is a number, then the comparison will be true if and only if there is a node in the node-set such that the result of performing the comparison on the number to be compared and on the result of converting the string-value of that node to a number using the number function is true.\"\n\nBut following example illustrates, that this is not a JXPath behaviour:\n\n\n        JXPathContext pathContext = JXPathContext\n                .newContext(DocumentBuilderFactory.newInstance()\n                        .newDocumentBuilder().parse(\n                                new InputSource(new StringReader(\n                                        \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\r\\n\"\n                                                + \"<doc/>\"))));\n        Boolean result = (Boolean) pathContext.getValue(\"2.0 > child1\",\n                Boolean.class);\n        assertFalse(result.booleanValue());\n\n\"child1\" is not found - right operand node set is empty, but result is TRUE, instead of FALSE.\n\nPlease, check greaterThan(), lesserThan(), etc methods of org.apache.xpath.objects.XObject for possible solution :)",
                "resolved": "2007-07-13",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-90",
                "project": "Commons JXPath",
                "title": "Upper boundary check is missing from substring(<string>, <number>)",
                "type": "Bug",
                "description": "Test case:\nsubstring( \"\" ,9)",
                "resolved": "2007-06-18",
                "versions": [
                    "1.2 Final",
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-89",
                "project": "Commons JXPath",
                "title": "Cannot compare pointers that do not belong to the same tree",
                "type": "Bug",
                "description": "For XPath \"$var | /MAIN/A\" exception is thrown:\n\norg.apache.commons.jxpath.JXPathException: Cannot compare pointers that do not belong to the same tree: '$var' and ''\n\tat org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:665)\n\tat org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:649)\n\tat org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:649)\n\tat org.apache.commons.jxpath.ri.model.NodePointer.compareTo(NodePointer.java:639)\n\tat java.util.Arrays.mergeSort(Arrays.java:1152)\n\tat java.util.Arrays.sort(Arrays.java:1079)\n\tat java.util.Collections.sort(Collections.java:113)\n\tat org.apache.commons.jxpath.ri.EvalContext.constructIterator(EvalContext.java:176)\n\tat org.apache.commons.jxpath.ri.EvalContext.hasNext(EvalContext.java:100)\n\tat org.apache.commons.jxpath.JXPathContext.selectNodes(JXPathContext.java:648)\n\tat org.apache.commons.jxpath.ri.model.VariablePointerTestCase.testUnionOfVariableAndNode(VariablePointerTestCase.java:76)",
                "resolved": "2007-07-02",
                "versions": [
                    "1.2 Final",
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-87",
                "project": "Commons JXPath",
                "title": "xmlURL field not set in XMLDocumentContainer",
                "type": "Bug",
                "description": "The only symptom of this is that if an exception is thrown, it will never show the url in the debug. \n\n[Found via: http://opensource.fortifysoftware.com/ ]",
                "resolved": "2007-06-08",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-86",
                "project": "Commons JXPath",
                "title": "Children returned instead of self for arrays when using . selector",
                "type": "Bug",
                "description": "The . selector should always return the context node, and the * selector should return child elements.  However, this doesn't work for arrays:\n\nJXPathContext context = JXPathContext.newContext(new HashMap());\ncontext.setValue(\"array\", new String[] {\"one\", \"two\", \"three\"});\ncontext.setValue(\"array2\", new String[][] { {\"a\", \"b\"}, {\"c\", \"d\"}});\ncontext.setValue(\"person\", new Person(\"Bob\", 25));\n\nString[] paths = {\"/array\", \"/array/.\", \"/array/*\", \"/person\", \"/person/.\", \"/person/*\"};\nfor(int i = 0; i < paths.length; i++) {\n\tPointer pointer = context.getPointer(paths[i]);\n\tSystem.out.println(pointer.asPath());\n\tObject value = context.getValue(paths[i]);\n\tSystem.out.println(value);\n\tSystem.out.println();\n}\n\n\nThis produces the following output:\n\n/.[@name='array']\n[Ljava.lang.String;@59b659b6\n\n/.[@name='array'][1]\none\n\n/.[@name='array'][1]/bytes[1]\n111\n\n/.[@name='person']\nnet.cts.jxpathserializer.Person@760076\n\n/.[@name='person']\nnet.cts.jxpathserializer.Person@760076\n\n/.[@name='person']/age\n25\n\n",
                "resolved": "2007-05-30",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-85",
                "project": "Commons JXPath",
                "title": "Restore binary compatibility with JXPath 1.2",
                "type": "Bug",
                "description": "I ran a CLIRR report comparing JXPath 1.2 with the current trunk and it higlighted one issue between the versions:\n\nERROR: 7004: org.apache.commons.jxpath.ri.NamespaceResolver: In method 'public NamespaceResolver()' the number of arguments has changed\n\nLooking at the source NamespaceResolver no longer has a no-parameter constructor - adding this back in would make the upcoming JXPath 1.3 version binary compatible with JXPath 1.2.",
                "resolved": "2007-05-24",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-84",
                "project": "Commons JXPath",
                "title": "reserved word enum is used",
                "type": "Bug",
                "description": "line 3671 in XPathParser uses enum:\n\nfor (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {\n\nwhich fails under java5.",
                "resolved": "2007-05-18",
                "versions": [],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-83",
                "project": "Commons JXPath",
                "title": "JXpath automatically trims string values",
                "type": "Bug",
                "description": "When an xml contains a value with leading or trailing spaces, JXPath trims this value.\nexample: <value>     12324 56</value> is retrieved by JXPath as : '1234 56' while I expect '     1234 56'.\n",
                "resolved": "2007-05-16",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-82",
                "project": "Commons JXPath",
                "title": "ConversionException: Zero length BigInteger",
                "type": "Bug",
                "description": "When JXPath is lenient and asked to return typized value by\n...getValue(..., BigInteger.class)\n\nit should return NULL value, instead of throwing\n\nCaused by: org.apache.commons.beanutils.ConversionException: Zero length BigInteger\n\tat org.apache.commons.beanutils.converters.BigIntegerConverter.convert(BigIntegerConverter.java:117)\n\tat org.apache.commons.jxpath.util.BasicTypeConverter.convert(BasicTypeConverter.java:299)\n\tat org.apache.commons.jxpath.util.TypeUtils.convert(TypeUtils.java:54)\n\tat org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(JXPathContextReferenceImpl.java:373)\n\tat org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(JXPathContextReferenceImpl.java:358)\n\t... 12 more\nCaused by: java.lang.NumberFormatException: Zero length BigInteger\n\tat java.math.BigInteger.<init>(BigInteger.java:275)\n\tat java.math.BigInteger.<init>(BigInteger.java:447)\n\tat org.apache.commons.beanutils.converters.BigIntegerConverter.convert(BigIntegerConverter.java:112)\n\t... 16 more",
                "resolved": "2007-05-04",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-80",
                "project": "Commons JXPath",
                "title": "boolean conversion of javabean getter values returning NULL fails",
                "type": "Bug",
                "description": "According to the JXPath User Guide a Javabean Getter returning NULL, regadless of the type, will be converted bo Boolean FALSE. But trying to build a boolean expression from this fails as the attached testcase shows.\n\nIt seems that the type the bean getter returns matters, as a NULL String for example works as expected.",
                "resolved": "2007-05-18",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-79",
                "project": "Commons JXPath",
                "title": "Error when accessing JXPathContext methods in Concurrent Scenario",
                "type": "Bug",
                "description": "I am getting following error when many parallel threads access JXPathContext methods. \n (But In case of a single thread, It works fine).\n\n\nCaused by: java.lang.NullPointerException\n\tat org.apache.commons.jxpath.JXPathBasicBeanInfo.getPropertyDescriptor(JXPathBasicBeanInfo.java:104)\n\tat org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getPropertyDescriptor(BeanPropertyPointer.java:267)\n\tat org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.isActualProperty(BeanPropertyPointer.java:151)\n\tat org.apache.commons.jxpath.ri.model.beans.PropertyPointer.isActual(PropertyPointer.java:80)\n\tat org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(SimplePathInterpreter.java:191)\n\tat org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(SimplePathInterpreter.java:142)\n\tat org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(SimplePathInterpreter.java:232)\n\tat org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(SimplePathInterpreter.java:142)\n\tat org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesPropertyOwner(SimplePathInterpreter.java:232)\n\tat org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(SimplePathInterpreter.java:142)\n\tat org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleLocationPath(SimplePathInterpreter.java:77)\n\tat org.apache.commons.jxpath.ri.compiler.Path.getSingleNodePointerForSteps(Path.java:153)\n\tat org.apache.commons.jxpath.ri.compiler.LocationPath.computeValue(LocationPath.java:82)\n\tat org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(JXPathContextReferenceImpl.java:314)\n\tat org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(JXPathContextReferenceImpl.java:280)",
                "resolved": "2007-05-21",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-76",
                "project": "Commons JXPath",
                "title": "CompiledExpression not completely thread-safe",
                "type": "Bug",
                "description": "Some classes in compiled expressions are not thread-safe, because they lazily initialize some information that should be initialized at object construction. The classes I've found are Path and ExpressionPath. I've attached a path that fixes the problem. \n\nWhen two threads tried to initialize such an object concurrently, it was possible that the expression was evaluated as simple expression when it should have been evaluated as complex expression. See the two stack traces below (using xpath expression //ExternalData/Order/@id). The first stack trace shows the bug in action, the second how it should look:\n\ncaused by java.lang.UnsupportedOperationException: Not supported node test for attributes: node()\n\tat org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.getNodeIterator(SimplePathInterpreter.java(Compiled Code))\n\tat org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStepNoPredicatesStandard(SimplePathInterpreter.java(Compiled Code))\n\tat org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.doStep(SimplePathInterpreter.java(Compiled Code))\n\tat org.apache.commons.jxpath.ri.axes.SimplePathInterpreter.interpretSimpleLocationPath(SimplePathInterpreter.java(Inlined Compiled Code))\n\tat org.apache.commons.jxpath.ri.compiler.Path.getSingleNodePointerForSteps(Path.java(Inlined Compiled Code))\n\tat org.apache.commons.jxpath.ri.compiler.LocationPath.computeValue(LocationPath.java(Compiled Code))\n\tat org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getPointer(JXPathContextReferenceImpl.java(Compiled Code))\n\tat org.apache.commons.jxpath.ri.JXPathCompiledExpression.selectSingleNode(JXPathCompiledExpression.java(Inlined Compiled Code))\n\nThis replaces the lines starting at Path.getSingleNodePointerForSteps:\n\n        LocationPath(Path).searchForPath(EvalContext) line: 183\t\n        LocationPath(Path).getSingleNodePointerForSteps(EvalContext) line: 159\t\n",
                "resolved": "2007-01-31",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-73",
                "project": "Commons JXPath",
                "title": "ValueUtils should catch IndexOutOfBoundsException instead of ArrayIndexOutOfBoundsException (for XmlBeans support)",
                "type": "Bug",
                "description": "Basically, I want to do createPathAndSetValue on an XmlBean . But, my xpath statement inlcudes a collection (an array, actually), so the missing elements in the array need to be created.\n\nJXPath checks for this condition (ie. that array elements are missing and need to be created) by catching an ArrayIndexOutOfBoundsException.\n\nUnfortunately, XmlBeans does not throw that type of exception. It throws an IndexOutOfBoundsException exception instead. So, instead of detecting that the array is too small and needs to be grown (by calling my AbstractFactory), it just propogates the exception up the chain.\n\nThe fix is quite simple: on line 423 of ValueUtils, just change the \"catch\" clause to catch a \"IndexOutOfBoundsException\" instead. This should not break any existing code since ArrayIndexOutOfBoundsException is actually a subclass of IndexOutOfBoundsException anyway.\n\nI made this fix to my local source tree, and everything works perfectly (ie. existing code did not break, but now I can also use JXPath on top of my XmlBeans beans too with my own custom AbstractFactory).\n\nThanks!\nJames",
                "resolved": "2007-01-10",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-72",
                "project": "Commons JXPath",
                "title": "1.2 binaries lack javadoc",
                "type": "Bug",
                "description": "The most recent JXPath release (1.2) lacks Javadoc in its binary files at http://archive.apache.org/dist/jakarta/commons/jxpath/binaries/.",
                "resolved": "2007-01-05",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-71",
                "project": "Commons JXPath",
                "title": "Ponter.asPath() return values not always correct",
                "type": "Bug",
                "description": "String returned by Pointer.asPath() is incorrect when path starts with '//' and target is a collection. The path returned always has a final subscript equal to the size of the collection, although Pointer.getValue() still returns the correct element  in each case. Below are two classes and a JUnit testcase which reproduce the bug and isolate it to the case where the path starts with '//' and the target is a collection.\n\nI found this problem whilst trying to write the equivalent of XPathExplorer for my JXPath-based object trees. It does't affect the main app, as getValue() always returns the correct node, but in my explorer it only ever highlights the last element in any collection (the objects in my trees aren't always unique so the path is only way to identify them individually and allow the matching nodes to be highlighted).\n\nOtherwise an excellent, easy-to-use and really useful package. \n\n///////////////////////////////////////  Parent.java  //////////////////////////////////////////////////////////////////////////////////\npackage test;\n\nimport java.util.ArrayList;\n\npublic class Parent {\n\tprivate int id;\n\n\tprivate ArrayList<Child> kids;\n\n\tpublic Parent(int id) {\n\t\tthis.id = id;\n\t\tthis.kids = new ArrayList<Child>();\n\t}\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic ArrayList<Child> getKids() {\n\t\treturn kids;\n\t}\n\n\tpublic void addKid(Child kid) {\n\t\tkids.add(kid);\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic void setKids(ArrayList<Child> kids) {\n\t\tthis.kids = kids;\n\t}\n}\n\n/////////////////////////////////////////////////////////// Child.java /////////////////////////////////////////////////////////////////////////////////////////////////////////////\npackage test;\n\npublic class Child {\n\tprivate int id;\n\n\tpublic Child(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n}\n\n///////////////////////////////////////////////////////////  TestPointerToPath.java ///////////////////////////////////////////////////////////////////////////\npackage test;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport junit.framework.TestCase;\n\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.Pointer;\n\npublic class TestPonterToPath extends TestCase {\n\tprivate Parent parent;\n\tprivate Set<String> expectedPaths, actualPaths;\n\tprivate Set<Object> actualObjects, expectedObjects;\n\tprivate JXPathContext ctx;\n\t\n\tprivate static final int SIZE = 4;\n\t\n\tpublic void setUp() {\n\t\tparent = new Parent(1);\n\t\tfor (int i = 1; i <= SIZE; i++) {\n\t\t\tparent.addKid(new Child(i));\n\t\t}\t\t\n\t\texpectedPaths = new HashSet<String>();\n\t\texpectedObjects = new HashSet<Object>();\n\t\tactualPaths = new HashSet<String>();\n\t\tactualObjects = new HashSet<Object>();\n\t\tctx = JXPathContext.newContext(parent);\n\t}\n\t\n\tprivate void doExpected(String path1, String path2) {\n\t\tfor (int i = 1; i <= SIZE; i++) {\n\t\t\tPointer p = ctx.getPointer(path1 + i + path2);\n\t\t\texpectedPaths.add(p.asPath());\n\t\t\texpectedObjects.add(p.getValue());\n\t\t}\n\t\tassertEquals(SIZE, expectedPaths.size());\n\t\tassertEquals(SIZE, expectedObjects.size());\n\t}\n\t\n\tprivate void doActual(String path) {\n\t\tIterator it = ctx.iteratePointers(path);\n\t\twhile (it.hasNext()) {\n\t\t\tPointer p = (Pointer) it.next();\n\t\t\tactualPaths.add(p.asPath());\n\t\t\tactualObjects.add(p.getValue());\n\t\t}\n\t\tassertEquals(SIZE, actualObjects.size());\n\t}\n\n\tpublic void testToPathLeafAbs() {\n\t\tdoExpected(\"/kids[\", \"]/id\");\n\t\tdoActual(\"/kids/id\");\n\t\tassertEquals(expectedObjects, actualObjects);\n\t\tassertEquals(expectedPaths, actualPaths);\n\t}\n\n\tpublic void testToPathLeafRel() {\n\t\tdoExpected(\"//kids[\", \"]/id\");\n\t\tdoActual(\"//kids/id\");\n\t\tassertEquals(expectedObjects, actualObjects);\n\t\tassertEquals(expectedPaths, actualPaths);\n\t}\n\n\tpublic void testToPathCollectionAbs() {\n\t\tdoExpected(\"/kids[\", \"]\");\n\t\tdoActual(\"/kids\");\n\t\tassertEquals(expectedObjects, actualObjects);\n\t\tassertEquals(expectedPaths, actualPaths);\n\t}\n\t\n\tpublic void testToPathCollectionRel() {\n\t\tdoExpected(\"//kids[\", \"]\");\n\t\tdoActual(\"//kids\");\n\t\tassertEquals(expectedObjects, actualObjects);\n\t\t/* next test fails as all actualPaths are /kids[SIZE] */\n\t\tassertEquals(expectedPaths, actualPaths);\n\t}\n\t\n}\n\n",
                "resolved": "2007-01-05",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-70",
                "project": "Commons JXPath",
                "title": "Javadoc missing from distribution",
                "type": "Bug",
                "description": "The javadoc is missing from the 1.2 zip file.  Broken links in the user guide and elsewhere in the documentation reference the missing directory at docs/apidocs where the javadoc should be.",
                "resolved": "2007-01-05",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-69",
                "project": "Commons JXPath",
                "title": "JXPath doesn't properly search for XBeanInfo defined for a parent class.",
                "type": "Bug",
                "description": "class A { ... }\nclass B extends A { ... }\nclass AXBeanInfo implmements JXPathBeanInfo { ... }\n\nNow if I try to\n   JXPathContext.newContext( new B() )\nit will fail to read the XBeanInfo of the base class (A), and will use simplebeaninfo instead.\n\nif instead I first do \n   JXPathContext.newContext( new A() )\nand then do the \n   JXPathContext.newContext( new B() )\n\nit will work.\n(it will probably work if A implemented the JXPathBeanInfo interface by itself, but I don't want it to require that. my current workarround is to do the above dummy context initialization)\n",
                "resolved": "2007-02-19",
                "versions": [],
                "fixVersions": [
                    "1.2 Final"
                ]
            },
            {
                "issue_id": "JXPATH-68",
                "project": "Commons JXPath",
                "title": "StackOverflow error on a call to 'JXPathContext.createPath()'",
                "type": "Bug",
                "description": "I'm running into a StackOverflow error on a call to\n'JXPathContext.createPath()' whenever I have a path that looks like\n'a/b[1]/c'.  I took a quick look at the code and it appears JXPath, when\ntrying to create its parent pointer, simply recreates an equivalent\npointer(???).\n\nHere is code to reproduce the problem.\n\n\n    Map map = new HashMap();\n    map.put(\"a\", null);\n    \n    JXPathContext pathContext = JXPathContext.newContext(map);\n    pathContext.setFactory(new AbstractFactory() {\n      public boolean createObject(\n          JXPathContext context, Pointer pointer, Object parent, String\nname, int index) {\n\n        Map parentMap = (Map)parent;\n        System.out.println(parent + \":\" + name + \":\" + index);\n        if (index > -1) {\n          List list = (List)parentMap.get(name);\n          if (list == null) {\n            list = new ArrayList();\n          }\n          int size = list.size();\n          for (int i = size; i <= index; i++) {\n            list.add(i, null);\n          }\n          parentMap.put(name, list);\n        } else {\n          parentMap.put(name, new HashMap());\n        }\n        return true;\n      }\n      \n    });\n    pathContext.createPath(\"a/b[1]/c\");\n\n***************\n\nI have continued looking into this, and found that the problem is that, if\nthe List is created with a 'null' element, JXPath gets stuck in infinite\nrecursion.\n\nTo discover this, I changed my Factory to implement the following method:\n\n      public boolean createObject(\n          JXPathContext context, Pointer pointer, Object parent, \n          String name, int index) {\n\n        if (pointer instanceof NodePointer) {\n          index = ((NodePointer)pointer).getIndex();\n        }\n        System.out.println(parent + \":\" + name + \":\" + index);\n        Map parentMap = (Map)parent;\n        if (index > -1) {\n          List list = (List)parentMap.get(name);\n          if (list == null) {\n            list = new ArrayList();\n          }\n          int size = list.size();\n          for (int i = size; i <= index; i++) {\n            list.add(i, new HashMap());  // !!!!!!  Don't set to 'null'\n          }\n          parentMap.put(name, list);\n        } else {\n          parentMap.put(name, new HashMap());\n        }\n        return true;\n      }\n\nThen I ran the following code:\n\n    pathContext.createPath(\"a/b[1]/c\");\n    pathContext.createPath(\"a/b[2]/c\");  // STACK OVERFLOW HERE\n\nHere is the stack trace at the beginning, where\n'ValueUtils.expandCollection()' is called.  It puts 'null' into the list,\nthus causing the stack overflow as we cycle between createPath() &\ncreateChild().\n\nThread [main] (Suspended (breakpoint at line 227 in DynamicPropertyPointer))\n\tDynamicPropertyPointer.createPath(JXPathContext) line: 227\n\tDynamicPropertyPointer(PropertyPointer).createChild(JXPathContext,\nQName, int) line: 188\n\tNullElementPointer.createPath(JXPathContext) line: 82\n\tNullPointer.createPath(JXPathContext) line: 86\n\tNullPropertyPointer.createPath(JXPathContext) line: 103\n\tNullPointer.createPath(JXPathContext) line: 86\n\tNullPropertyPointer.createPath(JXPathContext) line: 103\n\tJXPathContextReferenceImpl.createPath(String, Expression) line: 447\n\tJXPathContextReferenceImpl.createPath(String) line: 427\n\tTest.test4() line: 75\n\tTest.main(String[]) line: 38",
                "resolved": "2007-01-10",
                "versions": [
                    "1.2 Final",
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-54",
                "project": "Commons JXPath",
                "title": "[JXPATH] Pointer invalid after iterating over Pointers referencing atomic values",
                "type": "Bug",
                "description": "We encountered a problem with Pointers when iterating over an array or a \ncollection that holds atomic values such as Boolean. \n\nActions:\n- Create a bean exposing an array of Boolean objects\n  getBoolArray()\n- Obtain a Pointer iterator by calling:\n  context.iteratePointers(\"somepath/boolArray\");\n- Iterate over all Pointers and store them in a new Collection\n- Iterate over the new Collection\n- For each Pointer, try to update the Boolean value.\n--> The result is that only the last Boolean value of the original \n    array is updated.\n    Apparently the Pointers do not keep the index of the referenced\n    element withing the array. \n    The problem does also exist for Collections.\n    \n    We are using java5.\n\n    We consider this to be an error since nowhere is stated that updating\n    Pointer values is not possible after iterating over a list pointers.\n\n    The only work around is to wrap the values (see Example)\n\nKind regards\nAndreas\n\nExample Code:\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.JXPathContext;\nimport org.apache.commons.jxpath.Pointer;\n\npublic class JXPathTest {\n\n  /**\n   * @param args\n   */\n  @SuppressWarnings({\"unchecked\",\"unchecked\"})\n  public static void main(String[] args) {\n    \n    ArrayList arrayPointers = new ArrayList();\n    ArrayList listPointers  = new ArrayList();\n    ArrayList listWrappedPointers  = new ArrayList();\n    \n    \n    AModel model = new AModel();\n    System.out.println(\"start with:\");\n    model.printIt();\n    // get pointers\n    JXPathContext context = JXPathContext.newContext(model);    \n    // get the array pointers\n    Iterator resultPointerIterator = context.iteratePointers\n(\"/booleans/arrBool\");\n    while (resultPointerIterator.hasNext()){\n      Pointer ptr = (Pointer)resultPointerIterator.next();\n      arrayPointers.add(ptr);\n      \n    }        \n    // get list pointers\n    resultPointerIterator = context.iteratePointers(\"/booleans/listBool\");\n    while (resultPointerIterator.hasNext()){\n      Pointer ptr = (Pointer)resultPointerIterator.next();      \n      listPointers.add(ptr);\n    }\n    // get wrapped boolean pointers\n    resultPointerIterator = context.iteratePointers\n(\"/booleans/listWrappedBool/booleanValue\");\n    while (resultPointerIterator.hasNext()){\n      Pointer ptr = (Pointer)resultPointerIterator.next();      \n      listWrappedPointers.add(ptr);\n    }\n    \n    \n    // modify pointers: We just invert every values\n    // modify array content via iterated pointer (case Boolean[])\n    Iterator it = arrayPointers.iterator();\n    while (it.hasNext()){\n      Pointer ptr = (Pointer)it.next();\n      ptr.setValue(Boolean.TRUE.equals(ptr.getValue())?\nBoolean.FALSE:Boolean.TRUE);\n    }\n    \n    // modify collection content via iterated pointer (case Boolean List)\n    it = listPointers.iterator();\n    while (it.hasNext()){\n      Pointer ptr = (Pointer)it.next();\n      ptr.setValue(Boolean.TRUE.equals(ptr.getValue())?\nBoolean.FALSE:Boolean.TRUE);\n    }\n    \n    // modify wrapped boolean collection content via iterated pointer (case \nWrapped Boolean List)\n    it = listWrappedPointers.iterator();\n    while (it.hasNext()){\n      Pointer ptr = (Pointer)it.next();\n      ptr.setValue(Boolean.TRUE.equals(ptr.getValue())?\nBoolean.FALSE:Boolean.TRUE);\n    }\n    \n    System.out.println(\"after invert --> not ok, only the boolean values of \nthe wrapped boolean list are inverted\");\n    System.out.println(\"                 In the Boolean Array and the \nArrayList only the last value is inverted.\");\n    \n    model.printIt();\n    \n  }\n\n  \n  public static class AModel{\n    SomeBooleans booleans = new SomeBooleans();\n    \n    public SomeBooleans getBooleans(){\n      return booleans;\n    }\n    \n    public void printIt(){\n      booleans.printArrBool();\n      booleans.printListBool();\n      booleans.printListWrappedBool();\n    }\n  }\n  \n  public static class SomeBooleans{\n    private Boolean[] arrBool = new Boolean[]{\n        Boolean.TRUE,\n        Boolean.FALSE,\n        Boolean.TRUE,\n        Boolean.FALSE,\n    };\n    \n    ArrayList listBool = new ArrayList();\n    \n    ArrayList listWrappedBool = new ArrayList();\n    \n    public SomeBooleans(){\n      // populate list with boolean Object references\n      listBool.add(Boolean.TRUE);\n      listBool.add(Boolean.FALSE);\n      listBool.add(Boolean.TRUE);\n      listBool.add(Boolean.FALSE);\n      \n      // populate list with boolean wrapper objects\n      listWrappedBool.add(new BooleanWrapper(Boolean.TRUE));\n      listWrappedBool.add(new BooleanWrapper(Boolean.FALSE));\n      listWrappedBool.add(new BooleanWrapper(Boolean.TRUE));\n      listWrappedBool.add(new BooleanWrapper(Boolean.FALSE));\n    }\n\n    /**\n     * @return Returns the arrBool.\n     */\n    public Boolean[] getArrBool() {      \n      return arrBool;\n    }\n\n    /**\n     * @param arrBool The arrBool to set.\n     */\n    public void setArrBool(Boolean[] arrBool) {\n      this.arrBool = arrBool;\n    }\n\n    /**\n     * @return Returns the listBool.\n     */\n    public ArrayList getListBool() {\n      return listBool;\n    }\n\n    /**\n     * @param listBool The listBool to set.\n     */\n    public void setListBool(ArrayList listBool) {\n      this.listBool = listBool;\n    }\n        \n    /**\n     * @return Returns the listWrappedBool.\n     */\n    public ArrayList getListWrappedBool() {\n      return listWrappedBool;\n    }\n\n    /**\n     * @param listWrappedBool The listWrappedBool to set.\n     */\n    public void setListWrappedBool(ArrayList listWrappedBool) {\n      this.listWrappedBool = listWrappedBool;\n    }\n\n    public void printArrBool(){\n      System.out.print(\"printArrBool:          [\");\n      for (int i= 0; i< arrBool.length; ++i){        \n        System.out.print(i>0?\", \"+arrBool[i]:arrBool[i]);\n      }\n      System.out.println(\"]\");\n    }\n    \n    public void printListBool(){\n      System.out.println(\"printListBool:         \" + listBool);\n    }   \n    \n    public void printListWrappedBool(){\n      System.out.print(\"printListWrappedBool:  [\");\n      for (int i= 0; i< listWrappedBool.size(); ++i){        \n        System.out.print(i>0?\", \"+listWrappedBool.get(i):listWrappedBool.get\n(i));\n      }\n      System.out.println(\"]\");\n    }\n  }\n  \n  public static class BooleanWrapper{\n    Boolean booleanValue;\n\n    public BooleanWrapper(Boolean booleanValue){\n      this.booleanValue = booleanValue;\n    }\n    \n    /**\n     * @return Returns the booleanValue.\n     */\n    public Boolean getBooleanValue() {\n      return booleanValue;\n    }\n\n    /**\n     * @param booleanValue The booleanValue to set.\n     */\n    public void setBooleanValue(Boolean booleanValue) {\n      this.booleanValue = booleanValue;\n    }\n    \n    public String toString(){\n      return booleanValue.toString();\n    }\n  }\n}",
                "resolved": "2006-05-16",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-53",
                "project": "Commons JXPath",
                "title": "ConvertUtils instead of TypeUtils",
                "type": "Bug",
                "description": "ConvertUtils from commons BeanUtils package should be used instead of TypeUtils \nfor type conversions because it is more 'pluggable' (you can add/register any \nconverter you want).\n\nUntil it's changed, I'm using something like this (I'm not sure this is a good \nsolution):\n\nTypeUtils.setTypeConverter(new TypeConverter() {\n  public boolean canConvert(Object object, Class toType) {\n    return ConvertUtils.lookup(toType) != null;\n  }\n  public Object convert(Object object, Class toType) {\n    return ConvertUtils.convert(object.toString(), toType);\n  }\n});",
                "resolved": "2006-05-16",
                "versions": [
                    "1.1 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-52",
                "project": "Commons JXPath",
                "title": "not() function not working correctly",
                "type": "Bug",
                "description": "the not() function is not working correctly with Boolean types, maybe it is not \nintended to do so (and Boolean manipulations should be handled with some \nexternal function library) but this could cause confusion so I prefered to \nreport it.\n\ncontext.getVariables().declareVariable(\"TRUE\", Boolean.TRUE);\ncontext.getVariables().declareVariable(\"FALSE\", Boolean.FALSE);\n        \nSystem.out.println(context.getValue(\"$TRUE\"));       // true\nSystem.out.println(context.getValue(\"$FALSE\"));      // false\nSystem.out.println(context.getValue(\"not($TRUE)\"));  // false\nSystem.out.println(context.getValue(\"not($FALSE)\")); // false!!!",
                "resolved": "2006-05-16",
                "versions": [
                    "1.1 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-51",
                "project": "Commons JXPath",
                "title": "second call to hasNext() on DOM Iterator causes NPE",
                "type": "Bug",
                "description": "A second call to an empty DOM Iterator causes a NullPointerException in\nDOMNodeIterator. The attached patch to DOMModelTest tests for and illustrates\nthe problem.",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-50",
                "project": "Commons JXPath",
                "title": "does not properly handle NodeSet returned by extension function",
                "type": "Bug",
                "description": "Per the documentation, my function is returning a BasicNodeSet containing zero\nor more pointers:\n\n  public static NodeSet observations(ExpressionContext context) {\n    // the cast below shouldn't break, as this is the only pointer type that\n    // makes sense in this context\n    List<NodePointer> ptrs = extractObservations(\n                                  (NodePointer)context.getContextNodePointer(), \n                                  new ArrayList<NodePointer>());\n    BasicNodeSet result = new BasicNodeSet();\n    for (NodePointer ptr : ptrs) {\n      result.add(ptr);\n    }\n    return result;\n  }\n\nHowever, if I call JXPathContext.selectNodes(\"ems:observations()\"), I'm getting\na single node containing the BasicNodeSet. I notice that there is a testcase for\nfunctions that return NodeSets, but that it uses expressions that actually\nreturn the children of the NodeSet (\"test:nodeSet()/name\").\n\nThere appear to be two problems. First, Expression.iterate() and\nExpression.iteratePointers() do not correctly recognize a NodeSet as something\niterable. I've resolved this by reaching into the NodeSet and getting an\niterator over its pointers.\n\nSecond, Expression.PointerIterator doesn't recognize when it already has a\npointer, and instead tries to wrap it in a new pointer. This ends up treating\nthe pointer as a bean.\n\nI've made these changes, and written a testcase that uses an unadorned NodeSet\nfunction. I also found a class that used a variable named \"enum\", and changed\nthis so that it would compile under 1.5.\n\nThe patch is attached. It's relative to \"commons-jxpath-1.2\" (root of extract\ndirectory).",
                "resolved": "2007-01-10",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-49",
                "project": "Commons JXPath",
                "title": "JXPathContextReferenceImpl not thread safe",
                "type": "Bug",
                "description": "The cache used to store compiled xpaths in JXPathContextReferenceImpl is not\nthread-safe. Here's the exception that showsup as a result in stress tests.\n\nException Stack Trace: java.util.ConcurrentModificationException \n        at java.util.HashMap$HashIterator.nextEntry(HashMap.java:762) \n        at java.util.HashMap$EntryIterator.next(HashMap.java:804) \n        at\norg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.cleanupCache(JXPathContextReferenceImpl.java:270)\n\n        at\norg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.compileExpression(JXPathContextReferenceImpl.java:252)\n\n        at\norg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.iteratePointers(JXPathContextReferenceImpl.java:493)",
                "resolved": "2006-05-16",
                "versions": [
                    "1.1 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-47",
                "project": "Commons JXPath",
                "title": "\"setValue\" method broken ?",
                "type": "Bug",
                "description": "Hi\n\nUsing filtering attributes with \"setValue\" method doesn't seem to work. For \nexample :\n\ncontext.getPointer(\"/employeeList[firstName='Dmitri']/firstName\").setValue\n(\"NewDmitri\");\n\nThe new value is cached into the pointer object, but the property writer method \nis not invoked, so the bean is not modified. It works well with non filtered \npath.\n\nMethod \"ValueUtils.setValue(Object bean, PropertyDescriptor propertyDescriptor, \nObject value)\" shoudn't be called instead of \"ValueUtils.setValue(Object \ncollection, int index, Object value)\" ?\n\nThanks.",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-46",
                "project": "Commons JXPath",
                "title": "NullPointerException",
                "type": "Bug",
                "description": "Using the following xpath, I get a NullPointerException, when trying to do a\ngetPointer():\n\n//item[@mutable='1'][last()]\n\nMy code and instance data are attached",
                "resolved": "2008-03-10",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-45",
                "project": "Commons JXPath",
                "title": "XPath 2.0",
                "type": "Bug",
                "description": "Should JXPath support XPath 2.0? Anyone have time to do this? XPath 2.0 is a\nhuge but perhaps worthwhile undertaking. However, it is a very different\nlanguage than XPath 1. They are not compatible. If JXPath does support XPath 2,\nthis should be on a different branch than XPath 1, and XPath 1 should not be\nabandoned. It is still quite useful for many tasks. \n\nI'm just opening this bug to collect discussions about this in one place.",
                "resolved": "2006-05-16",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-44",
                "project": "Commons JXPath",
                "title": "Lack of examples or documentation",
                "type": "Bug",
                "description": "Hey guys,\n\nWhile trying to write a prototype to use JXPath with XML / Dom trees i was looking for \ndocumentation or examples on this subjects. I did not seem to find anything nor on the jakarta nor \non the internet. Where can we get this information? btw i think you could attract a lot more \ndevelopers by making this project more accessable with examples and practical documentation on \nuseing JXpath with XML/DOM.\nBTW: this is more an issue than a bug but the apache site brought me \nhere for issues.",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-43",
                "project": "Commons JXPath",
                "title": "JXPathContext.createPath() does work for field of multiplicity > 1",
                "type": "Bug",
                "description": "When attempting to create a new indexed path (corresponding to a multiple \nfield), I get a JXPathException that is ultimately caused by an \nIndexOutOfBounds exception. \n\nFor example, if Names is an array/Collection of size 3, then context.createPath\n(\"foo[3]\") will throw a JXPathException (before getting to my implementation of \nAbstractFactory).\n\nI chased the bug down in the latest codebase to the \norg.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.createPath\n(JXPathContext context) method.\n\nThe first thing this method does is to attempt to check \n    (getNodeValue() != null)\nbut in the case that the path does not yet exist, and the exception is thrown.\n\nMy suggested fix: this method needs a bit more logic in the intial check, such \nas:\n\n    Object nv = (index < getLength()) ? getNodeValue() : null;\n    if (nv == null) {\n        // same as before\n        ....\n    }\n \nCan you let me know whether you condone this change? (abeveridge@12.com).\n\nFinally, here is the stack trace that I get:\n\norg.apache.commons.jxpath.JXPathException: Exception trying to create xpath \nnames[3]; Cannot access property: names; \njava.lang.reflect.InvocationTargetException\n    at org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath\n(JXPathContextReferenceImpl.java:309)\n    at org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath\n(JXPathContextReferenceImpl.java:287)\n    at com.oxygen.object.BusinessObject.setProperty(BusinessObject.j\nava:233)\n    at com.oxygen.object.BusinessObjectXpathTest.testMomAndDad(Busin\nessObjectXpathTest.java:214)\n    at java.lang.reflect.Method.invoke(Native Method)\n    at junit.framework.TestCase.runTest(TestCase.java:166)\n    at junit.framework.TestCase.runBare(TestCase.java:140)\n    at junit.framework.TestResult$1.protect(TestResult.java:106)\n    at junit.framework.TestResult.runProtected(TestResult.java:124)\n    at junit.framework.TestResult.run(TestResult.java:109)\n    at junit.framework.TestCase.run(TestCase.java:131)\n    at junit.framework.TestSuite.runTest(TestSuite.java:173)\n    at junit.framework.TestSuite.run(TestSuite.java:168)\n    at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run\n(JUnitTestRunner.java:231)\n    at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.main\n(JUnitTestRunner.java:409)\n\n    =====NESTED EXCEPTION=====\norg.apache.commons.jxpath.JXPathException: Cannot access property: names; \njava.lang.reflect.InvocationTargetException\n    at org.apache.commons.jxpath.util.ValueUtils.getValue(ValueUtils\n.java:346)\n    at org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getNodeValue\n(BeanPropertyPointer.java:190)\n    at org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.createPath\n(BeanPropertyPointer.java:223)\n    at org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.createChild\n(PropertyOwnerPointer.java:169)\n    at org.apache.commons.jxpath.ri.model.beans.NullElementPointer.createChild\n(NullElementPointer.java:164)\n    at org.apache.commons.jxpath.ri.model.beans.NullPointer.createPath\n(NullPointer.java:142)\n    at org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath\n(JXPathContextReferenceImpl.java:306)\n    at org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath\n(JXPathContextReferenceImpl.java:287)\n    at com.oxygen.object.BusinessObject.setProperty(BusinessObject.java:233)\n    at com.oxygen.object.BusinessObjectXpathTest.testMomAndDad\n(BusinessObjectXpathTest.java:214)\n    at java.lang.reflect.Method.invoke(Native Method)\n    at junit.framework.TestCase.runTest(TestCase.java:166)\n    at junit.framework.TestCase.runBare(TestCase.java:140)\n    at junit.framework.TestResult$1.protect(TestResult.java:106)\n    at junit.framework.TestResult.runProtected(TestResult.java:124)\n    at junit.framework.TestResult.run(TestResult.java:109)\n    at junit.framework.TestCase.run(TestCase.java:131)\n    at junit.framework.TestSuite.runTest(TestSuite.java:173)\n    at junit.framework.TestSuite.run(TestSuite.java:168)\n    at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run\n(JUnitTestRunner.java:231)\n    at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.main\n(JUnitTestRunner.java:409)\n\n    ====NESTED EXCEPTION=====\njava.lang.reflect.InvocationTargetException: \njava.lang.IndexOutOfBoundsException: Index: 2, Size: 2\n    at java.util.ArrayList.RangeCheck(ArrayList.java:486)\n    at java.util.ArrayList.get(ArrayList.java:302)\n    at com.oxygen.object.Dad.getNames(Dad.java:210)\n    at java.lang.reflect.Method.invoke(Native Method)\n    at org.apache.commons.jxpath.util.ValueUtils.getValue(ValueUtils.java:342)\n    at org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getNodeValue\n(BeanPropertyPointer.java:190)\n    at org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.createPath\n(BeanPropertyPointer.java:223)\n    at org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer.createChild\n(PropertyOwnerPointer.java:169)\n    at org.apache.commons.jxpath.ri.model.beans.NullElementPointer.createChild\n(NullElementPointer.java:164)\n    at org.apache.commons.jxpath.ri.model.beans.NullPointer.createPath\n(NullPointer.java:142)\n    at org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath\n(JXPathContextReferenceImpl.java:306)\n    at org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPath\n(JXPathContextReferenceImpl.java:287)\n    at com.oxygen.object.BusinessObject.setProperty(BusinessObject.java:233)\n    at com.oxygen.object.BusinessObjectXpathTest.testMomAndDad\n(BusinessObjectXpathTest.java:214)\n    at java.lang.reflect.Method.invoke(Native Method)\n    at junit.framework.TestCase.runTest(TestCase.java:166)\n    at junit.framework.TestCase.runBare(TestCase.java:140)\n    at junit.framework.TestResult$1.protect(TestResult.java:106)\n    at junit.framework.TestResult.runProtected(TestResult.java:124)\n    at junit.framework.TestResult.run(TestResult.java:109)\n    at junit.framework.TestCase.run(TestCase.java:131)\n    at junit.framework.TestSuite.runTest(TestSuite.java:173)\n    at junit.framework.TestSuite.run(TestSuite.java:168)\n    at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run\n(JUnitTestRunner.java:231)\n    at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.main\n(JUnitTestRunner.java:409)",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-42",
                "project": "Commons JXPath",
                "title": "[jxpath] Extension functions no longer work in certain cases",
                "type": "Bug",
                "description": "In trying to upgrade to jxpath 1.2, I discovered a regression (or, at least, an \nundocumneted change in behavior) with the previous version I was using.\n\nThe following unit test used to pass, but now fails with the message that the \nfunction 'myString' is not found.\n\npublic class TestJXPath extends TestCase {\n  public class MyClass {\n    public String myString() {\n      return \"hello\";\n    }\n  }\n  public void testExtensionFunction() {\n    MyClass obj = new MyClass();\n    JXPathContext context = JXPathContextFactory.newInstance().newContext(obj);\n    Object result = context.iterate(\"myString(.)\").next();\n    assertEquals(\"hello\", result);\n  }\n}",
                "resolved": "2006-05-16",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-41",
                "project": "Commons JXPath",
                "title": "Missing class org.apache.commons.jxpath.servlet.Util",
                "type": "Bug",
                "description": "This class org.apache.commons.jxpath.servlet.Util is missing from the lastest\nrelease.\n\nIn the javadocs we can see it:\nhttp://jakarta.apache.org/commons/jxpath/apidocs/org/apache/commons/jxpath/servlet/Util.html\n\nBut it is removed from the CVS (3 months ago):\n\nhttp://cvs.apache.org/viewcvs.cgi/jakarta-commons/jxpath/src/java/org/apache/commons/jxpath/servlet/Attic/\n\nIf the class will be removed, please provide a repleacement of the class.",
                "resolved": "2006-05-16",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-40",
                "project": "Commons JXPath",
                "title": "Problem in namespace handling",
                "type": "Bug",
                "description": "The Cocoon forms framework relies heavily in JXPath for binding forms data to\nbusiness objects and/or XML. One of the newest requirements is being able to use\nXML namespaces as well, so we tried to integrate the latest JXPath version but\nwent through a blocker because of what seems to be a problem in namespace\ninheritance. Attached is a test case which reproduces the issue, just drop to\nsrc/test/org/apache/commons/jxpath and run the test suite (sorry for the messy\nXML as an internal string, but it was the easiest way to send y'all some stuff\nto test right away).",
                "resolved": "2008-03-10",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-39",
                "project": "Commons JXPath",
                "title": "DynamicPropertyHandler and Collections bug",
                "type": "Bug",
                "description": "I possibly noticed a bug concerning dynamic property beans containing collections.\n\nConsider a bean, which's properties are handled thru a DynamicPropertyHandler.\n\nWhen a certain property is a (indexed) collection,\ncontext.iterate(\"/<property>\") should (so far as I understood) iterate over all\nelements of the collection.\nInstead the Iterator iterates only over the first element.\n\nThe same thing without dynamic properties works of course.\n\nYou reproduce this behaviour by using a Map to store the attributes.\n\nTX\nMarkus",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-38",
                "project": "Commons JXPath",
                "title": "ClassFunctions throws NPE searching for a function in null ns",
                "type": "Bug",
                "description": "First thing in getFunction(...):\n\n        if (!namespace.equals(this.namespace)) {\n            return null;\n        }\n\nIn contrast PackageFunctions has null checks.  I think I can work around this by\nalways using a namespace, but I can't think of any reason this behavior should\npersist into (theoretical) future versions of jxpath.",
                "resolved": "2007-01-10",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-37",
                "project": "Commons JXPath",
                "title": "JXPathException cause",
                "type": "Bug",
                "description": "Simple patch to JXPathException - guarantees better stacktraces under jdk 1.4, \nreduces developer's headaches (what is this InvocationTargetException???), does \nnot harm anyone else.",
                "resolved": "2008-03-10",
                "versions": [],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-36",
                "project": "Commons JXPath",
                "title": "Variable evaluation problem ?",
                "type": "Bug",
                "description": "We get a strange result with variable and/or pointer using.\n\nWork well :\n\tcontext.getVariables().declareVariable(\"v1\", \"Dmitri\");\n\tPointer pointer1 = context.getPointer(\"/employees\n[firstName=$v1]/lastName\");\n\tPointer pointer2 = context.getPointer(\"/employees[firstName=$v1]\");\n\nDoesn't seem to work :\n\tcontext.getVariables().declareVariable(\"v1\", \"Dmitri\");\n\tPointer pointer1 = context.getPointer(\"/employees[firstName=$v1]\");\n\tPointer pointer2 = context.getPointer(\"/employees[firstName=$v1]\");\n\nReference pointer1 is a \"BeanPointer\".\nReference pointer2 is a \"NullPointer\", so its \"getValue\" method return \nalways \"null\".\n\nWe can obtain only one pointer corresponding to a given expression. This \nproblem appears only with path containing variables.",
                "resolved": "2007-01-05",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": [
                    "1.0 Final"
                ]
            },
            {
                "issue_id": "JXPATH-35",
                "project": "Commons JXPath",
                "title": "JXPathIntrospector Method JXPathIntrospector.getBeanInfo doesn't find correct JXPathBeanInfo Objects",
                "type": "Bug",
                "description": "I have written a class MyDynamicPropertyHandler. \nI execute the following Code:\n\nJXPathBeanInfo info0;\nJXPathBeanInfo info1;\n\nJXPathIntrospector.registerDynamicClass(Component.class, \nMyDynamicPropertyHandler.class);\n\ninfo0=JXPathIntrospector.getBeanInfo(Component.class);\ninfo1=JXPathIntrospector.getBeanInfo(JComponent.class);\n\n\nsLogger.debug(\"isSame: \"+(info0==info1));\n\nThe output is:\n\nisSame false\n\n\nI think the Objects info0 and info1 should be the same \nbecause I Component is a parent of JComponent.",
                "resolved": "2006-05-16",
                "versions": [
                    "1.1 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-34",
                "project": "Commons JXPath",
                "title": "[jxpath] JXPathContext.getValue(xPath) trims the string",
                "type": "Bug",
                "description": "If an XML document contains a tag which has a blank at the beginning or at the\nend the method \"getValue(String xpath)\" trims the resulting string. I think this\nbehaviour is invalid.\n\nThe code can be found in the class\norg.apache.commons.jxpath.ri.model.dom.DOMNodePointer at the method\nstringValue(Node node)\n\nThis behaviour is the same in release 1.1 and 1.2",
                "resolved": "2006-05-16",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-33",
                "project": "Commons JXPath",
                "title": "[jxpath] NullPointerException",
                "type": "Bug",
                "description": null,
                "resolved": "2006-05-16",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-32",
                "project": "Commons JXPath",
                "title": "JXPath 1.1 code using custom functions failing when run in 1.2 onwards",
                "type": "Bug",
                "description": "We have recently attempted to upgrade from a 1.1 release of jxpath\nto 1.2 and found a great deal of our jxpath code fails to run correctly. \n\nWe isolated the problem to relating to the use of Custom Extension\nFunctions and have included sample junit test case snippets that should \ndemonstrate the issue clearly. \n\nThe background on what we are trying to do with jxpath is as follows\n(included so its clear on what we are trying to use jxpath to achieve):\n\nWithin our project, we make extensive use of Custom Extension Functions in JXPath.  \n\nWe also use JXPath variables significantly, in combination with these functions, \nthat often take a JXPath variable as an argument(s) to the function.\n\nWe now rely heavily on the use of the ExpressionContext interface as the first \nargument to many of our functions.  The reason for this is that we need a\nconvienient way to obtain access to \u0091original\u0092 object references within the\ncontext invoked by the function (as you would expect).\n\nHowever, we have also begun using a very useful combination of features, which\nthe API supports in version 1.1, where the first argument always defines the\nExpressionContext interface (which isn\u0092t really part of the method signature \u0096\nfrom a caller perspective), and a 2nd argument as \u0091Object\u0092 type. Within body of\nthe function, we then cast the object of the 2nd argument as a NodeSet (or\ndefine the NodeSet type within the method signature \u0096 either appears to work),\nwhich provides us with access to the pointers for the object. \n\nAs previously mentioned, a jxpath variable is passed from the caller of the\nfunction (received via the 2nd argument in the method signature), which is\nautomatically resolved, by jxpath, to the object itself.\n\nThe benefit of casting the object to NodeSet (interface) enables us to retrieve\nthe first pointer in the NodeSet list. The first pointer concerns us, as it\nrefers to the String value passed to the argument of the function which we need\naccess to.  The object reference itself is of little concern in this case, as\nonce we have access to the variable name sent to the function, we can access the\nobject via the ExpressionContext.\n\nThis all works fine in jxpath 1.1, however, in version 1.2 this functionality is\nnow broken, since our objects are no longer being cast to NodeSet (previously\nachieved via the internal implementation of jxpath NodeSet using a SimpleNodeSet\n\u0096 as per inspecting jxpath 1.1 source code).\n\nNote on the use of ExpressionContext: For those methods that declare the\nExpressionContext interface (which must be the first argument, if used), as part\nof the argument list, the method signature from the caller perspective, excludes\nit from the argument list, as it is implied by jxpath.  In other words, there\nwill be one less argument from the caller when the interface is used.  In the\ncase where this interface was the only argument, which is common, then the\ncaller would be invoking a zero-argument method.  This is behaviour we expect.\n\n\nHere is a simplified example of one of our functions using the techniques\ndiscussed:-\n\npublic static void deleteSomeObject(ExpressionContext expContext, Object obj) {\n\n // create a local jxpath context to retrieve values for jxpath variables\n JXPathContext localContext = expContext.getJXPathContext();\n\n // Nodeset of the object passed to method\n NodeSet nodeset = (NodeSet)obj;\n // Retrieve variable name passed to function\n String declaredVariable = nodeset.getPointers().get(0).toString();\n Object objectToDelete = null;\n// If this method was passed the $obj1 var to delete, then retrieve 'Object Type\n1' via $obj1 variable \n   if (declaredVariable.equals(\"$obj1\")) {\t\t\t\n\tobjectToDelete = (ObjectType1)localContext.getValue(\"$obj1\");\n\t}\n\n\t// If this method was passed the $obj2 var to delete, then retrieve 'Object\nType 2' via $obj2 variable \n\tif (declaredVariable.equals(\"$obj2\")) {\t\t\t\n\t\tobjectToDelete = (ObjectType2)localContext.getValue(\"$obj2\");\n\t\t}\n\n\tcollectionOfSomeObjects.delete(objectToDelete);\n }\n\nWhich would be used (called) in the following way:-\n\u0085\n// add to collection\nObjectType1 objectType1 = new ObjectType1();\nObjectType2 objectType2 = new ObjectType2();\nCollectionOfSomeObjects.add(objectType1);\nCollectionOfSomeObjects.add(objectType2);\n// add collection to jxpath context\nJXPathContext context = JXPathContext.newContext(collectionOfSomeObjects);\n// define jxpath variables\ncontext.getVariables().declareVariable(\"obj1\", objectType1);\ncontext.getVariables().declareVariable(\"obj2\", objectType2);\n\n// call jxpath Custom Extension Function\n\nString method2Invoke;\nmethod2Invoke = \u0093ftn:deleteSomeObject($obj1)\u0094\ncontext.getValue(method2Invoke);  // \u00df invoke function & return value (for\nnon-void methods)\nmethod2Invoke = \u0093ftn:deleteSomeObject($obj2)\u0094\ncontext.getValue(method2Invoke);  // \u00df invoke function & return value (for\nnon-void methods)\n\n\nIn addition to the above example, I have prepared a suite of JUnit tests (&\nfunctions) that work against JXPath version 1.1, \nbut fail against version 1.2.  These code snippets can simply be dropped into\nthe appropriate classes and executed.\n\nAlso, I would like to note that the JXPath user guide is a little unclear with\nrespect to the use of NodeSet\u0092s.  \nAfter looking at many of the existing JUnit tests for JXPath, many un-documented\nfeatures became evident & existing features became a little obscure, such as\n\u0091Collections as NodeSets\u0092.\n\nThe code examples provided should give you our perspective on it\u0092s use.\n\n\nCODE SNIPPETS BELOW TO INSERT INTO EXISTING JXPATH TEST SUITE:\nBelow you will find two sections:-\n(1) JUnit Tests to test Extension Functions\n(2) Additional Extension Functions for these new tests \n\n\n---------------------------------------------------------------------------------------------------------\n3 JUnit Tests to add to 'ExtensionFunctionTest.java\" (in package\norg.apache.commons.jxpath.ri.compiler) :\n\n\n    /**\n     * To test the use of NodeSet to retrieve String value passed to argument of\nmethod\n     */   \n    public void testMyTestNodeSetOnly() {\n    \t\n    \tcontext.getVariables().declareVariable(\"obj1\", new String(\"$12345.00\"));\n\n    \tassertXPathValue(\n                context,\n                \"test:myTestNodeSetOnly($obj1)\",\n                \"$obj1\");\n    \t\n    }\n\n    /**\n     * To test the use of ContextExpression & NodeSet Combined\n     */   \n    public void testMyTestContextExpressionAndNodeSetCombined() {\n    \tHashMap map = new HashMap();\n    \tmap.put(\"1\",new String(\"Item 1\"));\n    \tmap.put(\"2\",new String(\"Item 2\"));\n    \tmap.put(\"3\",new String(\"Item 3\"));\n    \t\n    \tcontext.getVariables().declareVariable(\"obj2\", map);\n\n    \tassertXPathValue(\n                context,\n                \"test:myTestContextExpressionAndNodeSetCombined($obj2)\",\n                \"$obj2\");\n    \t\n    }\n    \n    /**\n     * To test the use of ContextExpression & NodeSet Combined with additional\narguments\n     */   \n    public void testMyTestContextExpressionAndNodeSetCombinedExtraArgs() {\n    \tHashMap map = new HashMap();\n    \tmap.put(\"1\",new String(\"Item 1\"));\n    \tmap.put(\"2\",new String(\"Item 2\"));\n    \tmap.put(\"3\",new String(\"Item 3\"));\n    \tHashMap map2 = new HashMap();\n    \tmap2.put(\"another collection\",map);\n    \tmap2.put(\"a bean\",new TestBean());\n    \tTestBean testBean = new TestBean();\n    \tMap beanMap = testBean.getMap();\n\n    \tcontext.getVariables().declareVariable(\"obj1\", beanMap);\n    \tcontext.getVariables().declareVariable(\"obj2\", map2);\n    \tcontext.getVariables().declareVariable(\"obj3\", testBean);\n    \tcontext.getVariables().declareVariable(\"obj4\", new Integer(10));\n\n    \tassertXPathValue(\n                context,\n                \"test:myTestContextExpressionAndNodeSetCombinedExtraArgs($obj1,\n$obj2, $obj3, $obj4)\",\n                \"$obj1\");\n    \t\n    }\n    \n---------------------------------------------------------------------------------------------------------\n3 Additional Functions to add to 'TestFunctions.java' (in package\norg.apache.commons.jxpath.ri.compiler) :\n    \n    \n    public static String myTestNodeSetOnly(NodeSet obj) {\n\n    \t// Nodeset of the object passed to method\n\t\tNodeSet nodeset = (NodeSet)obj;\n\t\t\n\t\t// Retrieve variable name passed to function\n\t\tString declaredVariable = \"\";\n\t\tdeclaredVariable = nodeset.getPointers().get(0).toString();    \t\n\t\t\n//\t\tfor (int i=0; i < nodeset.getPointers().size();i++ ) {\n//\t\t\tdeclaredVariable = nodeset.getPointers().get(i).toString(); \t\n//\t        System.out.println(\"  declaredVariable Name = \"+declaredVariable+\"  \nvalue =\"+nodeset.getNodes().get(i));   \t\n//\n//\t\t}\n\n//        System.out.println(\"  declaredVariable Name = \"+declaredVariable);    \t\n    \t\n    \treturn declaredVariable;\n    }\n\n    public static String\nmyTestContextExpressionAndNodeSetCombined(ExpressionContext expContext, Object\nobj) {\n\n    \t// create a local jxpath context to retrieve values for jxpath variables\n\t\tJXPathContext localContext = expContext.getJXPathContext();\n\n\t\t// Nodeset of the object passed to method\n\t\tNodeSet nodeset = (NodeSet)obj;\n\t\t\n\t\t// Retrieve variable name passed to function\n\t\tString declaredVariable = nodeset.getPointers().get(0).toString();\n\t\t\n//        System.out.println(\"  declaredVariable Name = \"+declaredVariable);\n        HashMap object = (HashMap)localContext.getValue(declaredVariable);\n//        System.out.println(\"  declaredVariable reference to object via context\n= \"+object);\n    \t\n    \t\n    \treturn declaredVariable;\n    }\n\n    public static String\nmyTestContextExpressionAndNodeSetCombinedExtraArgs(ExpressionContext expContext,\nObject obj1, Object obj2, Object obj3, Object obj4 ) {\n\n    \t// create a local jxpath context to retrieve values for jxpath variables\n\t\tJXPathContext localContext = expContext.getJXPathContext();\n\n\t\t// Nodesets of the object(s) passed to method\n\t\tNodeSet nodeset1 = (NodeSet)obj1;\n\t\tNodeSet nodeset2 = (NodeSet)obj2;\n\t\tNodeSet nodeset3 = (NodeSet)obj3;\n\t\tNodeSet nodeset4 = (NodeSet)obj4;\n\t\t\n\t\t// Retrieve variable name passed to function\n\t\tString declaredVariable = nodeset1.getPointers().get(0).toString();\n\t\t\n//        System.out.println(\"  declaredVariable 1 Name = \"+declaredVariable);\n        HashMap object = (HashMap)localContext.getValue(declaredVariable);\n//        System.out.println(\"  declaredVariable reference to object via context\n= \"+object);\n    \t\n    \treturn declaredVariable;\n    }",
                "resolved": "2006-05-16",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-31",
                "project": "Commons JXPath",
                "title": "Problem with Pointer asPath method using dynamic beans",
                "type": "Bug",
                "description": "Hi,\n\nI noticed a strange behaviour of asPath, when I use dynamic beans (with\nDynamicPropertyHandler).\n\nConsidering a dynamic property \"properties\", which contains a Vector with 5\nObjects (Strings in my case), using iteratePointers (works now :-)) returns a\nstrange path using the asPath method on the returned pointers:\n\n[@name='properties'][1]\n[@name='properties'][2]\n[@name='properties'][3]\n[@name='properties'][4]\n[@name='properties'][5]\n\nThis path leads (of course) to an error, when I invoke the context.getValue\nmethod with it. I attached a testcase.\n\nAlso I noticed, that in some cases im my application the \"index\" begins with 2\ninstead of 1. But I could not reproduce this in a simple testcase. It looks like\nthis:\n\n[@name='properties'][2]\n[@name='properties'][3]\n[@name='properties'][4]\n[@name='properties'][5]\n\nPerhaps you'll face this behaviour too.\n\nThanx\nMarkus",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-30",
                "project": "Commons JXPath",
                "title": "Source instructions on web site are wrong",
                "type": "Bug",
                "description": "The web site at http://jakarta.apache.org/commons/jxpath/ refers to the CVS\nrepository at least twice and links to the CVS repository. Apparently JXPath has\nswitched to Subversion. The web site should be updated so it links to the\ncurrent SVN repository instead. This needs to be pushed out even in advance of\nan actual release.",
                "resolved": "2008-03-10",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-29",
                "project": "Commons JXPath",
                "title": "null pointer exception in org.apache.commons.jxpath.ri.model.dom.DOMNodePointer when setting a value",
                "type": "Bug",
                "description": "bug in org.apache.commons.jxpath.ri.model.dom.DOMNodePointer\n\nThe problem is when you try and set the value of a DOM node that has more\nthan 1 child text node. the clearing of the nodes is ctashing:\n\nline 366:\nint count = children.getLength();\nfor (int i = 0; i < count; i++){\n Node child = children.item(i);\n if (child.getNodeType() == Node.TEXT_NODE ||\n\t    child.getNodeType() == Node.CDATA_SECTION_NODE){\n\tnode.removeChild(child);\n }\n}\nwhen a node is deleted it is removed from the children list.\n\nfix:\nint count = children.getLength();\nint nPos=0; \nfor (int i = 0; i < count; i++){\n Node child = children.item(nPos);\n if (child.getNodeType() == Node.TEXT_NODE ||\n\t    child.getNodeType() == Node.CDATA_SECTION_NODE){\n\tnode.removeChild(child);\n } else {\n\t nPos++;//only increment position if we are not deleting it\n }\n}\n\n\nThis is in both stable and nightly builds",
                "resolved": "2006-05-16",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-28",
                "project": "Commons JXPath",
                "title": "setValue doesn't support non-void setters",
                "type": "Bug",
                "description": "imagine a class like this:\n\npublic class User {\n  private String userName;\n  public String getUserName() {\n    return this.userName;\n  }\n  public User setUserName(String inUserName) {\n    this.userName = inUserName;\n    return this;\n  }\n}\n\nJXPathContext.newContext(new User()).setValue(\"userName\", \"Mickey\");\n\nthrows\n\nException trying to create xpath /userName; Cannot modify property: \nUser.userName; No write method",
                "resolved": "2006-05-16",
                "versions": [
                    "1.1 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-27",
                "project": "Commons JXPath",
                "title": "Locale related TestCases fail",
                "type": "Bug",
                "description": "The TestCases below fail in jxpath 1.2 RC1. Note that the locale on the JXPathContext is correctly set to \nLocale.US, but the tests find the default locale (of my computer) de_DE! \n\nTestcase: testFormatNumberFunction(org.apache.commons.jxpath.ri.compiler.CoreFunctionTest):     \nFAILED\nEvaluating <format-number(123456789, '#.000000000')> expected:<123456789.000000000> but \nwas:<123456789>\njunit.framework.AssertionFailedError: Evaluating <format-number(123456789, '#.000000000')> \nexpected:<123456789.000000000> but was:<123456789>\n        at org.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:52)\n        at \norg.apache.commons.jxpath.ri.compiler.CoreFunctionTest.testFormatNumberFunction(CoreFunctionTes\nt.java:153)\n\nTestcase: testAttributeLang(org.apache.commons.jxpath.ri.model.beans.BeanModelTest):    FAILED\nEvaluating <@xml:lang> expected:<en-US> but was:<de-DE>\njunit.framework.AssertionFailedError: Evaluating <@xml:lang> expected:<en-US> but was:<de-DE>\n        at org.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:52)\n        at \norg.apache.commons.jxpath.ri.model.BeanModelTestCase.testAttributeLang(BeanModelTestCase.java:\n605)\n\nTestcase: testLang(org.apache.commons.jxpath.ri.model.dom.DOMModelTest):        Caused an ERROR\nNo value for xpath: //product/price:sale[lang('en')]/saleEnds\norg.apache.commons.jxpath.JXPathException: No value for xpath: //product/price:sale[lang('en')]/\nsaleEnds\n        at \norg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(JXPathContextReferenceImpl.java:\n344)\n        at \norg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(JXPathContextReferenceImpl.java:\n280)\n        at org.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:51)\n        at org.apache.commons.jxpath.ri.model.XMLModelTestCase.testLang(XMLModelTestCase.java:698)\n\nTestcase: testAttributeLang(org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanModelTest):    \nFAILED\nEvaluating <@xml:lang> expected:<en-US> but was:<de-DE>\njunit.framework.AssertionFailedError: Evaluating <@xml:lang> expected:<en-US> but was:<de-DE>\n        at org.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:52)\n        at \norg.apache.commons.jxpath.ri.model.BeanModelTestCase.testAttributeLang(BeanModelTestCase.java:\n604)\n\nTestcase: testLang(org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest):      Caused an ERROR\nNo value for xpath: //product/price:sale[lang('en')]/saleEnds\norg.apache.commons.jxpath.JXPathException: No value for xpath: //product/price:sale[lang('en')]/\nsaleEnds\n        at \norg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(JXPathContextReferenceImpl.java:\n344)\n        at \norg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(JXPathContextReferenceImpl.java:\n280)\n        at org.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:51)\n        at org.apache.commons.jxpath.ri.model.XMLModelTestCase.testLang(XMLModelTestCase.java:698)",
                "resolved": "2006-05-16",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-26",
                "project": "Commons JXPath",
                "title": "pointers obtained from iteratePointers() fails to setValue()",
                "type": "Bug",
                "description": "I'm trying to iterate pointers, and set values.  However any values I set using\nthis method are ignored.  This sounds similar to COM-72\n\nNote: It would be great if you like this test to add it to the suite.\n\nThanks!\n\nTo see the bug, add this function to NestedTestbean :\n\npublic void setName(String name) {\n        this.name = name;\n    }\n\nThen, add this function to JXPathTestCase:\n\n    public void testIteratePointerSetValue() {\n        JXPathContext context = JXPathContext.newContext(bean);\n        \n        testGetValue(context, \"/beans[1]/name\", \"Name 1\"); \n        testGetValue(context, \"/beans[2]/name\", \"Name 2\");\n        \n        // Test setting via context\n        context.setValue(\"/beans[2]/name\", \"Name 2 set\");\n        testGetValue(context, \"/beans[2]/name\", \"Name 2 set\");\n        \n        // Restore original value\n        context.setValue(\"/beans[2]/name\", \"Name 2\");\n        testGetValue(context, \"/beans[2]/name\", \"Name 2\");\n        \n        int iter_count = 0;\n        Iterator iter = context.iteratePointers(\"/beans/name\");\n        while (iter.hasNext()) {\n            iter_count++;\n            Pointer pointer = (Pointer) iter.next();\n            String s = (String) pointer.getValue();\n            s = s + \"suffix\";\n            pointer.setValue(s);\n            assertEquals(\"pointer.getValue\", s, pointer.getValue());\n            // fails right here, the value isn't getting set in the bean.\n            assertEquals(\"context.getValue\", s, context.getValue(pointer.asPath()));\n        }\n        assertEquals(\"Iteration count\", 2, iter_count);\n        \n        testGetValue(context, \"/beans[1]/name\", \"Name 1suffix\"); \n        testGetValue(context, \"/beans[2]/name\", \"Name 2suffix\");\n    }",
                "resolved": "2006-05-16",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-25",
                "project": "Commons JXPath",
                "title": "JXPathContext.iterate(String) returns duplicate children",
                "type": "Bug",
                "description": "i have a bean hierarchy as follows\n\nCollection Listing.getProperties()  // returns collection of Property objects\nCollection Property.getStructures()  // returns collection of Structure objects\nCollection Structure.getRooms()     // returns collection of Room objects\nCollection Room.getRooms()          // also returns collection of Room objects\n\nthe following code:\n\npublic void testCreate() throws Exception {\n    JXPathContext context = JXPathContext.newContext(this.listing);\n    for (Iterator i =\n(Iterator)context.iterate(\"properties/structures/levels//rooms[name='Bathroom']\");\ni.hasNext();) {\n\tRoom bathroom = (Room) i.next();\n\tSystem.out.println(bathroom.getName() +\" \"+      bathroom.getValue());\n    }\n}\n\n\nrun against the following pseudo structure:\n\nListing = (null)\n+-Property = (10116 St. Paul's Lane)\n+-+-Structure = (Townhouse)\n+-+-+-Level = (First Floor)\n+-+-+-+-Kitchen = (Kitchen)\n+-+-+-+-Room = (Living Room)\n+-+-+-+-Bathroom = (Powder Room)\n+-+-+-Level = (Second Floor)\n+-+-+-+-Bedroom = (Master Bedroom)\n+-+-+-+-+-Bathroom = (Master Bath)\n+-+-+-+-Bedroom = (Guest Bedroom)\n+-+-+-+-+-Bathroom = (Guest Bath)\n\n\ngenerates the following output:\n\nBathroom Powder Room\nBathroom Master Bath\nBathroom Guest Bath\nBathroom Master Bath\nBathroom Guest Bath\n\n\nthe last four should only have been two.  the direct xpath would be\n'properties/structures/levels/rooms[name='Bedroom']' \nand \n'properties/structures/levels/rooms/rooms[name='Bedroom']'.\n\nbut when i use the 'properties/structures/levels//rooms[name='Bedroom']' style\nquery, the rooms/rooms children get listed twice.",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-24",
                "project": "Commons JXPath",
                "title": "Exception using asPath()",
                "type": "Bug",
                "description": "I probably noticed a bug, when I use dynamic beans and iteratePointers() and\nthen the asPath() method on each pointer.\n\nAssuming the toplevel (dynamic) bean has 3 attributes att1, att1, att3 and att3\nis a nested bean whit attribute called 'nested'. \n\nThe following works:\n\ncontext.getValue(\"/att3/nested\");\n\nWhereas this throws an exception:\n\nIterator it = context.iteratePointers(\"/att3\");\nPointer ptr = it.next();\ncontext.getValue(ptr.asPath()+\"/nested\");\n\nI provided a testcase.",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-22",
                "project": "Commons JXPath",
                "title": "Parent axis of dynamic property beans",
                "type": "Bug",
                "description": "Dear Dmitri,\n\nI think, that I face another problem concerning dynamic property beans.\n\nConsider an object graph of dynamic property beans where the attribute of \nsome bean is a Collection of other dynamic property beans.\n\nWorks:\n\n/propertybean1[1]/propertybean2\n/propertybean1[2]/propertybean2\n/propertybean1[1]/propertybean2/../propertybean2\n\nLeads to an error (no value for xpath):\n\n/propertybean1[2]/propertybean2/../propertybean2\n\nYou can reproduce it, when you use a Map for the attributes.\n\nI'll try to add a example as source code.\n\nThanx,\nMarkus",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-21",
                "project": "Commons JXPath",
                "title": "Child not created when setting attribute",
                "type": "Bug",
                "description": "JXPath automatically creates attributes if the element already exists, but does\nnot call AbstractFactory.createObject() if the element does not exist.  This was\nnoticed when using xpath statements to create a DOM model.",
                "resolved": "2006-05-16",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-19",
                "project": "Commons JXPath",
                "title": "[jxpath] createPath does not work for an empty DOM",
                "type": "Bug",
                "description": "doc = new DocumentImpl();  \ncontext = JXPathContext.newContext(doc);  \ncontext.setFactory(new W3CFactory());  \ncontext.createPath(\"/root/bla\",\"created\");  \n  \nthrows an Exception: \nJXPathException: Exception trying to create xpath /root/bla; \njava.lang.NullPointerException \n \nThe W3CFactory is attached",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-18",
                "project": "Commons JXPath",
                "title": "createPathAndSetValue fails",
                "type": "Bug",
                "description": "jXPathContext.createPathAndSetValue(\"/element1/element2/1_numberelement\",\"val\"));\nfails with the following error:\n\norg.apache.commons.jxpath.JXPathException: Invalid XPath:\n'/element1/element2/1_numberelement'. Syntax error after: '/element1/element2/'\n\tat org.apache.commons.jxpath.ri.Parser.parseExpression(Parser.java:106)\n\tat\norg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.compileExpression(JXPathContextReferenceImpl.java:248)\n\tat\norg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(JXPathContextReferenceImpl.java:421)\n\nThis does not happen when I rename the path to \"/element1/element2/numberelement_1\".\n\nGtx,\nThomas",
                "resolved": "2006-05-16",
                "versions": [
                    "1.1 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-17",
                "project": "Commons JXPath",
                "title": "JXPathContext.iteratePointers(\"//*\") results are incorrect",
                "type": "Bug",
                "description": "Sometimes strange strings, such as \"bytes[1]\" and \"valid\", etc. appear in\nresulting Pointer.asPath() output instead of the actual data.\nPlease run the main of the attached class to see what I mean.\nThanks.",
                "resolved": "2007-01-05",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-16",
                "project": "Commons JXPath",
                "title": "JXPathException: Exception trying to create xpath",
                "type": "Bug",
                "description": "Although I provide a valid path to createPath() I get an exception. I provided a\ntestcase.",
                "resolved": "2006-05-16",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-15",
                "project": "Commons JXPath",
                "title": "JXPathContextFactory doesn't cache most common result of search",
                "type": "Bug",
                "description": "JXPathContextFactory's search for a factory class name caches all values\nreturned in the search *except* the default value.  This means that in the\ndefault case (which is the most common, obviously), the search is performed\nevery time, which is quite expensive.\n\nthis is the problem method:\nprivate static String findFactory(String property, String defaultFactory)\n\nnote that it does not cache the value of defaultFactory in the foundFactory\nclass variable when that is the value returned.\n\nsuggest adding \nfoundFactory = defaultFactory;\nreturn foundFactory;\n\nin place of\nreturn defaultFactory;\n\nat the end of this method.",
                "resolved": "2006-05-16",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-14",
                "project": "Commons JXPath",
                "title": "JXPathContext.getValue(String xpath) does not through JXPathException when it should",
                "type": "Bug",
                "description": "It seems that for certain XPaths, JXPathContext.getValue(String xpath) does not\nthrough a JXPathException when the expression does not match any nodes, even if\nlenient is set to false, and returns null instead.\n\nAn example: if the XPath is \n    /root/foo[@name='attrName']/*\n\nfor XML document\n    <root><foo name=\"attrName\"><value>blahblah</value></foo></root>\n\nThen JXPathContext.newContext( dom ).getValue() returns \"blahblah\".\n\nIf the node <foo name=\"attrName\">...</foo> does not exist, then getValue()\nreturns null, instead of throwin a JXPathException.\n\nHowever, if the expression is \n    /root/foo[@name='attrName']    ( lacking the ending /* )\nthen getValue() *does* throw a JXPathException if the node does not exist; and\nthe correct value if the node does exist.\n\nThe fact that expression  \"/root/foo[@name='attrName']/*\" works when the node\nexists leads me to believe it is a valid xpath expression?\n\nTracing through the JXPath code a bit, in\nJXPathContextReferenceImpl.getValue(xpath, expr), line 287,\nexpr.computeValue(getEvalContext()) is returning null for the case above where\nthe node doesn't exist. Since null is not an instanceof EvalContext or\nNodePointer, it is just returned as-is.\n\nThe DOM parser being used is Apache Xerces.\n\nThanks,\nMatias",
                "resolved": "2006-05-16",
                "versions": [
                    "1.1 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-13",
                "project": "Commons JXPath",
                "title": "ValueUtils.setValue() method has ex.printStackTrace()",
                "type": "Bug",
                "description": "line 312 of org.apache.commons.jxpath.util.ValueUtils is \n   ex.printStackTrace();\nThis debug line should be removed since this exception is passed along in the \nException thrown in very next line.\n\nI know this is *incredibly* minor, but it does result in an unwanted stack \ntrace on the console.",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-12",
                "project": "Commons JXPath",
                "title": "Descendant or self axis does not work correctly at root node",
                "type": "Bug",
                "description": "Given the following XML document: <root id=\"1234\"/>\nand the XPath: //root/@id/text().\n\nJXPath returns null instead of \"1234\".\n\nJXPathContext context = JXPathContext.newContext(doc);\nassertEquals(value, context.selectSingleNode(\"//root/@id/text()\"));\n\nThe attached JUnit test highlights the problem. It seems that JXPath does not\nfind the root node if it is accessed with the axis descendant-or-self.",
                "resolved": "2007-01-10",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-11",
                "project": "Commons JXPath",
                "title": "Handling setValue for Collections and arrays",
                "type": "Bug",
                "description": "As requested, I'm logging the recent email on this topic:\n\nLooks like I'll need to add conversion from arbitrary arrays to collection\ntypes.  For consistency I will implement the opposite conversion as well.\n\nBTW, could you record this requirement as well as all other issues you\ndiscover in JXPath in Bugzilla?  I already have quite a sizable list of bug\nreports from various people and want track them.\n\nThanks,\n\n- Dmitri\n\n----- Original Message -----\nFrom: \"Ivelin Ivanov\" <ivelin@apache.org>\nTo: <cocoon-dev@xml.apache.org>\nCc: \"Dmitri Plotnikov\" <dmitri@apache.org>\nSent: Monday, May 06, 2002 9:46 PM\nSubject: Re: [Announcement] XMLForm 0.81 available in Scratchpad\n\n\n>\n> Michael,\n>\n> Good work.\n>\n> Do you have CVS access. If not, just submit the patches to the list, or\n> directly to me and will apply them.\n> If you don't use the CVS patch options, don't worry, just send me a zipped\n> bundle with the java files.\n>\n> see below... ( I hope Dmitri can provide some feedback as well )\n>\n> ----- Original Message -----\n> From: <mratliff@collegenet.com>\n> To: <cocoon-dev@xml.apache.org>\n> Sent: Monday, May 06, 2002 6:09 PM\n> Subject: Re: [Announcement] XMLForm 0.81 available in Scratchpad\n>\n>\n> >\n> > Ivelin,\n> >\n> > <disclaimer>\n> >       I'm new to java, so there are probably better ways to do this.\n> >       I'm not using CVS (yet!) so I can't supply a simple diff file.\n> > </disclaimer>\n> >\n> > SUMMARY:\n> > *******************************************************\n> > 1) Added accessor methods for a Collection (ArrayList) variable to the\n> data\n> > model.  Is there a better choice?\n> > 2) Filled in the stubs for handling <xf:selectMany> already in\n> > XMLFormTransformer.java.  This created the <xf:selectMany> tag, but it\nhad\n> only\n> > one <xf:value> child.\n> > 3) Changed StartTransformingElement function to detect an instance of\n> Collection\n> > in the value_ returned from form.getValue() and iterated through the\n> Collection\n> > to create the necessary multiple <xf:value> tags.\n>\n> Cool. That's what I was thinking to do as well.\n>\n> > 4) Added a template to xmlform2html .xsl to process the xf:selectMany\ntag\n> and\n> > generate either a checkbox set or multiple-select list (based on\n> <xf:selectMany\n> > @hint=\"checkbox\">).  Now I had the output I was looking for, but when I\n> tried to\n> > submit the form I kept getting errors from jxpath.\n>\n> Can you send me the stack traces.\n> BTW, the most recent version of JXPath should be able to correctly handle\n> setValue( Collection or String[] ).\n> Dmitri added this after we discussed its potential for request parameters\n> with multiple values.\n>\n> > 5) Changed the convert function in Types.java to recognize String arrays\n> coming\n> > from the request (it seems to convert only String scalars) and to\nconvert\n> them\n> > to ArrayList type.\n>\n> Interesting. There already was code in Form to handle request parameters\n> with multiple values.\n> Apparantly badly implemented:\n> Can you point me to the problem ?\n>\n>\n>   public void setValue(String path, Object[] values)\n>   {\n>     Pointer pointer = jxcontext_.locateValue( path );\n>     Object property = pointer.getValue();\n>     if ( property == null )\n>     {\n>       throw new RuntimeException( \"Property for \" + path + \" is nul.\nCannot\n> determine type.\" );\n>     }\n>     // if the property is a collection, set value as array\n>     if ( property instanceof Collection || property.getClass ().isArray\n() )\n>     {\n>       Object newValue = convertType( values, property.getClass () );\n>       pointer.setValue( newValue );\n>     }\n>     // otherwise set the value of the first element\n>     // (there shouldn't be other)\n>     // in the values array\n>     else setValue( pointer, values[0] );\n>   }\n>\n>\n>\n> > 6) Extended WizardAction (for other reasons), and modified the reset\n> function to\n> > set data model to empty ArrayList before population.\n> >\n> > There are (at least) several fishy things here: 1) Don't know what\nhappens\n> when\n> > DOM nodes are used for multiple-select.  (Don't really understand the\n> > purpose/use of DOM nodes in data model for that matter)\n>\n> I guess preparing of the DOM node can either happen in the reset() method,\n> when request\n> scope is used for the form. Otherwise, with session scope, no special\n> handling needs to take place.\n> Although I have not tested this.\n> I have not personally used DOM for any of the web apps I've worked on, but\n> Torsten and other folks do it quite a bit. You can look at the recent form\n> discussions in the list.\n>\n> 2) Types stuff is just\n> > a working hack.  No provision for converting anything but an ArrayList,\n> and not\n> > sure if I'm even doing this the right way.\n>\n> I've also added a couple hacks to the Types class, some of which made it\nin\n> the JXPath core.\n> Yours might too, if we can't find a better solution.\n>\n> > 3) I very much prefer your idea of\n> > using \"selectUIType\" attribute instead of \"hint\" attribute.  I'll work\non\n> these\n> > things when I get time.\n>\n> This was an excerpt from the XForms spec.\n>\n> >\n> > Also, I'm struggling a bit with the best way to handle \"presentation\" of\n> > multiple-select lists rendered as checkbox set.  All other form widgets,\n> item\n> > captions render only one way (e.g. options in select list).  But with\n> checkbox\n> > sets, item captions may be rendered to right of checkbox, to left of\n> checkbox,\n> > above checkbox, below checkbox, etc.  For now, my template just places\n> them to\n> > right of checkbox, but this needs to be more flexible.\n>\n> Konstantin can probably help here.\n> As long as there is a way to extend and override the default rendering of\n> multi select checkboxes,\n> then your implementation should be cool. Is it an isolated template with a\n> name like (\"selectManyCheckbox\" or similar).\n>\n> >\n> > DETAILS:\n> > *******************************************************\n> >\n> > 1) In XMLFormTransformer.java\n> > Filled in stub for selectMany tag in  StartTransformingElement():\n> >       else if (TAG_SELECTMANY.equals(name))\n> >             {\n> >             //NYI - Not Yet Implemented\n> >                   //throw new SAXException(\"tag selectMany Not Yet\n> > Implemented\");\n> >              startElementSimpleField( uri, name, raw, attributes,\n> currentForm );\n> >             }\n>\n> Looks good.\n>\n> >\n> > and EndTransformingElement():\n> >       else if (TAG_SELECTMANY.equals(name))\n> >             {\n> >                   super.endElement(uri, name, raw);\n> >             }\n>\n> Looks good.\n>\n> >\n> > and inserted code for handling Collections:\n> >\n> >       // render the value subelement(s)\n> >       if (value_ instanceof Collection)\n> >       {\n> >             Iterator i=((Collection) value_).iterator();\n> >             while (i.hasNext())\n> >             {\n> >                   super.startElement(uri, \"value\", NS_PREFIX + \":\" +\n> \"value\",\n> > NOATTR);\n> >                     if (value_ != null)\n> >                     {\n> >                         String v = String.valueOf( i.next() );\n> >                         super.characters(v.toCharArray(),0,v.length());\n> >                     }\n> >                     super.endElement( uri, \"value\", NS_PREFIX + \":\" +\n> \"value\" );\n> >             }\n> >       }\n> >       else\n> >       {\n> >               super.startElement(uri, \"value\", NS_PREFIX + \":\" +\n\"value\",\n> > NOATTR);\n> >               if (value_ != null)\n> >               {\n> >                   String v = String.valueOf( value_ );\n> >                   super.characters(v.toCharArray(),0,v.length());\n> >               }\n> >               super.endElement( uri, \"value\", NS_PREFIX + \":\" +\n\"value\" );\n> >         }\n>\n> Looks good.\n>\n>\n> >\n> > 2) In Types.java the convert function has a block of code for converting\n> request\n> > parameter Strings to various Object types, but no similar block for\n> request\n> > parameter String[].  Maybe they are supposed to \"drop through\" and be\n> processed\n> > below, don't entirely understand this.  Anyway this caused all sorts of\n> jxpath\n> > errors when I tried to use form.setValue(path, values), so I used \"brute\n> force\"\n> > and hacked in the following:\n> >             else if (object instanceof String[]){\n> >                   /* WARNING: THIS IS A REAL HACK!\n> >                    * Inserted to handle conversion of string array from\n> request\n> > into ArrayList.\n> >                    * Should write \"converters\" from String[] to other\n> types of\n> > Java objects\n> >                    * Not sure this belongs here at all, should look at\n> > hasConversionConstructor\n> >                    * stuff below, but this works for now...\n> >                    */\n> >                   if (toType == ArrayList.class){\n>\n> If you can extend this implementation to be able to handle Collections or\n> array of primitives,\n> it deserves to be part of the core JXPath code. I would encourage you to\n> look at the most recent\n> JXPath source, because from Dmitri's description, I believe this is\nalready\n> there.\n>\n>\n> >                         String[] tempString = (String[]) object;\n> >                         ArrayList newArrayList = new ArrayList();\n> >                         for (int n=0;n<tempString.length;n++){\n> >                               newArrayList.add(tempString[n]);\n> >                         }\n> >                         return newArrayList;\n> >                   }\n> >             }\n>\n>\n> Excelent.\n>\n> Keep the good stuff coming.\n>\n>\n> Ivelin\n>\n> >\n> > Cheers,\n> > --Michael\n> >\n> >\n> >\n> >\n> >\n> >                       \"Ivelin Ivanov\"\n> >                       <ivelin@apache.or        To:\n> <cocoon-dev@xml.apache.org>\n> >                       g>                       cc:\n> >                                                Subject:  Re:\n> [Announcement] XMLForm 0.81 available in\n> >                       05/06/02 06:33 AM         Scratchpad\n> >                       Please respond to\n> >                       cocoon-dev\n> >\n> >\n> >\n> >\n> >\n> >\n> > Sure feel free to patch.\n> >\n> > Actually, thanks for patching ;)\n> >\n> > I'd be curious to see the diff.\n> >\n> > Can you descripe in short what behaviour you added to implement\nselectMany\n> ?\n> >\n> > Ivelin\n> >\n> > ----- Original Message -----\n> > From: <mratliff@collegenet.com>\n> > To: <cocoon-dev@xml.apache.org>\n> > Sent: Saturday, May 04, 2002 11:43 PM\n> > Subject: Re: [Announcement] XMLForm 0.81 available in Scratchpad\n> >\n> >\n> > > Ivelin,\n> > >\n> > > I found the places in XMLFormTransformer.java that needed filling in\nand\n> > hacked\n> > > a patch into Types.java.  I now have xf:selectMany working well enough\n> for\n> > > testing purposes.  Let me know if you have any general advice about\n> > patching\n> > > these files...\n> > >\n> > > Thanks,\n> > > --Michael\n> > >\n> > >\n> > > ---------------------------------------------------------------------\n> > > To unsubscribe, e-mail: cocoon-dev-unsubscribe@xml.apache.org\n> > > For additional commands, email: cocoon-dev-help@xml.apache.org\n> > >\n> >\n> >\n> > ---------------------------------------------------------------------\n> > To unsubscribe, e-mail: cocoon-dev-unsubscribe@xml.apache.org\n> > For additional commands, email: cocoon-dev-help@xml.apache.org\n> >\n> >\n> >\n> >\n> >\n> >\n> > ---------------------------------------------------------------------\n> > To unsubscribe, e-mail: cocoon-dev-unsubscribe@xml.apache.org\n> > For additional commands, email: cocoon-dev-help@xml.apache.org\n> >\n>\n>",
                "resolved": "2006-05-16",
                "versions": [
                    "1.0 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-10",
                "project": "Commons JXPath",
                "title": "JXPath 1.1 code using custom functions failing when run in 1.2 onwards",
                "type": "Bug",
                "description": "We have recently attempted to upgrade from a 1.1 release of jxpath\nto 1.2 and found a great deal of our jxpath code fails to run correctly. \n\nWe isolated the problem to relating to the use of Custom Extension\nFunctions and have included sample junit test case snippets that should \ndemonstrate the issue clearly. \n\nThe background on what we are trying to do with jxpath is as follows\n(included so its clear on what we are trying to use jxpath to achieve):\n\nWithin our project, we make extensive use of Custom Extension Functions in JXPath.  \n\nWe also use JXPath variables significantly, in combination with these functions, \nthat often take a JXPath variable as an argument(s) to the function.\n\nWe now rely heavily on the use of the ExpressionContext interface as the first \nargument to many of our functions.  The reason for this is that we need a\nconvienient way to obtain access to 'original' object references within the\ncontext invoked by the function (as you would expect).\n\nHowever, we have also begun using a very useful combination of features, which\nthe API supports in version 1.1, where the first argument always defines the\nExpressionContext interface (which isn't really part of the method signature -\nfrom a caller perspective), and a 2nd argument as 'Object' type. Within body of\nthe function, we then cast the object of the 2nd argument as a NodeSet (or\ndefine the NodeSet type within the method signature - either appears to work),\nwhich provides us with access to the pointers for the object. \n\nAs previously mentioned, a jxpath variable is passed from the caller of the\nfunction (received via the 2nd argument in the method signature), which is\nautomatically resolved, by jxpath, to the object itself.\n\nThe benefit of casting the object to NodeSet (interface) enables us to retrieve\nthe first pointer in the NodeSet list. The first pointer concerns us, as it\nrefers to the String value passed to the argument of the function which we need\naccess to.  The object reference itself is of little concern in this case, as\nonce we have access to the variable name sent to the function, we can access the\nobject via the ExpressionContext.\n\nThis all works fine in jxpath 1.1, however, in version 1.2 this functionality is\nnow broken, since our objects are no longer being cast to NodeSet (previously\nachieved via the internal implementation of jxpath NodeSet using a SimpleNodeSet\n- as per inspecting jxpath 1.1 source code).\n\nNote on the use of ExpressionContext: For those methods that declare the\nExpressionContext interface (which must be the first argument, if used), as part\nof the argument list, the method signature from the caller perspective, excludes\nit from the argument list, as it is implied by jxpath.  In other words, there\nwill be one less argument from the caller when the interface is used.  In the\ncase where this interface was the only argument, which is common, then the\ncaller would be invoking a zero-argument method.  This is behaviour we expect.\n\n\nHere is a simplified example of one of our functions using the techniques\ndiscussed:-\n\npublic static void deleteSomeObject(ExpressionContext expContext, Object obj) {\n\n // create a local jxpath context to retrieve values for jxpath variables\n JXPathContext localContext = expContext.getJXPathContext();\n\n // Nodeset of the object passed to method\n NodeSet nodeset = (NodeSet)obj;\n // Retrieve variable name passed to function\n String declaredVariable = nodeset.getPointers().get(0).toString();\n Object objectToDelete = null;\n// If this method was passed the $obj1 var to delete, then retrieve 'Object Type\n1' via $obj1 variable \n   if (declaredVariable.equals(\"$obj1\")) {\t\t\t\n\tobjectToDelete = (ObjectType1)localContext.getValue(\"$obj1\");\n\t}\n\n\t// If this method was passed the $obj2 var to delete, then retrieve 'Object\nType 2' via $obj2 variable \n\tif (declaredVariable.equals(\"$obj2\")) {\t\t\t\n\t\tobjectToDelete = (ObjectType2)localContext.getValue(\"$obj2\");\n\t\t}\n\n\tcollectionOfSomeObjects.delete(objectToDelete);\n }\n\nWhich would be used (called) in the following way:-\n...\n// add to collection\nObjectType1 objectType1 = new ObjectType1();\nObjectType2 objectType2 = new ObjectType2();\nCollectionOfSomeObjects.add(objectType1);\nCollectionOfSomeObjects.add(objectType2);\n// add collection to jxpath context\nJXPathContext context = JXPathContext.newContext(collectionOfSomeObjects);\n// define jxpath variables\ncontext.getVariables().declareVariable(\"obj1\", objectType1);\ncontext.getVariables().declareVariable(\"obj2\", objectType2);\n\n// call jxpath Custom Extension Function\n\nString method2Invoke;\nmethod2Invoke = \"ftn:deleteSomeObject($obj1)\"\ncontext.getValue(method2Invoke);  // \u00df invoke function & return value (for\nnon-void methods)\nmethod2Invoke = \"ftn:deleteSomeObject($obj2)\"\ncontext.getValue(method2Invoke);  // \u00df invoke function & return value (for\nnon-void methods)\n\n\nIn addition to the above example, I have prepared a suite of JUnit tests (&\nfunctions) that work against JXPath version 1.1, \nbut fail against version 1.2.  These code snippets can simply be dropped into\nthe appropriate classes and executed.\n\nAlso, I would like to note that the JXPath user guide is a little unclear with\nrespect to the use of NodeSet's.  \nAfter looking at many of the existing JUnit tests for JXPath, many un-documented\nfeatures became evident & existing features became a little obscure, such as\n'Collections as NodeSets'.\n\nThe code examples provided should give you our perspective on it's use.\n\n\nCODE SNIPPETS BELOW TO INSERT INTO EXISTING JXPATH TEST SUITE:\nBelow you will find two sections:-\n(1) JUnit Tests to test Extension Functions\n(2) Additional Extension Functions for these new tests \n\n\n---------------------------------------------------------------------------------------------------------\n3 JUnit Tests to add to 'ExtensionFunctionTest.java\" (in package\norg.apache.commons.jxpath.ri.compiler) :\n\n\n    /**\n     * To test the use of NodeSet to retrieve String value passed to argument of\nmethod\n     */   \n    public void testMyTestNodeSetOnly() {\n    \t\n    \tcontext.getVariables().declareVariable(\"obj1\", new String(\"$12345.00\"));\n\n    \tassertXPathValue(\n                context,\n                \"test:myTestNodeSetOnly($obj1)\",\n                \"$obj1\");\n    \t\n    }\n\n    /**\n     * To test the use of ContextExpression & NodeSet Combined\n     */   \n    public void testMyTestContextExpressionAndNodeSetCombined() {\n    \tHashMap map = new HashMap();\n    \tmap.put(\"1\",new String(\"Item 1\"));\n    \tmap.put(\"2\",new String(\"Item 2\"));\n    \tmap.put(\"3\",new String(\"Item 3\"));\n    \t\n    \tcontext.getVariables().declareVariable(\"obj2\", map);\n\n    \tassertXPathValue(\n                context,\n                \"test:myTestContextExpressionAndNodeSetCombined($obj2)\",\n                \"$obj2\");\n    \t\n    }\n    \n    /**\n     * To test the use of ContextExpression & NodeSet Combined with additional\narguments\n     */   \n    public void testMyTestContextExpressionAndNodeSetCombinedExtraArgs() {\n    \tHashMap map = new HashMap();\n    \tmap.put(\"1\",new String(\"Item 1\"));\n    \tmap.put(\"2\",new String(\"Item 2\"));\n    \tmap.put(\"3\",new String(\"Item 3\"));\n    \tHashMap map2 = new HashMap();\n    \tmap2.put(\"another collection\",map);\n    \tmap2.put(\"a bean\",new TestBean());\n    \tTestBean testBean = new TestBean();\n    \tMap beanMap = testBean.getMap();\n\n    \tcontext.getVariables().declareVariable(\"obj1\", beanMap);\n    \tcontext.getVariables().declareVariable(\"obj2\", map2);\n    \tcontext.getVariables().declareVariable(\"obj3\", testBean);\n    \tcontext.getVariables().declareVariable(\"obj4\", new Integer(10));\n\n    \tassertXPathValue(\n                context,\n                \"test:myTestContextExpressionAndNodeSetCombinedExtraArgs($obj1,\n$obj2, $obj3, $obj4)\",\n                \"$obj1\");\n    \t\n    }\n    \n---------------------------------------------------------------------------------------------------------\n3 Additional Functions to add to 'TestFunctions.java' (in package\norg.apache.commons.jxpath.ri.compiler) :\n    \n    \n    public static String myTestNodeSetOnly(NodeSet obj) {\n\n    \t// Nodeset of the object passed to method\n\t\tNodeSet nodeset = (NodeSet)obj;\n\t\t\n\t\t// Retrieve variable name passed to function\n\t\tString declaredVariable = \"\";\n\t\tdeclaredVariable = nodeset.getPointers().get(0).toString();    \t\n\t\t\n//\t\tfor (int i=0; i < nodeset.getPointers().size();i++ ) {\n//\t\t\tdeclaredVariable = nodeset.getPointers().get(i).toString(); \t\n//\t        System.out.println(\"  declaredVariable Name = \"+declaredVariable+\"  \nvalue =\"+nodeset.getNodes().get(i));   \t\n//\n//\t\t}\n\n//        System.out.println(\"  declaredVariable Name = \"+declaredVariable);    \t\n    \t\n    \treturn declaredVariable;\n    }\n\n    public static String\nmyTestContextExpressionAndNodeSetCombined(ExpressionContext expContext, Object\nobj) {\n\n    \t// create a local jxpath context to retrieve values for jxpath variables\n\t\tJXPathContext localContext = expContext.getJXPathContext();\n\n\t\t// Nodeset of the object passed to method\n\t\tNodeSet nodeset = (NodeSet)obj;\n\t\t\n\t\t// Retrieve variable name passed to function\n\t\tString declaredVariable = nodeset.getPointers().get(0).toString();\n\t\t\n//        System.out.println(\"  declaredVariable Name = \"+declaredVariable);\n        HashMap object = (HashMap)localContext.getValue(declaredVariable);\n//        System.out.println(\"  declaredVariable reference to object via context\n= \"+object);\n    \t\n    \t\n    \treturn declaredVariable;\n    }\n\n    public static String\nmyTestContextExpressionAndNodeSetCombinedExtraArgs(ExpressionContext expContext,\nObject obj1, Object obj2, Object obj3, Object obj4 ) {\n\n    \t// create a local jxpath context to retrieve values for jxpath variables\n\t\tJXPathContext localContext = expContext.getJXPathContext();\n\n\t\t// Nodesets of the object(s) passed to method\n\t\tNodeSet nodeset1 = (NodeSet)obj1;\n\t\tNodeSet nodeset2 = (NodeSet)obj2;\n\t\tNodeSet nodeset3 = (NodeSet)obj3;\n\t\tNodeSet nodeset4 = (NodeSet)obj4;\n\t\t\n\t\t// Retrieve variable name passed to function\n\t\tString declaredVariable = nodeset1.getPointers().get(0).toString();\n\t\t\n//        System.out.println(\"  declaredVariable 1 Name = \"+declaredVariable);\n        HashMap object = (HashMap)localContext.getValue(declaredVariable);\n//        System.out.println(\"  declaredVariable reference to object via context\n= \"+object);\n    \t\n    \treturn declaredVariable;\n    }",
                "resolved": "2007-01-10",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-9",
                "project": "Commons JXPath",
                "title": "[jxpath] Property \"name\" of a bean-array can't be reached due to special handling with Maps",
                "type": "Bug",
                "description": "Pointing to the sample at\nhttp://jakarta.apache.org/commons/jxpath/users-guide.html#Map%20Element%20Access:\n<code>\npublic class Employee {\n    private Map addressMap = new HashMap();\n    {\n        addressMap.put(\"home\", new Address(...));\n        addressMap.put(\"office\", new Address(...));\n    }\n\n    public Map getAddresses(){\n       return addressMap;\n    }\n    ...\n }\n[...]\nString homeZipCode = (String)context.\n        getValue(\"addresses[@name='home']/zipCode\");\n</code>\n\ni realised that if \"addresses\" was an array of beans which contain the property\n\"name\", the getter isn't called properly if evaluating\n\"addresses[@name='home']/zipCode\".",
                "resolved": "2006-05-16",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-7",
                "project": "Commons JXPath",
                "title": "number() function doesn't work correctly on Boolean variable",
                "type": "Bug",
                "description": "When running the number() function on a Boolean variable, as in the following \ncode:\n        JXPathContext context = JXPathContextFactory.newInstance().newContext\n(null, null);\n        Variables vars = new BasicVariables();\n        vars.declareVariable(\"bool\", new Boolean(\"true\"));\n        context.setVariables(vars);\n        Number num = (Number)context.getValue(\"number($bool)\");\n        System.out.println(\"num = \" + num);\nThe value returned is NaN, instead of 1.0, as per the XPath spec.",
                "resolved": "2006-05-16",
                "versions": [
                    "1.1 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-6",
                "project": "Commons JXPath",
                "title": "org.apache.commons.jxpath.JXPathException: No value for xpath: /property1[@prop1='ONE']",
                "type": "Bug",
                "description": "Hi Dmitri,\n\nif I am right (I hope so :-)), there is a problem evaluating a simple xpath\nexpression, when you use a Vector as an attribute, which contains a dynamic\nbeans (for example HashMaps).\n\nSee testcase.\n\nThanx\nMarkus",
                "resolved": "2006-05-16",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-5",
                "project": "Commons JXPath",
                "title": "asPath() returns a path to the last sibling",
                "type": "Bug",
                "description": "The method call JXPathContext::iteratePointers() returns the correct number of \npointers. However, the pointers do not always return correct path on asPath() \nmethod call on them. A pointer returns a path that corresponds to the last \nNode in the sibling Nodes of the node that the pointer points to.\n\nHere is an example:\n\nClass A{\n       private List list;\n      //getter and setter\n      :\n}\n\nHere is a code snippet for creating an object graph that starts from\ninstance of A.\n\nA a1 = new A();\nList list1 = new LinkedList();\n\nA a11 = new A();\nlist1.add(a11);\n\nA a12 = new A();\nList list12 = new LinkedList();\nA a121 = new A();\nlist12.add(a121);\na12.setList(list12);\nlist1.add(a12);\n\nA a13 = new A();\nlist1.add(a11);\n\na1.setList(list1);\n\nAnd the list attribute can have instances of A as elements in it.\n\nThe JXPathContext correspong to a1 returns pointers when it's iteratePointers\n() method is called. And the pointers correspond to the following nodes.\n\nA[1]\nA[2]\nA[2]/A[1]\nA[3]\n\nThis is absolutely as expected. However, asPath() method on each of these \nPointers do not always return the correct path.\n\nCurrently, the asPath() method calls on the corresponding Pointers return this \noutput respectively.\n\nA[3]\nA[3]\nA[2]/A[1]\nA[3]\n\nThis needs to be fixed.",
                "resolved": "2008-03-10",
                "versions": [
                    "1.2 Final"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "JXPATH-3",
                "project": "Commons JXPath",
                "title": "JXPathContext.setTypeConverter()",
                "type": "Bug",
                "description": "could it be possible for a particular instance of JXPathContext to use a custom \nTypeConverter without touching TypeUtils (it would use TypeUtils if no \nTypeConverter is provided) ?",
                "resolved": "2006-05-16",
                "versions": [
                    "1.1 Final"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "JXPATH-2",
                "project": "Commons JXPath",
                "title": "Using JXPath in multiple threads",
                "type": "Bug",
                "description": "I was unable to determine if JXPath was intended to be used concurrently or not,\nbut after using it in a server application that runs 100+ threads concurrently,\nI started getting errors (they were rare) that showed the following trace:\n\njava.lang.NullPointerException\n\tat\norg.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer.getPropertyNames(BeanPropertyPointer.java:72)\n\tat\norg.apache.commons.jxpath.ri.model.beans.PropertyIterator.prepareForIndividualProperty(PropertyIterator.java:248)\n\tat\norg.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPositionIndividualProperty(PropertyIterator.java:141)\n\tat\norg.apache.commons.jxpath.ri.model.beans.PropertyIterator.setPosition(PropertyIterator.java:127)\n\tat\norg.apache.commons.jxpath.ri.axes.ChildContext.setPosition(ChildContext.java:106)\n\tat org.apache.commons.jxpath.ri.axes.ChildContext.nextNode(ChildContext.java:89)\n\tat org.apache.commons.jxpath.ri.EvalContext.nextSet(EvalContext.java:322)\n\tat org.apache.commons.jxpath.ri.axes.UnionContext.setPosition(UnionContext.java:55)\n\tat\norg.apache.commons.jxpath.ri.axes.NodeSetContext.nextNode(NodeSetContext.java:64)\n\tat org.apache.commons.jxpath.ri.EvalContext.constructIterator(EvalContext.java:181)\n\tat org.apache.commons.jxpath.ri.EvalContext.hasNext(EvalContext.java:114)\n\tat\ncom.paychex.hrs.ei.conversion.jaxb.InboundProcessor.process(InboundProcessor.java:136)\n\n\nThe code calling has next looks like:\n        Iterator oIter = m_oIdentifier.iteratePointers(oXCtx);\n>>>            while (oIter.hasNext())\n            {\n\nThe application has 100 worker threads, each processing the same\nmessage(converted to beans by JAXB), but different instances of it. This error\noccurs infrequently - happening only about once every 3 runs (each run processes\n1000 messages). I performed the test on a P4/Windows box, but I believe that\nthis is independent of os/system.\n\nI believe I have found some of the source code that may be causing this. It\nappears that bean info is stored in an internal cache (JXPathIntrospector) that\nall threads would end up using. For this to be thread safe, JXPathIntrospector\nneeds to be thread safe (which it is even though synchronization is not used),\nand JXPathBasicBeanInfo needs to be thread safe (it is not). Basically what is\nhappening is that inside of JXPathBasicBeanInfo, a couple of procedures build\nmember variables on demand. However this demand based building is not thread\nsafe and so a race condition exists between multiple threads that are both\nperforming the on demand building. Specifically getPropertyDescriptors and\ngetPropertyDescriptor modify propertyDescriptors and propertyNames in an unsafe\nmanner. Either synchronization should be used or the assignment to the member\nvariable should be performed last (resulting in duplicate effort but thread\nsafety).  Here are the pieces of code I am referring to:\n\n    public PropertyDescriptor[] getPropertyDescriptors() {\n        if (propertyDescriptors == null) {\n            try {\n                BeanInfo bi = null;\n                if (clazz.isInterface()) {\n                    bi = Introspector.getBeanInfo(clazz);\n                }\n                else {\n                    bi = Introspector.getBeanInfo(clazz, Object.class);\n                }\n                PropertyDescriptor[] pds = bi.getPropertyDescriptors();\n                propertyDescriptors = new PropertyDescriptor[pds.length];\n// At this point, the cache of property descriptors has been cleared possibly \n// conflicting with other threads\n                System.arraycopy(pds, 0, propertyDescriptors, 0, pds.length);\n                Arrays.sort(propertyDescriptors, new Comparator() {\n                    public int compare(Object left, Object right) {\n                        return ((PropertyDescriptor) left).getName().compareTo(\n                            ((PropertyDescriptor) right).getName());\n                    }\n                });\n            }\n...\n\n\n    public PropertyDescriptor getPropertyDescriptor(String propertyName) {\n        if (propertyNames == null) {\n            PropertyDescriptor[] pds = getPropertyDescriptors();\n            propertyNames = new String[pds.length];\n// At this point the property names has been cleared possibly conflicting with\n// other threads\n            for (int i = 0; i < pds.length; i++) {\n                propertyNames[i] = pds[i].getName();\n            }\n        }\n\n\n\n\nThanks,\nRob Sax",
                "resolved": "2008-03-10",
                "versions": [],
                "fixVersions": [
                    "1.3"
                ]
            }
        ]
    }
}