{
    "bugs info": {
        "bug counter": 160,
        "bugs": [
            {
                "issue_id": "CLI-335",
                "project": "Commons CLI",
                "title": "Defining Default Properties documentation has errors.",
                "type": "Bug",
                "description": "  https://commons.apache.org/proper/commons-cli/properties.html  specifically links to the deprecated OptionBuilder class.  It should reference the Option.Builder (note the dot) class.\r\n\r\nIn addition there are methods defined in Option.Builder that are not described in the properties document.",
                "resolved": "2024-06-12",
                "versions": [
                    "1.8.0"
                ],
                "fixVersions": [
                    "1.9.0"
                ]
            },
            {
                "issue_id": "CLI-331",
                "project": "Commons CLI",
                "title": "Deprecated option usage is not detected if non string keys are used for resolution.",
                "type": "Bug",
                "description": "CommandLine.handleDeprecated() is not called if the option key is not a string.\r\n\r\n\u00a0\r\n\r\nFor example getOptionValue() has both String and Option parameter types.\u00a0\r\n * getOptionValue(String) calls handleDeprecated()\r\n * getOptionValue(Option) does not call handleDeprecated().\r\n\r\nIn most cases the String parameter resolves the Option and calls the Option parameter method of the same name. \r\n\r\nThe fix is to move the handleDeprecated() into the Option processing path.",
                "resolved": "2024-05-11",
                "versions": [
                    "1.7.0"
                ],
                "fixVersions": [
                    "1.8.0"
                ]
            },
            {
                "issue_id": "CLI-327",
                "project": "Commons CLI",
                "title": "Date processing tests fail on some systems",
                "type": "Bug",
                "description": "On one of my systems the date conversions do not work as expected.\u00a0 I suspect this is some sort of entanglement between time zones and environment settings.\r\n\r\nI was able to fix the problem by creating the expected values from known values rather than hardcoding the expected date time strings.",
                "resolved": "2024-03-06",
                "versions": [
                    "1.7.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-326",
                "project": "Commons CLI",
                "title": "Make options.getKey() public",
                "type": "Bug",
                "description": "the Option method getKey() is package private.\u00a0 I believe that this is an oversight and should have been public.\u00a0\u00a0\r\n\r\nThe method is useful when describing options that have command line issues when the application is holding option references and not the option keys.",
                "resolved": "2024-03-06",
                "versions": [
                    "1.7.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-325",
                "project": "Commons CLI",
                "title": "When properties are retrieve for an Option that has both multiple arguments and a value separator only the first is retrieved.",
                "type": "Bug",
                "description": "When the following is executed it fails on the check for 2 values.\r\n\r\n\u00a0\r\n{color:#000000} {color}{color:#7f0055}final{color}{color:#000000} Option {color}{color:#6a3e3e}option{color}{color:#000000} = Option.{color}{color:#000000}builder{color}{color:#000000}({color}{color:#2a00ff}\"x\"{color}{color:#000000}){color}\r\n\r\n{color:#000000} .hasArgs(){color}\r\n\r\n{color:#000000} .valueSeparator(){color}\r\n\r\n{color:#000000} .desc({color}{color:#2a00ff}\"Multiple arg option with value separator.\"{color}{color:#000000}){color}\r\n\r\n{color:#000000} .build();{color}\r\n\r\n{color:#000000} {color}\r\n\r\n{color:#000000} String[] {color}{color:#6a3e3e}args{color}{color:#000000} = {{color}{color:#2a00ff}\"-x\"{color}{color:#000000}, {color}{color:#2a00ff}\"A=a\"{color}{color:#000000}, {color}{color:#2a00ff}\"B=b\"{color}{color:#000000}};{color}\r\n\r\n{color:#000000} CommandLine {color}{color:#6a3e3e}cmdLine{color}{color:#000000} = DefaultParser.{color}{color:#000000}builder{color}{color:#000000}().build().parse({color}{color:#7f0055}new{color}{color:#000000} Options().addOption({color}{color:#6a3e3e}option{color}{color:#000000}), {color}{color:#6a3e3e}args{color}{color:#000000});{color}\r\n\r\n{color:#000000} Properties {color}{color:#6a3e3e}props{color}{color:#000000} = {color}{color:#6a3e3e}cmdLine{color}{color:#000000}.getOptionProperties({color}{color:#6a3e3e}option{color}{color:#000000});{color}\r\n\r\n{color:#000000} {color}{color:#000000}assertEquals{color}{color:#000000}(2, {color}{color:#6a3e3e}props{color}{color:#000000}.size());{color}\r\n\r\n{color:#000000} {color}{color:#000000}assertEquals{color}{color:#000000}( {color}{color:#2a00ff}\"a\"{color}{color:#000000}, {color}{color:#6a3e3e}props{color}{color:#000000}.get({color}{color:#2a00ff}\"A\"{color}{color:#000000}));{color}\r\n\r\n{color:#000000} {color}{color:#000000}assertEquals{color}{color:#000000}( {color}{color:#2a00ff}\"b\"{color}{color:#000000}, {color}{color:#6a3e3e}props{color}{color:#000000}.get({color}{color:#2a00ff}\"B\"{color}{color:#000000}));{color}",
                "resolved": "2024-02-27",
                "versions": [
                    "1.6.0"
                ],
                "fixVersions": [
                    "1.7.0"
                ]
            },
            {
                "issue_id": "CLI-320",
                "project": "Commons CLI",
                "title": "Awkward behavior of Option.builder() for multiple optional args",
                "type": "Bug",
                "description": "This is to flag the breaking change for 1.6.0 as mentioned here:\r\n[https://github.com/apache/commons-cli/commit/34278395b6115752774c3d16a00292591da2dde3#comments]\r\n\r\nThe possible fixes seem to be:\r\n * add Javadoc for the {{numberOfArgs}} and {{optionalArg}} methods saying that the former must come after the latter.\r\n* make {{optionalArg}} fail (early) if the number of args is already set, so this change in behavior becomes explicit via the API rather than just a behavioral breakage later.\r\n * tweak the behavior of {{optionalArg}} to only adjust the arg count if not already set. This removes the implicit assumption of size 1 which I think better aligns with what you get when using the (deprecated) {{OptionBuilder#hasOptionalArgs(int)}}. I'll create a PR for this possible fix.",
                "resolved": "2024-02-19",
                "versions": [
                    "1.6.0"
                ],
                "fixVersions": [
                    "1.7.0"
                ]
            },
            {
                "issue_id": "CLI-318",
                "project": "Commons CLI",
                "title": "Inconsistent date format in changes report",
                "type": "Bug",
                "description": "Starting with 1.5.0 https://commons.apache.org/proper/commons-cli/changes-report.html uses a strange date format (10-23-2021) to report the release date.\r\n\r\nThis should be changed to the more comprehensible international date format used previously.",
                "resolved": "2023-06-30",
                "versions": [
                    "1.5.0"
                ],
                "fixVersions": [
                    "1.6.0"
                ]
            },
            {
                "issue_id": "CLI-317",
                "project": "Commons CLI",
                "title": "NullPointerException thrown by CommandLineParser.parse()",
                "type": "Bug",
                "description": "# First at all, your *testAmbiguousLongWithoutEqualSingleDash* does not lead to a AmbiguousOptionException\r\n\r\n # For this same test, if I replace the deprecated OptionBuilder with Option.Builder as follows\r\n{code:java}\r\noptions.addOption(Option.builder().option(\"f\").longOpt(\"foo\").optionalArg(true).build());\r\noptions.addOption(Option.builder().option(\"b\").longOpt(\"bar\").optionalArg(false).build());\r\n{code}\r\nthe test leads to a NPE\r\n{code:java}\r\njava.lang.NullPointerException\r\n\tat xx.DefaultParser.handleShortAndLongOption(DefaultParser.java:476)\r\n\tat xx.DefaultParser.handleToken(DefaultParser.java:535)\r\n\tat xx.DefaultParser.parse(DefaultParser.java:714)\r\n\tat xx.DefaultParser.parse(DefaultParser.java:677)\r\n\tat xx.DefaultParser.parse(DefaultParser.java:654)\r\n{code}\r\n\r\n_Note_\u00a0 : tested with Github code (January 22, 2023)",
                "resolved": "2023-08-19",
                "versions": [
                    "1.5.0"
                ],
                "fixVersions": [
                    "1.6.0"
                ]
            },
            {
                "issue_id": "CLI-314",
                "project": "Commons CLI",
                "title": "Release notes are missing",
                "type": "Bug",
                "description": "Link on the home page https://commons.apache.org/proper/commons-cli/ to the release notes is 404",
                "resolved": "2023-08-13",
                "versions": [],
                "fixVersions": [
                    "1.6.0"
                ]
            },
            {
                "issue_id": "CLI-313",
                "project": "Commons CLI",
                "title": "StringIndexOutOfBoundsException thrown by CommandLineParser.parse() on invalid input",
                "type": "Bug",
                "description": "I discovered a case which can trigger a\u00a0StringIndexOutOfBoundsException in {{{}CommandLineParser.parse(){}}}.\r\n\r\nThe following code-snippet reproduces it:\r\n{noformat}\r\n      CommandLineParser parser = new DefaultParser();\r\n      Options options = new Options();\r\n      parser.parse(options, new String[] {\"-=-\"}); {noformat}\r\n\u00a0\r\n\r\nWhen run against current commons-cli 1.5.0 as well as on latest git, it causes the following stacktrace:\r\n{noformat}\r\nException in thread \"main\" java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\r\n\u00a0 \u00a0 at java.base/java.lang.String.checkBoundsBeginEnd(String.java:3319)\r\n\u00a0 \u00a0 at java.base/java.lang.String.substring(String.java:1874)\r\n\u00a0 \u00a0 at org.apache.commons.cli.DefaultParser.isJavaProperty(DefaultParser.java:583)\r\n\u00a0 \u00a0 at org.apache.commons.cli.DefaultParser.handleShortAndLongOption(DefaultParser.java:511)\r\n\u00a0 \u00a0 at org.apache.commons.cli.DefaultParser.handleToken(DefaultParser.java:542)\r\n\u00a0 \u00a0 at org.apache.commons.cli.DefaultParser.parse(DefaultParser.java:712)\r\n\u00a0 \u00a0 at org.apache.commons.cli.DefaultParser.parse(DefaultParser.java:679)\r\n\u00a0 \u00a0 at org.apache.commons.cli.DefaultParser.parse(DefaultParser.java:660)\r\n\u00a0 \u00a0 at org.dstadler.cli.fuzz.Crash_4543e54e8e6239dec6cc2eea74b83d5de693ec71.main(Crash_4543e54e8e6239dec6cc2eea74b83d5de693ec71.java:13) {noformat}\r\n\u00a0\r\n\r\nAccording to the JavaDoc, all failures to parse the arguments should lead to a {{{}ParseException{}}}, but it seems this case is not handled currently.",
                "resolved": "2023-08-19",
                "versions": [
                    "1.5.0"
                ],
                "fixVersions": [
                    "1.6.0"
                ]
            },
            {
                "issue_id": "CLI-312",
                "project": "Commons CLI",
                "title": "Inconsistent behaviour in key/value pairs (Java property style)",
                "type": "Bug",
                "description": "In the Apache Maven project, we used to have an {{Option}} defined like this:\r\n\r\n{code:java}\r\nOption.builder(\"D\").longOpt(\"define\").hasArg().build()\r\n{code}\r\n\r\nThis allowed our users to define properties using all of these:\r\n* {{-Dx=1}}\r\n* {{-Dx}}\r\n* {{-D x}}\r\n* {{--define x=1}}\r\n* {{--define x}}\r\n\r\nSplitting the key/value pairs was something that we did inside Maven ([{{MavenCli.java #1733}}|https://github.com/apache/maven/blob/master/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java#L1733] and [{{MavenCli.java #1762}}|https://github.com/apache/maven/blob/master/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java#L1762]).\r\n\r\nIn the process of upgrading to Commons CLI 1.5 and moving away from the deprecated {{GnuParser}}, we found out that Commons CLI can split argument values thanks to the {{valueSeparator}}. We've changed our option declaration accordingly:\r\n\r\n{code:java}\r\nOption.builder(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build() );\r\n{code}\r\n\r\nUnfortunately, this breaks our accepted inputs: {{-Dv -Dw=1 -D x=2 -D y -D z=3}} breaks the parsing in Commons CLI:\r\n\r\n{code}\r\norg.apache.commons.cli.MissingArgumentException: Missing argument for option: D\r\n\r\n\tat org.apache.commons.cli.DefaultParser.checkRequiredArgs(DefaultParser.java:231)\r\n\tat org.apache.commons.cli.DefaultParser.handleOption(DefaultParser.java:394)\r\n\tat org.apache.commons.cli.DefaultParser.handleShortAndLongOption(DefaultParser.java:467)\r\n\tat org.apache.commons.cli.DefaultParser.handleToken(DefaultParser.java:542)\r\n\tat org.apache.commons.cli.DefaultParser.parse(DefaultParser.java:714)\r\n\tat org.apache.commons.cli.DefaultParser.parse(DefaultParser.java:681)\r\n\tat org.apache.commons.cli.DefaultParser.parse(DefaultParser.java:662)\r\n{code}\r\n\r\nFrom debugging, I've learned that it breaks at the *fifth* occurrence of {{-D}} (the one followed by {{z=3}}). It considers the *fourth* occurrence of {{-D}} incomplete (having only one value and not two). The strange thing is that the *first* occurrence of {{-D}} also has just one value ({{v}}) but parsing {{-Dw=1}} does not break over that.\r\n\r\nI can submit a pull request for a bug that demonstrates this, but I have no clue how to address it. Also, I don't know if this is actually supposed to work. Looking forward to your reaction.",
                "resolved": "2024-02-16",
                "versions": [
                    "1.5.0"
                ],
                "fixVersions": [
                    "1.7.0"
                ]
            },
            {
                "issue_id": "CLI-308",
                "project": "Commons CLI",
                "title": "Website has very out of date usage (site generation issue)",
                "type": "Bug",
                "description": "At time of writing the website at [https://commons.apache.org/proper/commons-cli/usage.html]\u00a0has very out of date usage examples, eg,\u00a0\r\n\r\n\u00a0\r\n{{Option logfile = OptionBuilder.withArgName( \"file\" )\r\n .hasArg()\r\n .withDescription( \"use given file for log\" )\r\n .create( \"logfile\" );}}\r\n\r\n\u00a0At first I thought this was just documentation neglect, but digging around a little, it seems like the doco in git is pretty up to date, and site generation was accidentally broken in December with a dependabot upgrade to the maven antrun plugin. An old version from svn gets picked up instead\r\n\r\nhttps://svn.apache.org/repos/infra/websites/production/commons/content/proper/commons-cli/usage.html\r\n\r\nI have a small patch as a possible fix.\r\n\r\n\r\n\r\n\u00a0",
                "resolved": "2021-10-19",
                "versions": [
                    "1.4"
                ],
                "fixVersions": [
                    "1.5.0"
                ]
            },
            {
                "issue_id": "CLI-303",
                "project": "Commons CLI",
                "title": "Doc: \"Usage Scenarios\" refers to deprecated methods",
                "type": "Bug",
                "description": "The [Usage Scenarios|http://commons.apache.org/proper/commons-cli/usage.html] describe how to add argument options like this:\r\n{code:java}\r\nOption logfile   = OptionBuilder.withArgName( \"file\" )\r\n                                .hasArg()\r\n                                .withDescription(  \"use given file for log\" )\r\n                                .create( \"logfile\" );\r\n{code}\r\nOptionBuilder has been deprecated. From what I can tell, the new way to do it is this:\r\n{code:java}\r\n  Option logfile = Option.builder(\"logfile\")\r\n      .argName(\"file\")\r\n      .hasArg()\r\n      .desc(\"use given file for log\")\r\n      .build();{code}",
                "resolved": "2023-08-19",
                "versions": [
                    "1.3.1"
                ],
                "fixVersions": [
                    "1.6.0"
                ]
            },
            {
                "issue_id": "CLI-292",
                "project": "Commons CLI",
                "title": "Girhub vs apache",
                "type": "Bug",
                "description": "From CONTRIBUTING.md it appears that development now happens on Github. However pom.xml still lists the Apache repos:\r\n\r\n  <scm>\r\n    <connection>scm:git:http://git-wip-us.apache.org/repos/asf/commons-cli.git</connection>\r\n    <developerConnection>scm:git:https://git-wip-us.apache.org/repos/asf/commons-cli.git</developerConnection>\r\n    <url>https://git-wip-us.apache.org/repos/asf?p=commons-cli.git</url>\r\n    <tag>HEAD</tag>\r\n  </scm>\r\n\r\nand this finds its way into the generated docs. I suspect the correct answer is to change pom.xml. However either way these should be consistent. ",
                "resolved": "2024-02-16",
                "versions": [
                    "1.5.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-283",
                "project": "Commons CLI",
                "title": "Missing Null pointer checks in CommandLine.java",
                "type": "Bug",
                "description": "- [CommandLine.java #L233 |https://github.com/apache/commons-cli/blob/b0024d482050a08efc36c3cabee37c0af0e57a10/src/main/java/org/apache/commons/cli/CommandLine.java#L233]\r\n Method call to `getValuesList()` returns the possible values of `Option` for which it is called as List or returns `null`. In case it returns `null`, `addAll()` method call on type `List` with `null` as an argument will lead to a NullPointerException. This can be prevented by explicitly checking and handling the cases when it might return null. I have made changes for the same\r\n\r\n - [CommandLine.java #L260 |https://github.com/apache/commons-cli/blob/b0024d482050a08efc36c3cabee37c0af0e57a10/src/main/java/org/apache/commons/cli/CommandLine.java#L260]\r\n As per the implementation of `stripLeadingHyphens(String)`, there exists cases when it might return `null`. And calling `equals` method on a null return value ([#L263 |https://github.com/apache/commons-cli/blob/b0024d482050a08efc36c3cabee37c0af0e57a10/src/main/java/org/apache/commons/cli/CommandLine.java#L263]) will lead to null pointer exception. So as to prevent this I have made changes to explicitly return null in case `stripLeadingHyphens` returns null\r\n\r\n - [CommandLine.java #L472 |https://github.com/apache/commons-cli/blob/b0024d482050a08efc36c3cabee37c0af0e57a10/src/main/java/org/apache/commons/cli/CommandLine.java#L472]\u00a0\r\n There is a possibility that `addOption` method is called with null as an argument. In that case we will be adding null values to our list of processed options (as `List` does not thrown any null pointer exception even if `add` method is called with null values). So as to prevent this we need to make sure that value that we are adding to list of processed option is not null.\r\n\r\nI have created a pull request for addressing these issues,\u00a0[see|https://github.com/apache/commons-cli/pull/24]",
                "resolved": "2023-08-14",
                "versions": [
                    "1.4"
                ],
                "fixVersions": [
                    "1.6.0"
                ]
            },
            {
                "issue_id": "CLI-282",
                "project": "Commons CLI",
                "title": "TypeHandler should throw ParseException for an unsupported class",
                "type": "Bug",
                "description": "JavaDoc for TypeHandler states that createValue will\r\n{noformat}\r\n* @throws ParseException if the value creation for the given object type failedtype{noformat}\r\n\u00a0However createValue(String str, Class<?> clazz) will return null if the clazz is unknown.",
                "resolved": "2018-02-26",
                "versions": [
                    "1.4"
                ],
                "fixVersions": [
                    "1.5.0"
                ]
            },
            {
                "issue_id": "CLI-274",
                "project": "Commons CLI",
                "title": "Option parser type EXISTING_FILE_VALUE not check file existing",
                "type": "Bug",
                "description": "When the user pass option type FileInputStream.class, I think the expected behavior for the return value is the same type, which the user passed.\n\nOptions options = new Options();\noptions.addOption(Option.builder(\"f\").hasArg().type(FileInputStream.class).build());\nCommandLine cline = new DefaultParser().parse(options, args);\nFileInputStream file = (FileInputStream) cline.getParsedOptionValue(\"f\"); // it returns \"File\" object, without check File exist.\n\n\nI attach a solution for it:\nhttps://github.com/schaumb/commons-cli/commit/abfcc8211f529ab75f3b3edd4a827e484109eb0b\n\n",
                "resolved": "2017-06-14",
                "versions": [],
                "fixVersions": [
                    "1.5.0"
                ]
            },
            {
                "issue_id": "CLI-266",
                "project": "Commons CLI",
                "title": "HelpFormatter#setOptionComparator(null) doesn't display the values in inserted order",
                "type": "Bug",
                "description": "{code:java}\nOptionGroup group = new OptionGroup();\nOption h = Option.builder(\"h\").build();\nOption s = Option.builder(\"s\").build();\nOption b = Option.builder(\"b\").build();\nOption t = Option.builder(\"t\").build();\ngroup.addOption(h)\n    .addOption(s)\n    .addOption(b)\n    .addOption(t);\nOptions options = new Options();\noptions.addOptionGroup(group);\noptions.addOption(Option.builder(\"o\").build());\nHelpFormatter formatter = new HelpFormatter();\nformatter.setOptionComparator(null);\nformatter.printHelp(\"cmd\", \"\", options, null);\n{code}\n\nThis code does print the options(1. Group, 2. Option \"o\") in the order of insertion but the groups order of display is messed up.\n\nThe OptionGroup internally uses a HashMap. If that could be replaced with a *LinkedHashMap* this issue can be solved.",
                "resolved": "2016-06-21",
                "versions": [
                    "1.3.1"
                ],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "CLI-265",
                "project": "Commons CLI",
                "title": "Optional argument picking up next regular option as its argument",
                "type": "Bug",
                "description": null,
                "resolved": "2020-09-02",
                "versions": [
                    "1.3.1"
                ],
                "fixVersions": [
                    "1.4"
                ]
            },
            {
                "issue_id": "CLI-254",
                "project": "Commons CLI",
                "title": "\"test\" gets parsed as test, quotes die :-(",
                "type": "Bug",
                "description": "{code}\ndef cli = new CliBuilder()\ncli.with {\n  f longOpt:'json-filter','jq expression', args: 1\n}\ndef vals = ['test', 't\"es\"t',\n            \"'test\", \"test'\", \"'test'\",\n            '\"test', 'test\"', '\"test\"']\nvals.each {\n  def opt = cli.parse(['-f', it])\n  assert opt.f == it\n}\n{code}\nIt fails on last entry: \"test\".",
                "resolved": "2024-03-07",
                "versions": [
                    "1.3"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-252",
                "project": "Commons CLI",
                "title": "LongOpt falsely detected as ambiguous",
                "type": "Bug",
                "description": "Options options = new Options();\noptions.addOption(Option.builder().longOpt(\"importToOpen\").hasArg().argName(\"FILE\").build());\noptions.addOption(Option.builder(\"i\").longOpt(\"import\").hasArg().argName(\"FILE\").build());\n\nParsing \"--import=FILE\" is not possible since 1.3 as it throws a AmbiguousOptionException stating that it cannot decide whether import is import or importToOpen. In 1.2 this is not an issue. \n\nThe root lies in the new DefaultParser which does a startsWith check internally. \n",
                "resolved": "2015-06-09",
                "versions": [
                    "1.3"
                ],
                "fixVersions": [
                    "1.3.1"
                ]
            },
            {
                "issue_id": "CLI-248",
                "project": "Commons CLI",
                "title": "dead links on doc page",
                "type": "Bug",
                "description": "http://commons.apache.org/proper/commons-cli/introduction.html\n\nLinks to Option, Options, Command Line et. al. are dead (e.g. http://commons.apache.org/proper/commons-cli/api-release/org/apache/commons/cli/Options.html ",
                "resolved": "2015-04-07",
                "versions": [],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-241",
                "project": "Commons CLI",
                "title": "OptionValidator Implementation Does Not Agree With JavaDoc",
                "type": "Bug",
                "description": "OptionValidator#validateOption\n\nIt states in its JavaDoc that:\n\nValidates whether opt is a permissible Option shortOpt.  The rules that specify if the opt is valid are:\n * it is not NULL\n * it is a single character that is either ' '(special case), '?', '@' or a letter\n * it is a multi characterthat only contains letters.\n\nThe first check in the code though is:\n\n        // check that opt is not NULL\n        if (opt == null)\n        {\n        \treturn;\n        }\n\n\nConsider changing to...\n\n        // check that opt is not NULL\n        if (opt == null)\n        {\n        \tthrow new IllegalArgumentException(\"The option cannot be NULL\");\n        }",
                "resolved": "2013-11-23",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-236",
                "project": "Commons CLI",
                "title": "CommandLine.getOptionValue() only returns first word of string",
                "type": "Bug",
                "description": "I have an option that takes an argument.  On the command line, I use:\n-someOption \"A string\"\n\ngetOptionValue() should return \"A String\",  but it returns \"A\".",
                "resolved": "2013-04-30",
                "versions": [
                    "1.2"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-235",
                "project": "Commons CLI",
                "title": "OptionBuilder wrong design",
                "type": "Bug",
                "description": "OptionBuilder uses static variables to do its work. That's why it is not thread safe.\n\nMore than that, static builder methods doesn't conform to Java good style of accessing static members. Such members belong to the class and must be accessed in static way.\n\nConsider creating new builder-like class like that:\n\n{code:java}\nOptionBuilder optionBuilder = OptionBuilder.newInstance();\noptions.add(optionBuilder.withDescription().hasArg().create());\noptions.add(optionBuilder.withDescription().hasArg().create());\noptions.add(optionBuilder.withDescription().hasArg().create());\n{code}\n\n",
                "resolved": "2013-03-16",
                "versions": [
                    "1.2"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-233",
                "project": "Commons CLI",
                "title": "HelpFormatter missing <arg> for first option",
                "type": "Bug",
                "description": "I'm not sure if this is fixed in the master branch, but it looks like the HelpFormatter doesn't correctly output a <arg> when the first option has an argument. Sample:\n\n\n{code:title=Main.java|borderStyle=solid}\n    Options options = new Options();\n    options.addOption(OptionBuilder.withLongOpt(\"user\").withDescription(\"Database username\").isRequired().hasArg().create(\"u\"));\n    options.addOption(OptionBuilder.withLongOpt(\"pass\").withDescription(\"Database password\").isRequired().hasArg().create(\"p\"));\n\n    CommandLineParser parser = new PosixParser();\n    CommandLine commandLine;\n    try {\n      commandLine = parser.parse(options, args);\n    } catch (ParseException e) {\n      HelpFormatter helpFormatter = new HelpFormatter();\n      helpFormatter.printHelp(120, \"Usage: Main <options>\", e.getMessage(), options, \"\");\n      System.exit(1);\n    }\n{code}\n\nThe output is:\n\n{noformat}\nusage: Usage: Main <options>\nMissing required option: u, p\n -p,--pass <arg>    Database password\n -u,--user          Database username\n{noformat}\n",
                "resolved": "2013-03-02",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-232",
                "project": "Commons CLI",
                "title": "Download link gives HTTP/1.1 403 Forbidden",
                "type": "Bug",
                "description": "Clicking on the \"Download\" link in the left hand menu under \"Commons CLI\" header directs to \nhttp://commons.apache.org/proper/commons-cli/download_cli.cgi\n\nAccessing the link yeilds a 403 Forbidden",
                "resolved": "2013-11-23",
                "versions": [
                    "1.2"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-230",
                "project": "Commons CLI",
                "title": "Unable to properly require options",
                "type": "Bug",
                "description": "Having some problems setting options as required. Have I misunderstood the documentation?\n\n * In test1() the option is required but also supplied, I expect to get no exceptions.\n * In test2() the option is required but *not* supplied, I expect to get an exception.\n\n{code:java}\npublic class Testing {\n\n    public static void main(String[] args) {\n        System.out.println(\"Begin test 1\");\n        test1();\n        System.out.println(\"End test 1\");\n        System.out.println(\"Begin test 2\");\n        test2();\n        System.out.println(\"End test 2\");\n    }\n\n    private static void test1() {\n\n        String[] args = new String[] { \"--foo\" };\n\n        Options options = new Options();\n        options.addOption(\"f\", \"foo\", false, \"\");\n        options.getRequiredOptions().add(options.getOption(\"foo\"));\n\n        GnuParser parser = new GnuParser();\n        try {\n            parser.parse(options, args);\n        } catch (ParseException e) {\n            // didn't expect to get MissingOptionException here\n            System.out.println(\"ERROR: \" + e.getMessage());\n        }\n    }\n\n    private static void test2() {\n\n        String[] args = new String[] { };\n\n        Options options = new Options();\n        options.addOption(\"f\", \"foo\", false, \"\");\n        options.getOption(\"f\").setRequired(true);\n\n        GnuParser parser = new GnuParser();\n        try {\n            parser.parse(options, args);\n        } catch (ParseException e) {\n            // expected to get MissingOptionException here\n            System.out.println(\"ERROR: \" + e.getMessage());\n        }\n    }\n}\n{code}",
                "resolved": "2013-02-11",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-229",
                "project": "Commons CLI",
                "title": "Missing place holder in required argument",
                "type": "Bug",
                "description": "The code below :\n{code}\n@SuppressWarnings(\"static-access\")\npublic class CliArgBug {\n\n\tprivate static final Options OPTIONS = new Options();\n\tstatic {\n\t\t// FIXME : bug ? usage prints --seq1 --seq2 <arg> - notice <arg>\n\t\t// missing in seq1 - corrected by adding .withArgName(\"file1\")\n\t\tOPTIONS.addOption(OptionBuilder\n\t\t\t\t.withLongOpt(\"seq1\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"REQUIRED : the file containing sequence 1\")\n\t\t\t\t.hasArg().isRequired().create());\n\t\tOPTIONS.addOption(OptionBuilder\n\t\t\t\t.withLongOpt(\"seq2\")\n\t\t\t\t.withDescription(\n\t\t\t\t\t\t\"REQUIRED : the file containing sequence 2\")\n\t\t\t\t.hasArg().isRequired().create());\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tHelpFormatter formatter = new HelpFormatter();\n\t\tformatter.printHelp(\"Notice <arg> is missing in seq1\", OPTIONS, true);\n\t}\n}\n{code}\n\nProduces :\n{code}\nusage: Notice <arg> is missing in seq1 --seq1 --seq2 <arg>\n    --seq1         REQUIRED : the file containing sequence \n    --seq2 <arg>   REQUIRED : the file containing sequence 2\n{code}\n\nAlso I was not able to find any info on where this placeholder <arg> is defined - please add this to the javadoc\n\nThanks",
                "resolved": "2013-01-27",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-225",
                "project": "Commons CLI",
                "title": "Special properties option (-Dproperty=value) handled improperly",
                "type": "Bug",
                "description": "In CLI 1.2 the special properties option (-Dproperty=value) is handled improperly. In GnuParser.java from line 80 is as follows:\n{code}\n                    if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n                    {\n                        // the format is --foo=value or -foo=value\n                        tokens.add(arg.substring(0, arg.indexOf('='))); // --foo\n                        tokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n                    }\n                    else if (options.hasOption(arg.substring(0, 2)))\n                    {\n                        // the format is a special properties option (-Dproperty=value)\n                        tokens.add(arg.substring(0, 2)); // -D\n                        tokens.add(arg.substring(2)); // property=value\n                    }\n{code}\n, but should be:\n{code}\n                    if (opt.indexOf('=') != -1)\n                \t{\n                \t    if (options.hasOption(opt.substring(0, opt.indexOf('='))))\n\t                    {\n\t                        // the format is --foo=value or -foo=value\n\t                        tokens.add(arg.substring(0, arg.indexOf('='))); // --foo\n\t                        tokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n\t                    }\n\t                    else if (options.hasOption(arg.substring(0, 2)))\n\t                    {\n\t                        // the format is a special properties option (-Dproperty=value)\n\t                        tokens.add(arg.substring(0, 2)); // -D\n\t                        tokens.add(arg.substring(2)); // property=value\n\t                    }\n                \t}\n{code}",
                "resolved": "2013-02-11",
                "versions": [
                    "1.2"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-224",
                "project": "Commons CLI",
                "title": "OptionBuilder only has static methods, yet many return an OptionBuilder instance",
                "type": "Bug",
                "description": "CLI-83 was closed as fixed in 2.0, but it seems that there is no current plan to release CLI 2.0.  Could this fix be rolled into the 1.x line?  I'm attaching a new version of option builder that addresses the issue (named DefaultOptionBuilder to maintain backwards compatability) and a unit test for it.",
                "resolved": "2013-02-11",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-220",
                "project": "Commons CLI",
                "title": "MissingOptionException.getMissingOptions() returns OptionGroup, not just String",
                "type": "Bug",
                "description": "The following code:\n\n{code:title=Test.java|borderStyle=solid}\nimport java.util.List;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.GnuParser;\nimport org.apache.commons.cli.MissingOptionException;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.OptionBuilder;\nimport org.apache.commons.cli.OptionGroup;\nimport org.apache.commons.cli.Options;\n\npublic class Test {\n\tpublic static void main(String[] argv)\n\t{\n\t\tOption opt_foo =\n\t\t\tOptionBuilder.hasArg(false)\n\t\t\t\t.isRequired(true)\n\t\t\t\t.withDescription(\"option foo\")\n\t\t        .create(\"foo\");\n\n\t\tOption opt_bar =\n\t\t\tOptionBuilder.hasArg(false)\n\t\t\t\t.isRequired(false)\n\t\t\t\t.withDescription(\"option bar\")\n\t\t        .create(\"bar\");\n\n\t\tOption opt_baz =\n\t\t\tOptionBuilder.hasArg(false)\n\t\t\t\t.isRequired(false)\n\t\t\t\t.withDescription(\"option baz\")\n\t\t        .create(\"baz\");\n\n\t\tOptionGroup optgrp = new OptionGroup();\n\t\toptgrp.setRequired(true);\n\t\toptgrp.addOption(opt_bar)\n\t\t\t.addOption(opt_baz);\n\n\t\tOptions optsdef = new Options();\n\t\toptsdef.addOption(opt_foo)\n\t\t\t.addOptionGroup(optgrp);\n\n\t\ttry {\n\t\t\tCommandLineParser parser = new GnuParser();\n\t\t\tCommandLine cmdline = parser.parse(optsdef, argv);\n\t\t}\n\t\tcatch (MissingOptionException ex) {\n\t\t\tList opts = ex.getMissingOptions();\n\n\t\t\tfor (Object option : opts) {\n\t\t\t\tSystem.out.println(\"OPT: \" + option.getClass().getName());\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n}\n{code}\n\nproduces the following output:\n\n{code}\n</tmp/MissingOptionException> $ javac -cp commons-cli-1.2.jar Test.java\n\n</tmp/MissingOptionException> $ java -cp commons-cli-1.2.jar:. Test\nOPT: java.lang.String\nOPT: org.apache.commons.cli.OptionGroup\n{code}\n\nThe JavaDoc for MissingOptionException.getMissingOptions() says:\n\n{quote}\nReturn the list of options (as strings) missing in the command line parsed.\n{quote}",
                "resolved": "2011-06-02",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-215",
                "project": "Commons CLI",
                "title": "String as default Option type",
                "type": "Bug",
                "description": "getParsedOptionValue returns null unless Option.type gets explicitly set. The user expects it to be String unless set to any other type.\nThis coult be either fixed in the Option constructor or in CommandLine.getParsedOptionValue. Mentioning this behaviour in Javadoc would be advisable.\n\n",
                "resolved": "2011-04-12",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-213",
                "project": "Commons CLI",
                "title": "Quoted string parsing",
                "type": "Bug",
                "description": "When you pass a quoted string as argument in command line (eg. java Hello -e \"fname=\\\"vishal\\\" and lname=\\\"dhawani\\\"\"), it gives you one character less in result (eg. cmdLine.getOptionValue(\"e\") will return you fname=\"vishal\" and lname=\"dhawani).\n\nActually when you see the args[] passed to java, args[1] is fname=\"vishal\" and lname=\"dhawani\" .\n\nThe above thing works when we give extra space, ie. java Hello -e \"fname=\\\"vishal\\\" and lname=\\\"dhawani\\\" \".\n\nPlease check.",
                "resolved": "2011-01-17",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-211",
                "project": "Commons CLI",
                "title": "Cloning Option is now breaking our code",
                "type": "Bug",
                "description": "In out code we create new options and put them in a member variable of a class like this:\n\nOption valuesOption = options.addOption(\"opt1\", true, \"Description.\").getOption(\"opt1\");\nthis.memberOpt = valuesOption;\n\nLater in our code we requested the value with this.memberOpt.getValue(), which worked good on 1.1.\nWith 1.2 all of our code does not work anymore using this mechanism.\nI guess this happens due to the change of Revision 667565 which now clones the Option.\nThis is not got, since all references to the original options given to the parser now do not get their values anymore.",
                "resolved": "2010-10-29",
                "versions": [
                    "1.2"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-210",
                "project": "Commons CLI",
                "title": "[OptionBuilder] argName isn't initialized",
                "type": "Bug",
                "description": "\"argName\" is null in the initial stage, but when \"reset\" method is calling \"argName\" is set to \"arg\".",
                "resolved": "2010-09-29",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-209",
                "project": "Commons CLI",
                "title": "OptionBuilder is not thread-safe",
                "type": "Bug",
                "description": "Class OptionBuilder is not thread-safe.\nIt uses one OptionBuilder instance without synchronizing access to it.\nIf more than one thread uses OptionBuilder, that can result in invalid Options (suppose a scheduler component).\n\nDon't know if this should be fixed. At least the Javadoc should mention the fact that the class is not thread-safe.\nAs a workaround, use constructor of class Option.\n",
                "resolved": "2010-10-29",
                "versions": [
                    "1.0",
                    "1.1",
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-208",
                "project": "Commons CLI",
                "title": "Error in javadoc CLI 1.2",
                "type": "Bug",
                "description": "javadoc for method isRequired() is wrong (probably copy/paste error) :\n\n    Query to see if this Option requires an argument\n        boolean flag indicating if an argument is required\n\n-> should be \"Query to see if this Option is mandatory, boolean flag indicating if this Option is mandatory\"\n",
                "resolved": "2010-09-19",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-207",
                "project": "Commons CLI",
                "title": "HelpFormatter strips leading whitespaces in the footer",
                "type": "Bug",
                "description": "I discovered a bug in Commons CLI while using it through Groovy's CliBuilder. See the following issue:\n\nhttp://jira.codehaus.org/browse/GROOVY-4313?page=com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel\n\nCopied:\nThe following code:\n\ndef cli = new CliBuilder(footer: \"line1:\\n line2:\\n\")\ncli.usage()\n\nProduces the following output:\n\nline1\nline2\n\nNote that there are no whitespaces before \"line2\". Replacing them with \"\\t\" doesn't solve the problem either.",
                "resolved": "2010-07-21",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-206",
                "project": "Commons CLI",
                "title": "If Parser.parse is called with a Properties parameter that contains an option not defined, get a NPE",
                "type": "Bug",
                "description": "See junit test below.\n\nThe problems appears to be in org.apache.commons.cli.Parser.processProperties, around lines 252 - 259.\n\nIt's trying to get the Option object for the property's name, but if none was specified, then opt is null and the attempt to call opt.hasArg() at line 259 throws an NPE.\n\nThe fix should be to skip the remainder of the clause if the Option object is null.\n\n\nExample unit test:\n\n{code:java}\npackage test;\n\nimport java.util.Properties;\n\nimport org.apache.commons.cli.OptionBuilder;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.PosixParser;\nimport org.junit.Test;\n\n\npublic class CommonsCliBugTest {\n\n    @Test\n    public void testCommonsCliOkay() throws Exception {\n        String[] args = new String[] {};\n        Properties p = new Properties();\n        p.setProperty(\"alpha\", \"beta\");\n        Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"alpha\").hasArg().withArgName(\"ALPHA\").create());\n        PosixParser parser = new PosixParser();\n        parser.parse(options, args, p);\n    }\n\n    @Test\n    public void testCommonsCliFails() throws Exception {\n        String[] args = new String[] {};\n        Properties p = new Properties();\n        // Note this property is not specified as a valid option\n        p.setProperty(\"gamma\", \"beta\");\n        Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"alpha\").hasArg().withArgName(\"ALPHA\").create());\n        PosixParser parser = new PosixParser();\n        parser.parse(options, args, p);\n    }\n}\n{code}",
                "resolved": "2010-07-16",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-205",
                "project": "Commons CLI",
                "title": "HelpFormatter.setArgName() has no effect",
                "type": "Bug",
                "description": "The default argument name set on the HelpFormatter has no effect because the Option and the OptionBuilder bring automatically a default value 'arg'.",
                "resolved": "2010-06-19",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-204",
                "project": "Commons CLI",
                "title": "NullPointerException with unrecognized default options",
                "type": "Bug",
                "description": "Passing default options to the parser that weren't defined triggers a NullPointerException instead of a ParseException.",
                "resolved": "2010-06-17",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-203",
                "project": "Commons CLI",
                "title": "The state of the option groups is not updated by the default options",
                "type": "Bug",
                "description": "The state of the option groups is neither checked nor updated when the default options passed as a Properties instance to the parse method are processed. For example if 'a' and 'b' are two mutually exclusive options, the command line argument could specify 'a' and the default options could contain 'b', the parser will not complain and the resulting CommandLine will contain 'a' and 'b'.\n",
                "resolved": "2010-06-17",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-202",
                "project": "Commons CLI",
                "title": "Default options are not taken into account for the required options",
                "type": "Bug",
                "description": "The default options passed as a Properties instance to the parse method are not taken into account when the required options are checked at the end of the parsing. If a required option wasn't present among the arguments of the command line and is picked from the default options, a ParseException is thrown.",
                "resolved": "2010-06-16",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-201",
                "project": "Commons CLI",
                "title": "Default options may be partially processed",
                "type": "Bug",
                "description": "The Properties instance passed to the Parser.parse() method to initialize the default options may be partially processed. This happens when the properties contains an option that doesn't accept arguments and has a default value that isn't evaluated to \"true\". When this case occurs the processing of the properties is stopped and the remaining options are never handled.\n\nThis is caused by the break statement in Parser.processProperties(Properties), a continue statement should have been used instead.\n\nThe related test in ValueTest is also wrong, there are two assertions that need to be changed:\n\n{code}\nOptions opts = new Options();\nopts.addOption(\"a\", false, \"toggle -a\");\nopts.addOption(\"c\", \"c\", false, \"toggle -c\");\nopts.addOption(OptionBuilder.hasOptionalArg().create('e'));\n\nproperties = new Properties();\nproperties.setProperty( \"a\", \"false\" );\nproperties.setProperty( \"c\", \"no\" );\nproperties.setProperty( \"e\", \"0\" );\n\ncmd = parser.parse(opts, null, properties);\nassertTrue( !cmd.hasOption(\"a\") );\nassertTrue( !cmd.hasOption(\"c\") );\nassertTrue( !cmd.hasOption(\"e\") ); // Wrong, this option accepts an argument and should receive the value \"0\"\n{code}\n\n and the second one:\n\n{code}\nproperties = new Properties();\nproperties.setProperty( \"a\", \"just a string\" );\nproperties.setProperty( \"e\", \"\" );\n\ncmd = parser.parse(opts, null, properties);\nassertTrue( !cmd.hasOption(\"a\") );\nassertTrue( !cmd.hasOption(\"c\") );\nassertTrue( !cmd.hasOption(\"e\") ); // Wrong, this option accepts an argument and should receive an empty string as value\n{code}\n",
                "resolved": "2010-06-16",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-200",
                "project": "Commons CLI",
                "title": "particular spelled wrong in Javadoc",
                "type": "Bug",
                "description": "{code}\nIndex: CommandLine.java\n===================================================================\n--- CommandLine.java\t(revision 950536)\n+++ CommandLine.java\t(working copy)\n@@ -%ld,%ld +%ld,%ld @@\n      * Return a version of this <code>Option</code> converted to a particular type. \n      *\n      * @param opt the name of the option\n-     * @return the value parsed into a particluar object\n+     * @return the value parsed into a particular object\n      * @throws ParseException if there are problems turning the option value into the desired type\n      * @see PatternOptionBuilder\n      * @since 1.2\n{code}",
                "resolved": "2010-06-02",
                "versions": [
                    "1.2",
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-198",
                "project": "Commons CLI",
                "title": "Download links for CLI 1.2 binaries are broken",
                "type": "Bug",
                "description": "On the following page\nhttp://commons.apache.org/cli/download_cli.cgi\nthe download links for the Binary files of commons-cli 1.2 are broken.\n\nThe reason is that the files are named \n\"commons-cli-1.2-bin.zip\" etc., but the links point to\n\"commons-cli-1.2.zip\" etc.",
                "resolved": "2010-04-23",
                "versions": [
                    "1.2"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-197",
                "project": "Commons CLI",
                "title": "boolean option in documentation is woorking oposite way documented",
                "type": "Bug",
                "description": "In documentation it says as follows:\n\nCommandLine parse(Options options,\n                  String[] arguments,\n                  boolean stopAtNonOption)\n                  throws ParseException\n\n        stopAtNonOption - specifies whether to continue parsing the arguments if a non option is encountered. \n\n\nThe parser stops an throws Exception if \"stopAtNonOption\" is set to false (when I guess it should be other way round), if I set boolean \"true\", the parser ignores unknown arguments and continues without throwing Exception.",
                "resolved": "2010-06-15",
                "versions": [],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-193",
                "project": "Commons CLI",
                "title": "StringIndexOutOfBoundsException in HelpFormatter.findWrapPos",
                "type": "Bug",
                "description": "In the last while loop in HelpFormatter.findWrapPos, it can pass text.length() to text.charAt(int), which throws a StringIndexOutOfBoundsException. The first expression in that while loop condition should use a <, not a <=.\n\nThis is on line 908 in r779646:\n  http://svn.apache.org/viewvc/commons/proper/cli/trunk/src/java/org/apache/commons/cli/HelpFormatter.java?revision=779646&view=markup",
                "resolved": "2010-07-07",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-192",
                "project": "Commons CLI",
                "title": "single character arguments are wrongly interpreted as short options",
                "type": "Bug",
                "description": "If I have a command line which supports \"-o\"\nor equivalently \"--option\", and \"-foo\", then\n\n--foo o\n\ngets interpreted as if I had typed \"--foo -o\", i.e. the \"o\" is (wrongly) seen as an option\ninstead of an argument to \"--foo\". Foo then (wrongly) has no arguments.",
                "resolved": "2010-07-07",
                "versions": [
                    "1.1"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-191",
                "project": "Commons CLI",
                "title": "Coding error: OptionGroup.setSelected causes java.lang.NullPointerException",
                "type": "Bug",
                "description": "Code snippet from OptionGroup.setSelected(Option option):\n...\n        if (selected == null || selected.equals(option.getOpt()))\n        {\n            selected = option.getOpt(); \n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n...\nWhen parameter option is \"null\" to reset the selected option, selected.equals(option.getOpt()) will obviously fail.\nIssue is already fixed in the head revision of 1.3.\n\n",
                "resolved": "2010-03-02",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-189",
                "project": "Commons CLI",
                "title": "\"Unexpected --help while processing\"",
                "type": "Bug",
                "description": "The help trigger feature seems not working.\nWhen I pass --help to the command line, I have \"Unexpected --help while processing\", then usage is printed.\nCode snippet:\n{code:java}\n Parser parser = new Parser();\n parser.setGroup(group);\n parser.setHelpFormatter(new HelpFormatter());\n parser.setHelpTrigger(\"--help\");\n parser.parseAndHelp(args);\n{code}",
                "resolved": "2010-06-11",
                "versions": [
                    "2.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-187",
                "project": "Commons CLI",
                "title": "OptionBuilder working incorrectly at first Invocation of create(...)",
                "type": "Bug",
                "description": "OptionBuilder is working incorrectly when invoked for the first time. Since \"argName\" is null the arg-text will not be initialized for the first option created. argName is set on the call to reset() though.\nSo after the first Option created OptionBuilder works fine.",
                "resolved": "2010-06-19",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-186",
                "project": "Commons CLI",
                "title": "Standard help text will not show mandatory arguments for first option",
                "type": "Bug",
                "description": "The generated help text will not show \"<arg>\" for the first argument added.\n\n\nSee attached test case:\n\n\nPlease confirm",
                "resolved": "2010-06-19",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-185",
                "project": "Commons CLI",
                "title": "Commons CLI incorrectly stripping leading and trailing quotes",
                "type": "Bug",
                "description": "org.apache.commons.cli.Parser.processArgs() calls Util.stripLeadingAndTrailingQuotes() for all argument values. IMHO this is incorrect and totally broken.\n\nIt is trivial to create a simple test for this. Output:\n\n    $ java -cp target/clitest.jar Clitest --balloo \"this is a \\\"test\\\"\"\n    Value of argument balloo is 'this is a \"test'.\n\nThe argument 'balloo' should indeed keep its trailing double quote. It is what the shell gives it, so don't try to do something clever to it.\n\nThe offending code was committed here:\n    http://svn.apache.org/viewvc?view=rev&revision=129874\nand has been there for more than 6 years (!). Why was this committed in the first place?\n\nThe fix is trivial, just get rid of Util.stripLeadingAndTrailingQuotes(), and consequently avoid calling it from Parser.processArgs().",
                "resolved": "2010-06-16",
                "versions": [
                    "1.1",
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-184",
                "project": "Commons CLI",
                "title": "Negative arguments should take the priority over numerical options",
                "type": "Bug",
                "description": "A negative argument can be mistaken for an option, for example with the options '1' and 'N' both having an argument, the following command line:\n\n{code}-N -123{code}\n\nwill be interpreted as the option N with no argument, and the option 1 with 23 as argument. But the right interpretation is N=-123. The token -123 has been processed as a potential option first before being considered as the argument of the previous option.\n\nThis is consistent with JOpt Simple.",
                "resolved": "2009-05-30",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-183",
                "project": "Commons CLI",
                "title": "Clear the selection from the groups before parsing",
                "type": "Bug",
                "description": "OptionGroup stores the name of the option selected after the parsing. If the same Options is used again to parse another command line, an AlreadySelectedException is likely to occur since the selection state is never cleared from the option group.\n\nThis case was already covered by testValidLongOnlyOptions() in OptionGroupTest, but it never failed due to CLI-182.\n",
                "resolved": "2009-05-30",
                "versions": [
                    "1.0",
                    "1.1",
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-182",
                "project": "Commons CLI",
                "title": "Unable to select a pure long option in a group",
                "type": "Bug",
                "description": "OptionGroup doesn't play nice with options with a long name and no short name. If the selected option hasn't a short name, group.setSelected(option) has no effect.\n",
                "resolved": "2009-05-30",
                "versions": [
                    "1.0",
                    "1.1",
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-180",
                "project": "Commons CLI",
                "title": "arguments with spaces parsed as individual arguments",
                "type": "Bug",
                "description": "If an argument contains a space then the part after the space is treated as another argument and you end up with an invalid argument error.\n\nTried many things to escape the space: double quotes around the argument value, backslash before the space, short and long forms, etc. Nothing is working.",
                "resolved": "2009-05-26",
                "versions": [
                    "1.1",
                    "1.2"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-178",
                "project": "Commons CLI",
                "title": "org.apache.commons.cli.ParserTestCase: Test doesn't pass on Sun JDK 1.6.0.12, Gentoo Linux",
                "type": "Bug",
                "description": "Hello, I was bumping the Gentoo version of commons-CLI to 1.2 and in the process tried to run the tests. It fails at this test:\n\n    [junit] Testsuite: org.apache.commons.cli.ParserTestCase\n    [junit]     at sun.reflect.InstantiationExceptionConstructorAccessorImpl.newInstance(InstantiationExceptionConstructorAccessorImpl.java:30)\n    [junit]     at java.lang.reflect.Constructor.newInstance(Constructor.java:494)\n    [junit]     at junit.framework.TestSuite.createTest(TestSuite.java:54)\n    [junit]     at junit.framework.TestSuite.addTestMethod(TestSuite.java:280)\n    [junit]     at junit.framework.TestSuite.<init>(TestSuite.java:140)\n    [junit]     at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:396)\n    [junit]     at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.launch(JUnitTestRunner.java:911)\n    [junit]     at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.main(JUnitTestRunner.java:768)\n    [junit] ))\n    [junit] Tests run: 1, Failures: 1, Errors: 0, Time elapsed: 0.073 sec\n    [junit] Tests run: 1, Failures: 1, Errors: 0, Time elapsed: 0.073 sec\n    [junit]\n    [junit] Testcase: warning took 0.005 sec\n    [junit]     FAILED\n    [junit] Cannot instantiate test case: testSimpleShort (java.lang.InstantiationException\n    [junit]     at sun.reflect.InstantiationExceptionConstructorAccessorImpl.newInstance(InstantiationExceptionConstructorAccessorImpl.java:30)\n    [junit]     at java.lang.reflect.Constructor.newInstance(Constructor.java:494)\n    [junit]     at junit.framework.TestSuite.createTest(TestSuite.java:54)\n    [junit]     at junit.framework.TestSuite.addTestMethod(TestSuite.java:280)\n    [junit]     at junit.framework.TestSuite.<init>(TestSuite.java:140)\n    [junit]     at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:396)\n    [junit]     at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.launch(JUnitTestRunner.java:911)\n    [junit]     at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.main(JUnitTestRunner.java:768)\n    [junit] )\n    [junit] junit.framework.AssertionFailedError: Cannot instantiate test case: testSimpleShort (java.lang.InstantiationException\n    [junit]     at java.lang.reflect.Constructor.newInstance(Constructor.java:494)\n    [junit] )\n    [junit]\n\nNote that the others tests before run fine. Note that when using Maven all the tests run fine but only because the problematic test is *NOT* run. Does that means that it should not be run? (I used mvn ant:ant to generate an Ant buildfile as Gentoo packaging system does not support Maven yet).\n",
                "resolved": "2009-03-28",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-177",
                "project": "Commons CLI",
                "title": "OptionBuilder is not reseted in case of an IAE at create",
                "type": "Bug",
                "description": "If the call to OptionBuilder.create() fails with an IllegalArgumentException, the OptionBuilder is not resetted and its next usage may contain unwanted settings. Actually this let the CLI-1.2 RCs fail on IBM JDK 6 running on Maven 2.0.10.",
                "resolved": "2009-03-16",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-176",
                "project": "Commons CLI",
                "title": "Long descriptions wrap incorrectly",
                "type": "Bug",
                "description": "When some option has a really long description (at least 3 lines), it wraps incorrectly. See attached picture, it's a total mess.\n\nThe problem is, you have default width set to 74 characters. But when you are printing the second line of the description, you forget to count also the preceding white space into the 74 characters. Therefore the second line wraps into a third line. After all 74 characters are printed, you start again on fourth line with a correct preceding white space. And over and over again.\n\nThis fix should be really easy. Just count the whitespace.",
                "resolved": "2009-05-25",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-175",
                "project": "Commons CLI",
                "title": "Test class BugCLI162Test fails under Windows",
                "type": "Bug",
                "description": "Two test methods are failing due to system depending line endings:\n\nFailed tests:\n  testLongLineChunking(org.apache.commons.cli.bug.BugCLI162Test)\n  testLongLineChunkingIndentIgnored(org.apache.commons.cli.bug.BugCLI162Test",
                "resolved": "2009-02-28",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-174",
                "project": "Commons CLI",
                "title": "RuntimeException in the wrapping code of HelpFormatter",
                "type": "Bug",
                "description": "If there is not enough space to display a word on a single line, HelpFormatter goes into a infinite loops until the JVM crashes with an OutOfMemoryError.\n\nTest case:\n\n{code}\nOptions options = new Options();\noptions.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n\nHelpFormatter formatter = new HelpFormatter();\nformatter.setWidth(20);\nformatter.printHelp(\"app\", options); // hang & crash\n{code}\n\nAn helpful exception indicating the insufficient width would be more appropriate than an OutOfMemoryError.",
                "resolved": "2009-02-18",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-171",
                "project": "Commons CLI",
                "title": "Typo in ant documentation, more logical example code",
                "type": "Bug",
                "description": "ant.xml contains a typo (used \u2192 user).\n\nFurthermore, it uses withShortName for the full-word arguments.  I would use withLongName for that.",
                "resolved": "2008-10-14",
                "versions": [
                    "2.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-165",
                "project": "Commons CLI",
                "title": "PosixParser keeps processing tokens after a non unrecognized long option",
                "type": "Bug",
                "description": "PosixParser keeps processing tokens after a non unrecognized long option when stopAtNonOption is enabled. The tokens after the unrecognized long option are burst, split around '=', etc.. instead of being kept as is.\n\nFor example, with the options 'a' and 'b' defined, 'b' having an argument, the following command line:\n\n{code}--zop -abfoo{code}\n\nis interpreted as:\n\n{code}--zop -a -b foo{code}\n\nbut the last token should remain unchanged.",
                "resolved": "2008-07-28",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-164",
                "project": "Commons CLI",
                "title": "PosixParser ignores unrecognized tokens starting with '-'",
                "type": "Bug",
                "description": "PosixParser doesn't handle properly unrecognized tokens starting with '-' when stopAtNonOption is enabled, the token is simply ignored.\n\nFor example, if the option 'a' is defined, the following command line:\n\n{code}-z -a foo{code}\n\nis interpreted as:\n\n{code}-a foo{code}",
                "resolved": "2008-07-28",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-163",
                "project": "Commons CLI",
                "title": "PosixParser keeps bursting tokens even if a non option character is found",
                "type": "Bug",
                "description": "PosixParser doesn't stop the bursting process of a token if stopAtNonOption is enabled and a non option character is encountered.\n\nFor example if the options a and b are defined, with stopAtNonOption=true the following command line:\n\n{code}-azb{code}\n\nis turned into:\n\n{code}-a zb -b{code}\n\nthe right output should be:\n\n{code}-a zb{code}\n",
                "resolved": "2008-07-27",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-162",
                "project": "Commons CLI",
                "title": "infinite loop in the wrapping code of HelpFormatter",
                "type": "Bug",
                "description": "If there is not enough space to display a word on a single line, HelpFormatter goes into a infinite loops until the JVM crashes with an OutOfMemoryError.\n\nTest case:\n\n{code}\nOptions options = new Options();\noptions.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n\nHelpFormatter formatter = new HelpFormatter();\nformatter.setWidth(20);\nformatter.printHelp(\"app\", options); // hang & crash\n{code}\n\nAn helpful exception indicating the insufficient width would be more appropriate than an OutOfMemoryError.",
                "resolved": "2009-02-20",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-161",
                "project": "Commons CLI",
                "title": "PosixParser doesn't stop the parsing on \"--\" tokens following an option with an argument",
                "type": "Bug",
                "description": "PosixParser doesn't stop on \"--\" tokens if the option preceding the token expects an argument. GnuParser is not affected by this issue.\n\nTest case:\n\n{code}\npublic void testDoubleHyphenToken() throws Exception\n{\n    Options options = new Options();\n    options.addOption(OptionBuilder.hasArg().create('n'));\n    options.addOption(OptionBuilder.create('m'));\n\n    CommandLine cl = parser.parse(options, new String[] { \"-n\", \"--\", \"-m\" });\n\n    assertTrue(cl.hasOption(\"n\"));\n    assertFalse(cl.hasOption(\"m\"));\n}\n{code}\n",
                "resolved": "2009-05-30",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CLI-159",
                "project": "Commons CLI",
                "title": "The required property for the child groups of a group should be more consistent",
                "type": "Bug",
                "description": "Currently restrictions defined for a child group can also affect the parent group. For instance, if for the child group a minimum constraint greater than 0 is set, the parent group will implicitly become required, even if its minimum is set to 0.\n\nThis is counter-intuitive. It would be more consistent if the minimum and maximum constraints of the parent group were independent of the settings in the child groups. Then it would be possible to model constellations like an optional parent group with a child group that has required elements (i.e. the child group is optional, but if it is present, all required elements must be provided).",
                "resolved": "2008-07-27",
                "versions": [
                    "2.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-158",
                "project": "Commons CLI",
                "title": "deafult arguments only works if no arguments are submitted",
                "type": "Bug",
                "description": "When using multple arguments and defaults, the behaviour is counter-intuitive and will only pick up a default if no args are passed in.\n\nFor instance in the code below I have set up so 0, 1, or 2 args may bve accepted, with defaults 100 and 1000.\n\nI expect it to behave as follows.\n1. for 2 args, 1 and 2 the values should be 1 and 2. This works as expected.\n2. for 0 args passed in the values should be 100 and 1000, picking up both of the defaults. This works as expected\n\n\n3. for 1 arg passed in the values should be 1 and 1000, so the second argument picks up the second default value. The valuse become just 1, which is not as expected..\n\n\nCurrently, in the second case will only return 1 and ignore the defaults.\n\n\n\n    public void testSingleOptionSingleArgument() throws Exception {\n        String defaulValue1 = \"100\";\n        String defaultValue2 = \"1000\";\n        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n        final ArgumentBuilder abuilder = new ArgumentBuilder();\n        final GroupBuilder gbuilder = new GroupBuilder();\n\n        DefaultOption bOption = obuilder.withShortName(\"b\")\n                .withLongName(\"b\")\n                .withArgument(abuilder.withName(\"b\")\n                        .withMinimum(0)\n                        .withMaximum(2)\n                        .withDefault(defaulValue1)\n                        .withDefault(defaultValue2)\n                        .create())\n                .create();\n\n        Group options = gbuilder\n                .withName(\"options\")\n                .withOption(bOption)\n                .create();\n\n        Parser parser = new Parser();\n        parser.setHelpTrigger(\"--help\");\n        parser.setGroup(options);\n        String enteredValue1 = \"1\";\n        String[] args = new String[]{\"-b\", enteredValue1};\n        CommandLine cl = parser.parse(args);\n        CommandLine cmd = cl;\n        assertNotNull(cmd);\n        List b = cmd.getValues(\"-b\");\n        assertEquals(\"[\" + enteredValue1 + \"]\", b + \"\");\n    }\n\n",
                "resolved": "2008-07-24",
                "versions": [
                    "2.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-156",
                "project": "Commons CLI",
                "title": "Missing required options not throwing MissingOptionException",
                "type": "Bug",
                "description": "When an Options object is used to parse a second set of command arguments it won't throw a MissingOptionException.\n\n{code:java}\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.GnuParser;\nimport org.apache.commons.cli.OptionBuilder;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\n\npublic class Example\n{\n\tpublic static void main(String[] args) throws ParseException\n\t{\n\t\tbrokenExample();\n\t\tworkingExample();\n\t}\n\n\t// throws exception as expected\n\tprivate static void workingExample() throws ParseException\n\t{\n\t\tString[] args = {};\n\n\t\tOptions opts = new Options();\n\t\topts.addOption(OptionBuilder.isRequired().create('v'));\n\n\t\tGnuParser parser = new GnuParser();\n\t\tCommandLine secondCL = parser.parse(opts, args);\n\n\t\tSystem.out.println(\"Done workingExample\");\n\t}\n\n\t// fails to throw exception on second invocation of parse\n\tprivate static void brokenExample() throws ParseException\n\t{\n\t\tString[] firstArgs = { \"-v\" };\n\t\tString[] secondArgs = {};\n\n\t\tOptions opts = new Options();\n\t\topts.addOption(OptionBuilder.isRequired().create('v'));\n\n\t\tGnuParser parser = new GnuParser();\n\t\tCommandLine firstCL = parser.parse(opts, firstArgs);\n\t\tCommandLine secondCL = parser.parse(opts, secondArgs);\n\n\t\tSystem.out.println(\"Done brokenExample\");\n\t}\n}\n{code}\n\nThis is a result of the Options object returning the reference to its own list and the parsers modifying that list. The first call is removing the required options as they are found and subsequent calls get back an empty list.",
                "resolved": "2008-05-29",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-154",
                "project": "Commons CLI",
                "title": "Incomplete usage documentation about Java property option",
                "type": "Bug",
                "description": "On Usage Scenarios page http://jakarta.apache.org/commons/cli/usage.html, in the \"Java property option\" section of \"Ant example\", after the creation of the property Option, ie :\n\nOption property  = OptionBuilder.withArgName( \"property=value\" )\n                                .hasArg()\n                                .withValueSeparator()\n                                .withDescription( \"use value for given property\" )\n                                .create( \"D\" );\n\nOne should add :\n\nproperty.setArgs(Option.UNLIMITED_VALUES);\n\nfor the example to work properly.\n\nIn the \"Querying the commandline\" section, the code line :\n    this.buildfile = line.getValue( \"buildfile\" );\n\nshould be :\n    this.buildfile = line.getOptionValue( \"buildfile\" );\n\n\nAlso some parsing code could be given about the special property option, for instance :\n\nProperties props = new Properties();\n\nif( line.hasOption( \"D\" ) ) {\n\n    String[] args = line.getOptionValues( \"D\" );\n\n    for (int i = 0; i < args.length; i += 2) {\n        String propertyName = args[i];\n        String propertyValue = null;\n\n        if (i + 1 < args.length)\n            propertyValue = args[i + 1];\n\n        props.put(propertyName, propertyValue);\n    }\n}",
                "resolved": "2008-06-13",
                "versions": [
                    "1.0",
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-151",
                "project": "Commons CLI",
                "title": "HelpFormatter wraps incorrectly on every line beyond the first",
                "type": "Bug",
                "description": "The method findWrapPos(...) in the HelpFormatter is a couple of bugs in the way that it deals with the \"startPos\" variable.  This causes it to format every line beyond the first line by \"startPos\" to many characters, beyond the specified width.  \n\nTo see this, create an option with a long description, and then use the help formatter to print it.  The first line will be the correct length.  The 2nd, 3rd, etc lines will all be too long.\n\nI don't have a patch (sorry) - but here is a corrected version of the method.\n\nI fixed it in two places - both were using \"width + startPos\" when they should have been using width.\n\n{code}\n protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos+1;\n        }\n        else if ((width) >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length())        ? (-1) : pos;\n    }\n{code}",
                "resolved": "2009-02-18",
                "versions": [],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-150",
                "project": "Commons CLI",
                "title": "Negative numbers mistaken for options",
                "type": "Bug",
                "description": "If an option has a negative numerical argument, the parser mistakes it for another option and throws an error. For example, consider:\n\n{{Argument numArg = aBuilder.withValidator(NumberValidator.getNumberInstance()).withMinimum(1).withMaximum(1).create();}}\n{{Option numOpt = oBuilder.withLongName(\"num\").withArgument(numArg).create();}}\n{{Group options = gBuilder.withOption(numOpt).create();}}\n\nThen parsing {{--num -0.1}} results in:\n\n{{Unexpected -0.1 while processing --num}}\n\n\n\n",
                "resolved": "2008-07-30",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-149",
                "project": "Commons CLI",
                "title": "MissingOptionException.getMessage() changed from CLI 1.0 > 1.1",
                "type": "Bug",
                "description": "The MissingOptionException.getMessage() string changed from CLI 1.0 > 1.1. \n\nCLI 1.0 was poorly formatted but readable:\nMissing required options: -format-source-properties\n\nCLI 1.1 is almost unreadable:\nMissing required options: formatsourceproperties\n\nIn CLI 1.0 Options.addOption(Option) prefixed the stored options with a \"-\" and in CLI 1.1 it doesn't.\n\nI would suggest changing Parser.checkRequiredOptions() to add the options to the error message with a prefix of \" -\":\n\nOLD: \n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\nNEW: \n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(\" -\" + iter.next());\n            }\n\nResulting in:\nMissing required options: -format -source -properties\n",
                "resolved": "2008-05-08",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-148",
                "project": "Commons CLI",
                "title": "arguments are interpreted as options",
                "type": "Bug",
                "description": "The command-line parser interprets arguments to options as options if they match existing options.  Example:\n\nAssume\n-a arg\n-b arg\n\n-a b -b a was fixed in CLI-71, but\n\n-a \"-b\" returns \nUnable to parse command line: no argument for:a\n\n-a \"-c\" is OK if \"-c\" is not defined as an option.\n\nThe option in my case was \"-password\" and their password happened to match one of the options.",
                "resolved": "2008-01-02",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-145",
                "project": "Commons CLI",
                "title": "ArgumentBuilder.withMaximum causes parse errors: Unexpeced <value> while processing options",
                "type": "Bug",
                "description": "With the sample program below, running with the arguments\n\n  -a 0 -b 1 2 3 4\n\ncauses the error:\n\nUnexpected 3 while processing options                                           \nUsage:                                                                          \n [-a <a1> [<a2> ...] -b <b1> <b2> [<b3> [<b4>]]]                                \noptions                                                                         \n  -a (--a) a [a ...]                                                            \n  -b (--b) b b [b [b]]                                                          \n\nI specified .withMinimum(2).withMaximum(4) \nThe help is correct, but the value '3' is not added as a value.\n\nNote also that if for bOption, if you add two more defaults (uncomment them in the source)\n\n            .withDefault(\"10000\")\n            .withDefault(\"1000000\")\n\nan error is raised (incorrectly) on the first b value (i.e. 1 instead of 3) :\n\nUnexpected 1 while processing options         \nUsage:                                                                          \n [-a <a1> [<a2> ...] -b <b1> <b2> [<b3> [<b4>]]]                                \noptions                                                                         \n  -a (--a) a [a ...]                                                            \n  -b (--b) b b [b [b]]\n\n\nSource:\n\npackage org.apache.commons.cli2.issues;\n\nimport java.util.List;\nimport org.apache.commons.cli2.CommandLine;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.builder.ArgumentBuilder;\nimport org.apache.commons.cli2.builder.DefaultOptionBuilder;\nimport org.apache.commons.cli2.builder.GroupBuilder;\nimport org.apache.commons.cli2.commandline.Parser;\nimport org.apache.commons.cli2.option.DefaultOption;\n\npublic class WithMinimum\n{\n   public static void main(String[] args)\n   {\n      final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n      final ArgumentBuilder abuilder = new ArgumentBuilder();\n      final GroupBuilder gbuilder = new GroupBuilder();\n      DefaultOption aOption = obuilder//\n            .withShortName(\"a\")\n            .withLongName(\"a\")\n            .withArgument(abuilder\n                  .withName(\"a\")\n                  .withDefault(\"10\")\n                  .create())\n            .create();\n      DefaultOption bOption = obuilder\n      .withShortName(\"b\")\n      .withLongName(\"b\")\n      .withArgument(abuilder\n            .withName(\"b\")\n            .withMinimum(2)\n            .withMaximum(4)\n            .withDefault(\"100\")\n            .withDefault(\"1000\")\n//            .withDefault(\"10000\")\n//            .withDefault(\"1000000\")\n            .create())\n      .create();\n      Group options = gbuilder\n            .withName(\"options\")\n            .withOption(aOption)\n            .withOption(bOption)\n            .create();\n      Parser parser = new Parser();\n      parser.setHelpTrigger(\"--help\");\n      parser.setGroup(options);\n      CommandLine cl = parser.parseAndHelp(args);\n      if (cl == null)\n         System.exit(1);\n      int a = Integer.parseInt(cl.getValue(aOption).toString());\n      List b = cl.getValues(bOption);\n      System.out.printf(\"a=%d b=%s%n\", a, b);\n   }\n}\n",
                "resolved": "2008-06-09",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-144",
                "project": "Commons CLI",
                "title": "adding a FileValidator results in ClassCastException in parser.parseAndHelp(args)",
                "type": "Bug",
                "description": "When I add a FileValidator.getExistingFileInstance() to an Argument, I get a ClassCastException when I parse args.\n\nBelow is a testcase invoke with\n\n   java org.apache.commons.cli2.issues.CLI2Sample -classpath commons-cli-2.0-SNAPSHOT.jar --file-name path-to-an-existing-file\n\nRun it and you get:\n\nException in thread \"main\" java.lang.ClassCastException: java.io.File cannot be cast to java.lang.String\n\tat org.apache.commons.cli2.validation.FileValidator.validate(FileValidator.java:122)\n\tat org.apache.commons.cli2.option.ArgumentImpl.validate(ArgumentImpl.java:250)\n\tat org.apache.commons.cli2.option.ParentImpl.validate(ParentImpl.java:123)\n\tat org.apache.commons.cli2.option.DefaultOption.validate(DefaultOption.java:175)\n\tat org.apache.commons.cli2.option.GroupImpl.validate(GroupImpl.java:264)\n\tat org.apache.commons.cli2.commandline.Parser.parse(Parser.java:105)\n\tat org.apache.commons.cli2.commandline.Parser.parseAndHelp(Parser.java:125)\n\tat org.apache.commons.cli2.issues.CLI2Sample.main(CLI2Sample.java:38)\n\nComment out the withValidator call and it runs with no exception. \n\nI also get a similar ClassCastException if I add a \n\n  .withValidator(NumberValidator.getIntegerInstance())\n\nto another option/argument.\n\nHere is the source\n\n\npackage org.apache.commons.cli2.issues;\n\nimport java.io.File;\nimport org.apache.commons.cli2.CommandLine;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.builder.ArgumentBuilder;\nimport org.apache.commons.cli2.builder.DefaultOptionBuilder;\nimport org.apache.commons.cli2.builder.GroupBuilder;\nimport org.apache.commons.cli2.commandline.Parser;\nimport org.apache.commons.cli2.option.DefaultOption;\nimport org.apache.commons.cli2.validation.FileValidator;\n\npublic class CLI2Sample\n{\n   public static void main(String[] args)\n   {\n      final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n      final ArgumentBuilder abuilder = new ArgumentBuilder();\n      final GroupBuilder gbuilder = new GroupBuilder();\n      DefaultOption fileNameOption = obuilder\n            .withShortName(\"f\")\n            .withLongName(\"file-name\")\n            .withRequired(true)\n            .withDescription(\"name of an existing file\")\n            .withArgument(abuilder\n                  .withName(\"file-name\")\n                  .withValidator(FileValidator.getExistingFileInstance())\n                  .create())\n            .create();\n      Group options = gbuilder\n            .withName(\"options\")\n            .withOption(fileNameOption)\n            .create();\n      Parser parser = new Parser();\n      parser.setHelpTrigger(\"--help\");\n      parser.setGroup(options);\n      CommandLine cl = parser.parseAndHelp(args);\n     }\n}\n",
                "resolved": "2008-07-23",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-143",
                "project": "Commons CLI",
                "title": "Put CLI 2.x into Maven repository",
                "type": "Bug",
                "description": "The groundswell appears to lead to CLI 1.x being declared at End Of Life and for CLI 2.x to become the new main stream.  However, there is no version of CLI 2.x in the Maven repository.  I think a SNAPSHOT release of some version of the 2.x branch should be put out as a matter of urgency.\n\n(This will enable me to try 2.x out with Groovy and report back.)",
                "resolved": "2008-06-02",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-141",
                "project": "Commons CLI",
                "title": "CLI Option reports arguments incorrectly on toString()",
                "type": "Bug",
                "description": "The Option class contains some logic around the \"hasArg\" boolean that seems to be cruft and no longer works correctly. There is no need for this boolean anymore and its only usage could be replaced with hasArg() / hasArgs() calls.",
                "resolved": "2007-11-18",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-138",
                "project": "Commons CLI",
                "title": "No '--' option for terminating options processing",
                "type": "Bug",
                "description": "It appears that neither 1.0 not 1.1 have a '--' option as the 'end processing options' option.  This is immensely useful to allow parameter that are not options that start with a hyphen.  grep for example does this.  I think it is a bug rather than an enhancement request, I think Commons CLI should support '--' option.",
                "resolved": "2007-08-14",
                "versions": [
                    "1.1"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-137",
                "project": "Commons CLI",
                "title": "Change of behaviour 1.0 -> 1.1",
                "type": "Bug",
                "description": "The code:\n{code}\nimport org.apache.commons.cli.*;\n\npublic class Trial {\n\n  private void execute (String[] commandLine) throws ParseException {\n    Options options = new Options();\n    options.addOption ( OptionBuilder.withLongOpt(\"flob\").hasArg().create('F') );\n\n    CommandLine line = new GnuParser().parse(options, commandLine);\n\n    String[] results = line.getOptionValues('F');\n\n    if ( results != null ) { \n      for ( String s : results ) { \n        System.out.println( \"-F \" + s );\n      } \n    }\n\n    results = line.getOptionValues(\"flob\") ;\n\n    if ( results != null ) { \n      for ( String s : results ) { \n        System.out.println( \"--blah \" + s ); \n      }\n    }\n\n    String[] theRest = line.getArgs() ;\n    for ( String s : theRest ) { \n      System.out.print( s + \" \" ); \n    }\n    System.out.println();\n  }\n\n  public static void main (String[] args) throws ParseException {\n    Trial trial = new Trial() ;\n    trial.execute ( new String[] { \"-F1\" , \"-F3\" , \"-Fbla\" , \"-F 76\" , \"--flob\" , \"54\" } ) ;\n  }\n}\n{code}\nwhen compiled and executed under 1.0 produces:\n\ntrial:\n     [java] -F 1\n     [java] -F 3\n     [java] -F bla\n     [java] -F  76\n     [java] -F 54\n     [java] \n\nHowever, when compiled and executed under 1.1 produces:\n\ntrial:\n     [java] -F 1\n     [java] --blah 1\n     [java] 3 bla  76 54 \n\n",
                "resolved": "2008-06-13",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-135",
                "project": "Commons CLI",
                "title": "Backwards compatibility between 1.1 and 1.0 broken due to Option.addValue removal",
                "type": "Bug",
                "description": "ERROR: 7006: org.apache.commons.cli.Option: Return type of method 'public boolean addValue(java.lang.String)' has been changed to void\nERROR: 7009: org.apache.commons.cli.Option: Accessibility of method 'public boolean addValue(java.lang.String)' has been decreased from public to\npackage",
                "resolved": "2007-06-29",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-134",
                "project": "Commons CLI",
                "title": "1.1 is not backwards compatible because it adds methods to the CommandLineParser interface",
                "type": "Bug",
                "description": "General problem - the interface adds methods.\n\nSolution - remove the interfaces from the methods and people who want to use them will have to use the Parser abstract class instead of the CommandLineParser interface. ",
                "resolved": "2007-06-29",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-133",
                "project": "Commons CLI",
                "title": "NullPointerException in Util.stripLeadingHyphens when passed a null argument",
                "type": "Bug",
                "description": "If you try to do a hasOption(null), you get a NPE:\n\njava.lang.NullPointerException\n\tat org.apache.commons.cli.Util.stripLeadingHyphens(Util.java:39)\n\tat org.apache.commons.cli.CommandLine.resolveOption(CommandLine.java:166)\n\tat org.apache.commons.cli.CommandLine.hasOption(CommandLine.java:68)\n\nEither hasOption should reject the null argument, or the function should simply return false.  I think the latter makes more since, as this is how Java collections generally work.",
                "resolved": "2007-06-06",
                "versions": [
                    "1.0",
                    "1.1"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-129",
                "project": "Commons CLI",
                "title": "CLI_1_BRANCH build.xml doesn't work",
                "type": "Bug",
                "description": "This file was apparently created half-way through the CLI-2 branch.  I removed the second 'jar' task, and fix up a couple other.  ",
                "resolved": "2007-05-21",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-128",
                "project": "Commons CLI",
                "title": "Remove Commons-logging from CLI's pom.xml",
                "type": "Bug",
                "description": "A search of the code in commons-cli 1.0 shows that CLI (rightly) doesn't do any logging, but just raises exceptions when things go wrong. However, the pom.xml states that commons-logging is a dependency, which isn't true. Instead of making users manually exclude commons-logging, it should be removed from the pom.xml. \n\nI hope that future versions will continue to be free from logging, as it's completely unnecessary for such a simple and elegant library. There's just no reason that a simple argument parser should ever need to log its status, except perhaps while fixing a bug--but those statements would be unlikely to be useful again and are better removed.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-127",
                "project": "Commons CLI",
                "title": "Date validation tests are locale dependent",
                "type": "Bug",
                "description": "Date validation tests have strings such as Dec or Jan to specify months. In Italian locale the tests fails because the correct strings are Dic and Gen.\nUse DateFormatSymbols to make the test locale independent",
                "resolved": "2007-03-15",
                "versions": [
                    "2.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-123",
                "project": "Commons CLI",
                "title": "the minimum and maximum constraints on a group do not take other groups into account",
                "type": "Bug",
                "description": "If you have a Group A as a child of Group B and you set a minimum or maximum on Group B, the presence or not of Group A will not affect GroupB. This is because Groups are never added to a CommandLine so .hasOption(A) returns false and so it isn't counted. WriteableCommandLine#addOption(Option) should be used to indicate that a Group is present if any of a Groups children is present.",
                "resolved": "2008-07-24",
                "versions": [
                    "2.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-121",
                "project": "Commons CLI",
                "title": "Tests fail under 1.6 + error at end that may or may not be related",
                "type": "Bug",
                "description": "Testsuite: org.apache.commons.cli2.bug.Bug27575Test\nTests run: 1, Failures: 1, Errors: 0, Time elapsed: 0.058 sec\n\nTestcase: testRequiredOptions(org.apache.commons.cli2.bug.Bug27575Test):        FAILED\nexpected:<[-h]> but was:<-c <arg>>\njunit.framework.ComparisonFailure: expected:<[-h]> but was:<-c <arg>>\n        at org.apache.commons.cli2.bug.Bug27575Test.testRequiredOptions(Bug27575Test.java:36)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\n\nand error at end of:\n\nException in thread \"Thread-1\" javax.xml.transform.TransformerFactoryConfigurationError: Provider for javax.xml.transform.TransformerFactory cannot be found\n        at javax.xml.transform.TransformerFactory.newInstance(Unknown Source)\n        at java.util.prefs.XmlSupport.writeDoc(XmlSupport.java:246)\n        at java.util.prefs.XmlSupport.exportMap(XmlSupport.java:333)\n        at java.util.prefs.FileSystemPreferences$8.run(FileSystemPreferences.java:607)",
                "resolved": "2008-02-23",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-74",
                "project": "Commons CLI",
                "title": "Prefix ignored with DefaultOption",
                "type": "Bug",
                "description": "I created the same Option using DefaultOption and DefaultOptionBuilder but \nthey behave differently for short (and I am guessing for long as well) \nprefixes. With DefaultOptionBuilder, the preferredName for an Option \nbecomes \"shortPrefix\" + \"shortName\". With DefaultOption, the preferredName \nremains the \"preferredName\" supplied in the constructor, when I think it \nshould become \"shortPrefix\"/\"longPrefix\" + \"preferredName\"\n\nFor example:\n\nDefaultOption optionName =\n  new DefaultOption(\n    \"-\",\n    \"--\",\n    false,\n    \"n\",\n    \"Print greeting\",\n    null,\n    null,\n    true,\n    null,\n    null,\n    'n');\n\nWhen used on the command line, it will require \"MyApplication n\" instead \nof \"MyApplication -n\".\n\nThe same created using the builder:\n\nDefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n  Option optionName =\n    oBuilder\n      .withShortName(\"n\")\n      .withDescription(\"Print standard greeting\")\n      .create();\n\nwill require \"MyApplication -n\" and not \"MyApplication n\" which would be the \nexpected behaviour.\n\n--\nVikram",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-73",
                "project": "Commons CLI",
                "title": "Use of CommandLine.getOptionValue(String opt, String defaultValue) for missing argument results in null pointer exception",
                "type": "Bug",
                "description": "The following code results in an unexpected null pointer exception\n\n*** begin DemoCliBug.java ***\nimport org.apache.commons.cli.*;\n\npublic class DemoCliBug\n{\n    public static void main(String args[])\n    {\n\tOptions opts = new Options();\n\topts.addOption(\"f\", true, \"foobar\");\n\topts.addOption(\"m\", true, \"missing\");\n\n\tString[] bug_args = new String[2];\n\n\tbug_args[0] = \"-f\";\n\tbug_args[1] = \"foo\";\n\n\ttry {\n\t    CommandLine cmd = new GnuParser().parse(opts, bug_args);\n\t    System.out.println(\"f option: \" \n\t\t\t       + cmd.getOptionValue(\"f\", \"default f\"));\n\t    //The following line results in null pointer exception\n\t    System.out.println(\"m option: \" \n\t\t\t       + cmd.getOptionValue(\"m\", \"default m\"));\n\t}\n\tcatch (ParseException exception){\n\t}\n    }\n}\n*** end DemoCliBug.java ***\nresults in this output\n*** begin output ***\nf option: foo\nException in thread \"main\" java.lang.NullPointerException\n        at org.apache.commons.cli.CommandLine.getOptionValue(CommandLine.java:146)\n        at org.apache.commons.cli.CommandLine.getOptionValue(CommandLine.java:185)\n        at DemoCliBug.main(DemoCliBug.java:21)\n*** end output ***\n\nper the javadoc for the CommandLine.getOptionValue(String) method, it should\nreturn null if the option is unset or has no argument\n\nI changed the implementation to this to fix the bug...\n    public String getOptionValue( String opt ) {\n \tOption option = (Option)options.get( opt );\n        return option == null ? null : option.getValue();\n    }\n\nIt looks like the same problem exists for\nString[] getOptionValues( String opt )\n\nSorry, I'm a CVS newbie so I'm not yet able to post the patch myself.",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CLI-72",
                "project": "Commons CLI",
                "title": "support anonymous arguments explicity",
                "type": "Bug",
                "description": "Allow the user to specify anonymous arguments.  This may lead to the elimination\nof the unprocessed arguments and thus prevent an open ended contract.",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-71",
                "project": "Commons CLI",
                "title": "[cli] A weakness of parser",
                "type": "Bug",
                "description": "I found a weakness of Jakarta Commons CLI and want to explain it with a simple\nexample: \n\nOur program provides 2 options: \n\n1.\t-a or --algo <name>: The -a option requires an argument.\n2.\t-k or --key <value>: The -k option requires an argument too.\n\na)\n\nIf you pass the following command line arguments everything will be ok:\n-a Caesar -k A\n\nAfter evaluation:\n\n\u2022\t\"Caesar\" is the parameter of the -a option and\n\u2022\t\"A\" is the parameter of the -k option.\n\nb)\n\nHowever an org.apache.commons.cli.MissingArgumentException: no argument for:k is\nthrown if you pass the following input:\n\n-a Caesar -k a\n\nThe Parser assumes that the argument \"a\" after the -k option, is the -a option\nmissing the hyphen. At the end of this description there is Java code for\nexecuting this problem.\n\nInformation:\n\nThe handling of this command line \n\n-a Caesar -k a \n\nworks in Getopt without any problem:\n\n\u2022\t\"Caesar\" is the parameter of the -a option and\n\u2022\t\"a\" of the -k option.\n\nAfter parsing a valid option Getopt always takes the next (available) command\nline argument as the option's parameter if the option requires an argument -\nmeans if you pass to the command line \n\n-k -a Caesar\n\nAfter evaluation:\n\n\u2022\t\"a\" is the parameter of the -k option\n\u2022\tthe \"Caesar\" argument is just ignored\n\nIf the option's parameter (<value>) represents an optional argument the next\nargument is not required, if it represents a valid option - means if you pass to\nthe command line \n\n-k -a Caesar\n\nAfter evaluation:\n\n\u2022\t\"Caesar\" is the parameter of the -a option\n\u2022\tk option is set without a parameter - in this case a default value makes sense.\n\nLast but not least here is the code snippet for the CLI Test:\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.commons.cli.PosixParser;\n\npublic class TestCommonsCLI {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t\n\t\tOptions options = new Options();\n\t\t\n\t\tOption algorithm = new Option(\"a\" , \"algo\", true, \"the algorithm which it to\nperform executing\");\n\t\talgorithm.setArgName(\"algorithm name\");\n\t\toptions.addOption(algorithm);\n\t\t\n\t\tOption key = new Option(\"k\" , \"key\", true, \"the key the setted algorithm uses\nto process\");\n\t\talgorithm.setArgName(\"value\");\n\t\toptions.addOption(key);\n\t\t\n\t\tCommandLineParser parser = new PosixParser();\n\t\t\n\t\t try {\n\t\t\tCommandLine line = parser.parse( options, args);\n\t\t\t\n\t\t\tif(line.hasOption('a')){\n\t\t    \tSystem.out.println(\"algo: \"+ line.getOptionValue( \"a\" ));\n\t\t    }\n\t\t\t\n\t\t\tif(line.hasOption('k')){\n\t\t    \tSystem.out.println(\"key: \" + line.getOptionValue('k'));\n\t\t    }\n\t\t\t\n\t\t\t\n\t\t} catch (ParseException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n}",
                "resolved": "2007-05-24",
                "versions": [],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-69",
                "project": "Commons CLI",
                "title": "[cli] Error parsing option arguments",
                "type": "Bug",
                "description": "I hav a tool that takes the following options: -p -attr.\nBoth takes argument. If the user wants to specify p as the argument for attr,\n-attr p, cli throws a MissingArgumentException. This is because it sees p as an\noption rather than the argument of attr.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-67",
                "project": "Commons CLI",
                "title": "[cli] Missing arguments in HelpFormatter.renderOptions(..)",
                "type": "Bug",
                "description": "The method renderOptions(....) ignores Options with no shortOpt.\n\nPossible Solution:\nreplace\n   List optList = options.helpOptions();\n   Collections.sort( optList, new StringBufferComparator() );\n\nwith\n   Collection optList = options.getOptions();",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-65",
                "project": "Commons CLI",
                "title": "[cli] Parser breaks up command line parms into single characters",
                "type": "Bug",
                "description": "The base Parser class used to pull tokens from a command line breaks up \ncommand line options longer than 1 character. For example, -file becomes -f -\ni -l -e. This can be duplicated with the Ant example shown in the user guide. \nThis is probably the cause for bug \nhttp://issues.apache.org/bugzilla/show_bug.cgi?id=31464 section 1 and 2.\n\nI have worked up a patch that fixes this problem and all of the JUnit tests \nrun correctly after this patch is applied. \n\nThere appear to be some shortcomings in the way the Parser class processes \noptions. The main problem is that it doesn't maintain a state value indicating \nwhat is being processed so option parameters can be interpreted as options. To \nfix this the code needs to be reorganized. Because of this, I can't say this \npatch will work in every case but it is an improvement.",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-64",
                "project": "Commons CLI",
                "title": "[cli][PATCH] cli2.commandline.Parser.parseAndHelp need not throw IOException",
                "type": "Bug",
                "description": "Hi all,\n\nAfter COM-2749 was resolved, org.apache.commons.cli2.commandline.Parser\nneedn't throw IOException. The attached patch also fixes a test case to no\nlonger try and catch this exception.\n\nThis is a patch to unreleased code. Please commit! :)\n\nThanks,\nJames",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-63",
                "project": "Commons CLI",
                "title": "[cli] parser confuses values with similar options",
                "type": "Bug",
                "description": "If an option -x or --xyz exists, the values \"x\" and \"xyz\" are no longer accepted\nas arguments.  Values between the ignored value and the next option are also\nignored.\n\nThe reporting email is linked.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-62",
                "project": "Commons CLI",
                "title": "Error parsing options a-la Java property option",
                "type": "Bug",
                "description": "import org.apache.commons.cli.*;\n\n\n\n\npublic class Test {\n\n\n    public static void main( String[] args ) {\n\n\n\t    try {\n\n\n\t        Options options = new Options();\n\n\n\t        options.addOption( OptionBuilder\n\n\n\t                           .hasArg()\n\n\n\t                           .withDescription( \"Define a system property\" )\n\n\n\t                           .create( 'D' ) );\n\n\n\t        CommandLineParser parser = new PosixParser();\n\n\n\t        CommandLine cl = parser.parse( options, args );\n\n\n\t        for (java.util.Iterator i = cl.iterator(); i.hasNext(); ) {\n\n\n\t            System.err.println(i.next());\n\n\n\t        }\n\n\n\t        System.err.println(cl.getArgList());\n\n\n\t    } catch (Throwable e) {\n\n\n\t        e.printStackTrace();\n\n\n\t    }\n\n\n    }\n\n\n}\n\n\n\n\nHOW TO REPRODUCE:\n\n\nCompile this example and run for example\n\n\njava -cp commons-cli-1.0-beta-2.jar:. Test -Da=b -Dc=d xxx\n\n\n\n\nOBSERVED RESULT:\n\n\n[ option: D  :: Define a system property ]\n\n\n[c=d, xxx]\n\n\n\n\nEXPECTED RESULT:\n\n\n[ option: D  :: Define a system property ]\n\n\n[ option: D  :: Define a system property ]\n\n\n[xxx]\n\n\n\n\nADDITIONAL INFO:\n\n\nThe error occured only in 1.0 version, versions 1.0-beta-2 and 1.0-beta-2-dev \nhave no such problem.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-61",
                "project": "Commons CLI",
                "title": "[cli] argument defaults prevent commandline usage.",
                "type": "Bug",
                "description": "I have found a bug in the following scenario:\n\nYou have an option which can take a single argument which in turn has a default\nvalue. You supply a value on the command line which is intended to override\nthis default however as the CommandLine already has a value for this Option,\nthis second value is not allowed and the command line cannot be parsed.\n\nI have created a patch which adds a method to WritableCommandLine and its Impl\nwhich allows you to retrieve the undefaulted values for an Option. I have then\nchanged ArgumentImpl to use this method to determine the argument count",
                "resolved": "2008-06-09",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-60",
                "project": "Commons CLI",
                "title": "[cli] HelpFormatter doesn't function correctly for options with only LongOpt",
                "type": "Bug",
                "description": "The following doesn't work (org.apache.commons.cli.HelpFormatter\n)correctly and doesn't print out the help menu of options\nthat only specify LongOpt.\n\n\nThe output is:\n [java] usage: -a | -d | --shutdown  |  -s | -h [-r <email>] [-f <flight>] [-t]\n     [java] VendMore - Email Management System\n     [java]  -t,--test       test mode - makes no permanent changes.\n     [java]     --shutdown   shutdown rpc server.\n     [java]  -a,--add        add user to email queue.\n     [java]  -d,--delete     delete user from email queue.\n     [java]  -f,--flight     flight which is the index into the email being sent\n     [java]  -h,--help       Print this usage information.\n     [java]  -r              recipient's email\n     [java]  -s,--send       send email command\n     [java]  For more information, see Steve Morin\n     [java] Java Result: 1\n\n\n\n\nit is missing the following options when printing the help display.\n\n\n\n\n   options.addOption(OptionBuilder.withDescription(\"hostname for the XmlRpc\nclient to connect to.\").withLongOpt(\"hostname\").create());\n        options.addOption(OptionBuilder.withDescription(\"port for the xmlrpc\nclient to use.\").withLongOpt(\"port\").create());\n        options.addOption(OptionBuilder.withDescription(\"additional xmlrpc\nconnection\").withLongOpt(\"urlpath\").create());\n             options.addOption(OptionBuilder.withDescription(\"add a parameter\nform name=value.\").hasArg().withLongOpt(\"params\").create());\n\n\n\n\nexample of the offending code\n\n    private CommandLineParser cmd;\n    private Options options;\n    private OptionGroup ogmain;\n    \n    public CmdLineArg() {\n        super();\n        cmd = new BasicParser();\n        options = new Options();\n        ogmain = new OptionGroup();\n        ogmain.setRequired(true);\n        localinit();\n        init();\n    }\n\n\n public CommandLine run(String[] args) {\n        \n        try {\n             options.addOption(OptionBuilder.withDescription(\"add a parameter\nform name=value.\").hasArg().withLongOpt(\"params\").create());\n             options.addOption(OptionBuilder.withDescription(\"recipient's\nemail\").hasArg().create('r'));\n             options.addOption(OptionBuilder.withDescription(\"flight which is\nthe index into the email being sent\").withLongOpt(\"flight\").hasArg().create('f'));\n             options.addOption(OptionBuilder.withDescription(\"test mode - makes\nno permanent changes.\").withLongOpt(\"test\").create('t'));\n\n        \n        \n             ogmain.addOption(OptionBuilder.withDescription(\"Print this usage\ninformation.\").withLongOpt(\"help\").create('h'));\n             ogmain.addOption(OptionBuilder.withDescription(\"send email\ncommand\").withLongOpt(\"send\").hasArg().create('s'));\n\n        ogmain.addOption(OptionBuilder.withDescription(\"add user to email\nqueue.\").withLongOpt(\"add\").create('a'));\n        ogmain.addOption(OptionBuilder.withDescription(\"delete user from email\nqueue.\").withLongOpt(\"delete\").create('d'));\n        ogmain.addOption(OptionBuilder.withDescription(\"shutdown rpc\nserver.\").withLongOpt(\"shutdown\").create());\n        \n        options.addOption(OptionBuilder.withDescription(\"hostname for the XmlRpc\nclient to connect to.\").withLongOpt(\"hostname\").create());\n        options.addOption(OptionBuilder.withDescription(\"port for the xmlrpc\nclient to use.\").withLongOpt(\"port\").create());\n        options.addOption(OptionBuilder.withDescription(\"additional xmlrpc\nconnection\").withLongOpt(\"urlpath\").create());\n\n\n            options.addOptionGroup(this.ogmain);\n            return cmd.parse(options,args);\n        } catch (ParseException e) {\n            printUsage();\n            System.exit(1);\n            return null;\n        }\n    }\n    \n    protected void printUsage(){\n        HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.printHelp(getUSAGE(),getHEADER(),options,getFOOTER());\n    }",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-59",
                "project": "Commons CLI",
                "title": "No Javadoc for HelpFormatter!",
                "type": "Bug",
                "description": "There is almost no Javadoc for the class org.apache.commons.cli.HelpFormatter.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-56",
                "project": "Commons CLI",
                "title": "[cli] clone() method doesn't fully clone contents",
                "type": "Bug",
                "description": "Broken out from #19749.\n\nI'm a little weary of fixing this in case it was done this way on purpose... if\nanyone cloning options would care to reasure me it would be appreciated.  Also\nneed to decide if cli2 Options should be Cloneable\n\nRob",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-55",
                "project": "Commons CLI",
                "title": "[cli] PatternOptionBuilder does not support required Options",
                "type": "Bug",
                "description": "It seems like no required Options can be created via the\nPatternOptionBuilder. That is for the following reason:\n\nUsually \"required\" is being specified by including an \"!\"\ninto the pattern. E.g. like this \"hc!<\" which should make\nthe option \"c\" mandatory. But you always get an\nIllegalArgumentException because the \"!\" is used to create\nan Option. Here is the main loop...\n\n  if (!isValueCode(ch))\n  {\n    if (opt != ' ')\n    {\n      options.addOption(\n         OptionBuilder.hasArg(type != null)\n                      .isRequired(required).withType(type)\n                      .create(opt));\n       required = false;\n       type = null;\n       opt = ' ';\n    }\n    opt = ch;\n  }\n  else if (ch == '!')\n  {\n    required = true;\n  }\n  else\n  {\n    type = getValueClass(ch);\n  }\n\nIf you look at the code you can see the that \"!\"\ncase is only being reached in the else clause.\nWhich in turn means if isValueCode('!') is true.\nIf you look at \"isValueCode\"\n\n  public static boolean isValueCode(char ch)\n     {\n         if ((ch != '@') && (ch != ':') && (ch != '%') && (ch != '+')\n             && (ch != '#') && (ch != '<') && (ch != '>') && (ch != '*')\n             && (ch != '/'))\n         {\n             return false;\n         }\n \n         return true;\n     }\n\nyou can see that \"isValueCode('!')\" will always return\nfalse and the else clause can never be reached.\n\nAdding the \"!\" to the \"isValueCode\" method should\ndo the trick.\n\n  public static boolean isValueCode(char ch)\n     {\n         if ((ch != '@') && (ch != ':') && (ch != '%') && (ch != '+')\n             && (ch != '#') && (ch != '<') && (ch != '>') && (ch != '*')\n             && (ch != '/') && (ch != '!'))\n         {\n             return false;\n         }\n \n         return true;\n     }\n\nCould someone please fix this?\nThanks, Torsten",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-54",
                "project": "Commons CLI",
                "title": "[Patch][CLI] OptionBuilder implemented like ToStringBuilder from commons-lang",
                "type": "Bug",
                "description": "OptionBuilder uses only static methods instead of a very common java-idiom, the\nchain of calls, that is used in many jakarta projects (see ECS or commons-lang\nwith the implementations of ToStringBuilder, HashCodeBuilder...)\n\nThis patch fixes OptionBuilder but as it breaks the current API, it might be\nbest applied on a 2.0 release.\n\nLudovic.\n\nIndex: src/java/org/apache/commons/cli/OptionBuilder.java\n===================================================================\nretrieving revision 1.16\ndiff -u -r1.16 OptionBuilder.java\n--- src/java/org/apache/commons/cli/OptionBuilder.java\t9 Oct 2003 20:57:01\n-0000\t1.16\n+++ src/java/org/apache/commons/cli/OptionBuilder.java\t11 Jan 2004 02:32:24 -0000\n@@ -73,55 +73,34 @@\n public class OptionBuilder {\n \n     /** long option */\n-    private static String longopt;\n+    private String longopt;\n \n     /** option description */\n-    private static String description;\n+    private String description;\n \n     /** argument name */\n-    private static String argName;\n+    private String argName;\n \n     /** is required? */\n-    private static boolean required;\n+    private boolean required;\n \n     /** the number of arguments */\n-    private static int numberOfArgs = Option.UNINITIALIZED;\n+    private int numberOfArgs = Option.UNINITIALIZED;\n \n     /** option type */\n-    private static Object type;\n+    private Object type;\n \n     /** option can have an optional argument value */\n-    private static boolean optionalArg;\n+    private boolean optionalArg;\n \n     /** value separator for argument value */\n-    private static char valuesep;\n-\n-    /** option builder instance */\n-    private static OptionBuilder instance = new OptionBuilder();\n-\n-    /**\n-     * private constructor to prevent instances being created\n-     */\n-    private OptionBuilder()\n-    {\n-    }\n+    private char valuesep;\n \n     /**\n-     * <p>Resets the member variables to their default values.</p>\n+     * Constructor for OptionBuilder\n      */\n-    private static void reset()\n+    public OptionBuilder()\n     {\n-        description = null;\n-        argName = \"arg\";\n-        longopt = null;\n-        type = null;\n-        required = false;\n-        numberOfArgs = Option.UNINITIALIZED;\n-\n-\n-        // PMM 9/6/02 - these were missing\n-        optionalArg = false;\n-        valuesep = (char) 0;\n     }\n \n     /**\n@@ -130,11 +109,11 @@\n      * @param longopt the long option value\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder withLongOpt(String longopt)\n+    public OptionBuilder withLongOpt(String longopt)\n     {\n-        instance.longopt = longopt;\n+        this.longopt = longopt;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -142,11 +121,11 @@\n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasArg()\n+    public OptionBuilder hasArg()\n     {\n-        instance.numberOfArgs = 1;\n+        this.numberOfArgs = 1;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -156,11 +135,11 @@\n      * @param hasArg if true then the Option has an argument value\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasArg(boolean hasArg)\n+    public OptionBuilder hasArg(boolean hasArg)\n     {\n-        instance.numberOfArgs = (hasArg == true) ? 1 : Option.UNINITIALIZED;\n+        this.numberOfArgs = (hasArg == true) ? 1 : Option.UNINITIALIZED;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -170,11 +149,11 @@\n      * @param name the name for the argument value\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder withArgName(String name)\n+    public OptionBuilder withArgName(String name)\n     {\n-        instance.argName = name;\n+        this.argName = name;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -182,11 +161,11 @@\n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder isRequired()\n+    public OptionBuilder isRequired()\n     {\n-        instance.required = true;\n+        this.required = true;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -207,11 +186,11 @@\n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder withValueSeparator(char sep)\n+    public OptionBuilder withValueSeparator(char sep)\n     {\n-        instance.valuesep = sep;\n+        this.valuesep = sep;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -230,11 +209,11 @@\n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder withValueSeparator()\n+    public OptionBuilder withValueSeparator()\n     {\n-        instance.valuesep = '=';\n+        this.valuesep = '=';\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -244,11 +223,11 @@\n      * @param required if true then the Option is required\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder isRequired(boolean required)\n+    public OptionBuilder isRequired(boolean required)\n     {\n-        instance.required = required;\n+        this.required = required;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -256,11 +235,11 @@\n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasArgs()\n+    public OptionBuilder hasArgs()\n     {\n-        instance.numberOfArgs = Option.UNLIMITED_VALUES;\n+        this.numberOfArgs = Option.UNLIMITED_VALUES;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -270,11 +249,11 @@\n      * @param num the number of args that the option can have\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasArgs(int num)\n+    public OptionBuilder hasArgs(int num)\n     {\n-        instance.numberOfArgs = num;\n+        this.numberOfArgs = num;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -282,12 +261,12 @@\n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasOptionalArg()\n+    public OptionBuilder hasOptionalArg()\n     {\n-        instance.numberOfArgs = 1;\n-        instance.optionalArg = true;\n+        this.numberOfArgs = 1;\n+        this.optionalArg = true;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -296,12 +275,12 @@\n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasOptionalArgs()\n+    public OptionBuilder hasOptionalArgs()\n     {\n-        instance.numberOfArgs = Option.UNLIMITED_VALUES;\n-        instance.optionalArg = true;\n+        this.numberOfArgs = Option.UNLIMITED_VALUES;\n+        this.optionalArg = true;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -312,12 +291,12 @@\n      * the next Option created can have.\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasOptionalArgs(int numArgs)\n+    public OptionBuilder hasOptionalArgs(int numArgs)\n     {\n-        instance.numberOfArgs = numArgs;\n-        instance.optionalArg = true;\n+        this.numberOfArgs = numArgs;\n+        this.optionalArg = true;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -327,11 +306,11 @@\n      * @param type the type of the Options argument value\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder withType(Object type)\n+    public OptionBuilder withType(Object type)\n     {\n-        instance.type = type;\n+        this.type = type;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -340,11 +319,11 @@\n      * @param description a description of the Option's purpose\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder withDescription(String description)\n+    public OptionBuilder withDescription(String description)\n     {\n-        instance.description = description;\n+        this.description = description;\n \n-        return instance;\n+        return this;\n     }\n \n     /**\n@@ -356,7 +335,7 @@\n      * @throws IllegalArgumentException if <code>opt</code> is not\n      * a valid character.  See Option.\n      */\n-    public static Option create(char opt)\n+    public Option create(char opt)\n                          throws IllegalArgumentException\n     {\n         return create(String.valueOf(opt));\n@@ -369,7 +348,7 @@\n      * @throws IllegalArgumentException if <code>longOpt</code> has\n      * not been set.  \n      */\n-    public static Option create()\n+    public Option create()\n                          throws IllegalArgumentException\n     {\n         if (longopt == null)\n@@ -390,7 +369,7 @@\n      * @throws IllegalArgumentException if <code>opt</code> is not\n      * a valid character.  See Option.\n      */\n-    public static Option create(String opt)\n+    public Option create(String opt)\n                          throws IllegalArgumentException\n     {\n         // create the option\n@@ -405,10 +384,6 @@\n         option.setType(type);\n         option.setValueSeparator(valuesep);\n         option.setArgName(argName);\n-\n-\n-        // reset the OptionBuilder properties\n-        instance.reset();\n \n         // return the Option instance\n         return option;\nIndex: src/java/org/apache/commons/cli/PatternOptionBuilder.java\n===================================================================\nretrieving revision 1.6\ndiff -u -r1.6 PatternOptionBuilder.java\n--- src/java/org/apache/commons/cli/PatternOptionBuilder.java\t9 Oct 2003\n20:57:02 -0000\t1.6\n+++ src/java/org/apache/commons/cli/PatternOptionBuilder.java\t11 Jan 2004\n02:32:25 -0000\n@@ -200,7 +200,7 @@\n                 {\n                     // we have a previous one to deal with\n                     options.addOption(\n-                            OptionBuilder.hasArg(type != null)\n+                            new OptionBuilder().hasArg(type != null)\n                                          .isRequired(required).withType(type)\n                                          .create(opt));\n                     required = false;\n@@ -224,7 +224,7 @@\n         {\n             // we have a final one to deal with\n             options.addOption(\n-                    OptionBuilder.hasArg(type != null).isRequired(required)\n+                    new OptionBuilder().hasArg(type != null).isRequired(required)\n                                  .withType(type).create(opt));\n         }\n \nIndex: src/test/org/apache/commons/cli/ApplicationTest.java\n===================================================================\nretrieving revision 1.9\ndiff -u -r1.9 ApplicationTest.java\n--- src/test/org/apache/commons/cli/ApplicationTest.java\t19 Sep 2002 22:59:44\n-0000\t1.9\n+++ src/test/org/apache/commons/cli/ApplicationTest.java\t11 Jan 2004 02:32:30 -0000\n@@ -40,7 +40,7 @@\n         options.addOption( \"a\", \"all\", false, \"do not hide entries starting\nwith .\" );\n         options.addOption( \"A\", \"almost-all\", false, \"do not list implied . and\n..\" );\n         options.addOption( \"b\", \"escape\", false, \"print octal escapes for\nnongraphic characters\" );\n-        options.addOption( OptionBuilder.withLongOpt( \"block-size\" )\n+        options.addOption( new OptionBuilder().withLongOpt( \"block-size\" )\n                                         .withDescription( \"use SIZE-byte blocks\" )\n                                         .withValueSeparator( '=' )\n                                         .hasArg()\n@@ -79,7 +79,7 @@\n         options.addOption( \"logger\", true, \"the class which is to perform the\nlogging\" );\n         options.addOption( \"listener\", true, \"add an instance of a class as a\nproject listener\" );\n         options.addOption( \"buildfile\", true, \"use given buildfile\" );\n-        options.addOption( OptionBuilder.withDescription( \"use value for given\nproperty\" )\n+        options.addOption( new OptionBuilder().withDescription( \"use value for\ngiven property\" )\n                                         .hasArgs()\n                                         .withValueSeparator()\n                                         .create( 'D' ) );\nIndex: src/test/org/apache/commons/cli/BugsTest.java\n===================================================================\nretrieving revision 1.16\ndiff -u -r1.16 BugsTest.java\n--- src/test/org/apache/commons/cli/BugsTest.java\t17 Jan 2003 20:00:14 -0000\t1.16\n+++ src/test/org/apache/commons/cli/BugsTest.java\t11 Jan 2004 02:32:30 -0000\n@@ -39,7 +39,7 @@\n \n     public void test11457() {\n         Options options = new Options();\n-        options.addOption( OptionBuilder.withLongOpt( \"verbose\" )\n+        options.addOption( new OptionBuilder().withLongOpt( \"verbose\" )\n                            .create() );\n         String[] args = new String[] { \"--verbose\" };\n \n@@ -58,10 +58,10 @@\n     public void test11458()\n     {\n         Options options = new Options();\n-        options.addOption( OptionBuilder.withValueSeparator( '=' )\n+        options.addOption( new OptionBuilder().withValueSeparator( '=' )\n                            .hasArgs()\n                            .create( 'D' ) );\n-        options.addOption( OptionBuilder.withValueSeparator( ':' )\n+        options.addOption( new OptionBuilder().withValueSeparator( ':' )\n                            .hasArgs()\n                            .create( 'p' ) );\n         String[] args = new String[] { \"-DJAVA_HOME=/opt/java\" ,\n@@ -136,9 +136,9 @@\n     {\n         // Posix \n         Options options = new Options();\n-        options.addOption( OptionBuilder.hasOptionalArg()\n+        options.addOption( new OptionBuilder().hasOptionalArg()\n                            .create( 'a' ) );\n-        options.addOption( OptionBuilder.hasArg()\n+        options.addOption( new OptionBuilder().hasArg()\n                            .create( 'b' ) );\n         String[] args = new String[] { \"-a\", \"-bvalue\" };\n \n@@ -154,9 +154,9 @@\n \n         // GNU\n         options = new Options();\n-        options.addOption( OptionBuilder.hasOptionalArg()\n+        options.addOption( new OptionBuilder().hasOptionalArg()\n                            .create( 'a' ) );\n-        options.addOption( OptionBuilder.hasArg()\n+        options.addOption( new OptionBuilder().hasArg()\n                            .create( 'b' ) );\n         args = new String[] { \"-a\", \"-b\", \"value\" };\n \n@@ -232,11 +232,11 @@\n \n     public void test13425() {\n         Options options = new Options();\n-        Option oldpass = OptionBuilder.withLongOpt( \"old-password\" )\n+        Option oldpass = new OptionBuilder().withLongOpt( \"old-password\" )\n             .withDescription( \"Use this option to specify the old password\" )\n             .hasArg()\n             .create( 'o' );\n-        Option newpass = OptionBuilder.withLongOpt( \"new-password\" )\n+        Option newpass = new OptionBuilder().withLongOpt( \"new-password\" )\n             .withDescription( \"Use this option to specify the new password\" )\n             .hasArg()\n             .create( 'n' );\n@@ -265,7 +265,7 @@\n \n     public void test13666() {\n         Options options = new Options();\n-        Option dir = OptionBuilder.withDescription( \"dir\" )\n+        Option dir = new OptionBuilder().withDescription( \"dir\" )\n                                        .hasArg()\n                                        .create( 'd' );\n         options.addOption( dir );\n@@ -345,7 +345,7 @@\n     }\n \n     public void test14786() throws Exception {\n-        Option o =\nOptionBuilder.isRequired().withDescription(\"test\").create(\"test\");\n+        Option o = new\nOptionBuilder().isRequired().withDescription(\"test\").create(\"test\");\n         Options opts = new Options();\n         opts.addOption(o);\n         opts.addOption(o);\n@@ -377,7 +377,7 @@\n     public void test15648() throws Exception {\n         CommandLineParser parser = new PosixParser();\n         final String[] args = new String[] { \"-m\", \"\\\"Two Words\\\"\" };\n-        Option m = OptionBuilder.hasArgs().create(\"m\");\n+        Option m = new OptionBuilder().hasArgs().create(\"m\");\n         Options options = new Options();\n         options.addOption( m );\n         CommandLine line = parser.parse( options, args );\nIndex: src/test/org/apache/commons/cli/OptionBuilderTest.java\n===================================================================\nretrieving revision 1.3\ndiff -u -r1.3 OptionBuilderTest.java\n--- src/test/org/apache/commons/cli/OptionBuilderTest.java\t18 Nov 2002\n08:41:26 -0000\t1.3\n+++ src/test/org/apache/commons/cli/OptionBuilderTest.java\t11 Jan 2004 02:32:34\n-0000\n@@ -21,7 +21,7 @@\n     }\n \n     public void testCompleteOption( ) {\n-        Option simple = OptionBuilder.withLongOpt( \"simple option\")\n+        Option simple = new OptionBuilder().withLongOpt( \"simple option\")\n                                      .hasArg( )\n                                      .isRequired( )\n                                      .hasArgs( )\n@@ -39,7 +39,7 @@\n     }\n \n     public void testTwoCompleteOptions( ) {\n-        Option simple = OptionBuilder.withLongOpt( \"simple option\")\n+        Option simple = new OptionBuilder().withLongOpt( \"simple option\")\n                                      .hasArg( )\n                                      .isRequired( )\n                                      .hasArgs( )\n@@ -55,7 +55,7 @@\n         assertTrue( simple.isRequired() );\n         assertTrue( simple.hasArgs() );\n \n-        simple = OptionBuilder.withLongOpt( \"dimple option\")\n+        simple = new OptionBuilder().withLongOpt( \"dimple option\")\n                               .hasArg( )\n                               .withDescription( \"this is a dimple option\" )\n                               .create( 'd' );\n@@ -70,7 +70,7 @@\n     }\n \n     public void testBaseOptionCharOpt() {\n-        Option base = OptionBuilder.withDescription( \"option description\")\n+        Option base = new OptionBuilder().withDescription( \"option description\")\n                                    .create( 'o' );\n \n         assertEquals( \"o\", base.getOpt() );\n@@ -79,7 +79,7 @@\n     }\n \n     public void testBaseOptionStringOpt() {\n-        Option base = OptionBuilder.withDescription( \"option description\")\n+        Option base = new OptionBuilder().withDescription( \"option description\")\n                                    .create( \"o\" );\n \n         assertEquals( \"o\", base.getOpt() );\n@@ -91,7 +91,7 @@\n \n         // '?'\n         try {\n-            Option opt = OptionBuilder.withDescription( \"help options\" )\n+            Option opt = new OptionBuilder().withDescription( \"help options\" )\n                                       .create( '?' );\n             assertEquals( \"?\", opt.getOpt() );\n         }\n@@ -101,7 +101,7 @@\n \n         // '@'\n         try {\n-            Option opt = OptionBuilder.withDescription( \"read from stdin\" )\n+            Option opt = new OptionBuilder().withDescription( \"read from stdin\" )\n                                       .create( '@' );\n             assertEquals( \"@\", opt.getOpt() );\n         }\n@@ -111,7 +111,7 @@\n     }\n \n     public void testOptionArgNumbers() {\n-        Option opt = OptionBuilder.withDescription( \"option description\" )\n+        Option opt = new OptionBuilder().withDescription( \"option description\" )\n                                   .hasArgs( 2 )\n                                   .create( 'o' );\n         assertEquals( 2, opt.getArgs() );\n@@ -120,7 +120,7 @@\n     public void testIllegalOptions() {\n         // bad single character option\n         try {\n-            Option opt = OptionBuilder.withDescription( \"option description\" )\n+            Option opt = new OptionBuilder().withDescription( \"option\ndescription\" )\n                                       .create( '\"' );\n             fail( \"IllegalArgumentException not caught\" );\n         }\n@@ -130,7 +130,7 @@\n \n         // bad character in option string\n         try {\n-            Option opt = OptionBuilder.create( \"opt`\" );\n+            Option opt = new OptionBuilder().create( \"opt`\" );\n             fail( \"IllegalArgumentException not caught\" );\n         }\n         catch( IllegalArgumentException exp ) {\n@@ -139,7 +139,7 @@\n \n         // valid option \n         try {\n-            Option opt = OptionBuilder.create( \"opt\" );\n+            Option opt = new OptionBuilder().create( \"opt\" );\n             // success\n         }\n         catch( IllegalArgumentException exp ) {\nIndex: src/test/org/apache/commons/cli/OptionsTest.java\n===================================================================\nretrieving revision 1.2\ndiff -u -r1.2 OptionsTest.java\n--- src/test/org/apache/commons/cli/OptionsTest.java\t9 Oct 2003 20:57:20 -0000\t1.2\n+++ src/test/org/apache/commons/cli/OptionsTest.java\t11 Jan 2004 02:32:35 -0000\n@@ -94,25 +94,25 @@\n     \n     public void testHelpOptions(){\n         \n-        Option longOnly1 = OptionBuilder\n+        Option longOnly1 = new OptionBuilder()\n             .withLongOpt(\"long-only1\")\n             .create();\n         \n-        Option longOnly2 = OptionBuilder\n+        Option longOnly2 = new OptionBuilder()\n             .withLongOpt(\"long-only2\")\n             .create();\n                 \n-        Option shortOnly1 = OptionBuilder\n+        Option shortOnly1 = new OptionBuilder()\n             .create(\"1\");\n                 \n-        Option shortOnly2 = OptionBuilder\n+        Option shortOnly2 = new OptionBuilder()\n             .create(\"2\");\n                 \n-        Option bothA = OptionBuilder\n+        Option bothA = new OptionBuilder()\n             .withLongOpt(\"bothA\")\n             .create(\"a\");\n                 \n-        Option bothB = OptionBuilder\n+        Option bothB = new OptionBuilder()\n             .withLongOpt(\"bothB\")\n             .create(\"b\");\n         \nIndex: src/test/org/apache/commons/cli/ParseRequiredTest.java\n===================================================================\nretrieving revision 1.5\ndiff -u -r1.5 ParseRequiredTest.java\n--- src/test/org/apache/commons/cli/ParseRequiredTest.java\t19 Sep 2002\n22:59:44 -0000\t1.5\n+++ src/test/org/apache/commons/cli/ParseRequiredTest.java\t11 Jan 2004 02:32:36\n-0000\n@@ -40,7 +40,7 @@\n                        \"enable-a\",\n                        false,\n                        \"turn [a] on or off\")\n-            .addOption( OptionBuilder.withLongOpt( \"bfile\" )\n+            .addOption( new OptionBuilder().withLongOpt( \"bfile\" )\n                                      .hasArg()\n                                      .isRequired()\n                                      .withDescription( \"set the value of [b]\" )\nIndex: src/test/org/apache/commons/cli/PatternOptionBuilderTest.java\n===================================================================\nretrieving revision 1.6\ndiff -u -r1.6 PatternOptionBuilderTest.java\n--- src/test/org/apache/commons/cli/PatternOptionBuilderTest.java\t19 Sep 2002\n22:59:44 -0000\t1.6\n+++ src/test/org/apache/commons/cli/PatternOptionBuilderTest.java\t11 Jan 2004\n02:32:40 -0000\n@@ -12,9 +12,6 @@\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import java.io.StringWriter;\n-import java.io.PrintWriter;\n-\n /** \n  * Test case for the PatternOptionBuilder class \n  *\nIndex: src/test/org/apache/commons/cli/TestHelpFormatter.java\n===================================================================\nretrieving revision 1.6\ndiff -u -r1.6 TestHelpFormatter.java\n--- src/test/org/apache/commons/cli/TestHelpFormatter.java\t9 Dec 2002 23:47:26\n-0000\t1.6\n+++ src/test/org/apache/commons/cli/TestHelpFormatter.java\t11 Jan 2004 02:32:41\n-0000\n@@ -14,7 +14,6 @@\n \n import java.io.ByteArrayOutputStream;\n import java.io.PrintWriter;\n-import java.io.StringWriter;\n \n /** \n  * Test case for the HelpFormatter class \nIndex: src/test/org/apache/commons/cli/ValueTest.java\n===================================================================\nretrieving revision 1.7\ndiff -u -r1.7 ValueTest.java\n--- src/test/org/apache/commons/cli/ValueTest.java\t27 Nov 2002 23:24:38 -0000\t1.7\n+++ src/test/org/apache/commons/cli/ValueTest.java\t11 Jan 2004 02:32:45 -0000\n@@ -53,28 +53,28 @@\n                        true,\n                        \"set -d\");\n \n-        opts.addOption( OptionBuilder.hasOptionalArg()\n+        opts.addOption( new OptionBuilder().hasOptionalArg()\n                         .create( 'e') );\n \n-        opts.addOption( OptionBuilder.hasOptionalArg()\n+        opts.addOption( new OptionBuilder().hasOptionalArg()\n                         .withLongOpt( \"fish\" )\n                         .create( ) );\n \n-        opts.addOption( OptionBuilder.hasOptionalArgs()\n+        opts.addOption( new OptionBuilder().hasOptionalArgs()\n                         .withLongOpt( \"gravy\" )\n                         .create( ) );\n \n-        opts.addOption( OptionBuilder.hasOptionalArgs( 2 )\n+        opts.addOption( new OptionBuilder().hasOptionalArgs( 2 )\n                         .withLongOpt( \"hide\" )\n                         .create( ) );\n \n-        opts.addOption( OptionBuilder.hasOptionalArgs( 2 )\n+        opts.addOption( new OptionBuilder().hasOptionalArgs( 2 )\n                         .create( 'i' ) );\n \n-        opts.addOption( OptionBuilder.hasOptionalArgs( )\n+        opts.addOption( new OptionBuilder().hasOptionalArgs( )\n                         .create( 'j' ) );\n \n-        opts.addOption( OptionBuilder.hasArgs( ).withValueSeparator( ',' )\n+        opts.addOption( new OptionBuilder().hasArgs( ).withValueSeparator( ',' )\n                         .create( 'k' ) );\n \n         String[] args = new String[] { \"-a\",\nIndex: src/test/org/apache/commons/cli/ValuesTest.java\n===================================================================\nretrieving revision 1.9\ndiff -u -r1.9 ValuesTest.java\n--- src/test/org/apache/commons/cli/ValuesTest.java\t25 Nov 2002 23:43:41 -0000\t1.9\n+++ src/test/org/apache/commons/cli/ValuesTest.java\t11 Jan 2004 02:32:47 -0000\n@@ -53,7 +53,7 @@\n                        true,\n                        \"set -d\");\n         \n-        opts.addOption( OptionBuilder.withLongOpt( \"e\" )\n+        opts.addOption( new OptionBuilder().withLongOpt( \"e\" )\n                                      .hasArgs()\n                                      .withDescription( \"set -e \")\n                                      .create( 'e' ) );\n@@ -63,33 +63,33 @@\n                        false,\n                        \"jk\");\n         \n-        opts.addOption( OptionBuilder.withLongOpt( \"g\" )\n+        opts.addOption( new OptionBuilder().withLongOpt( \"g\" )\n                         .hasArgs( 2 )\n                         .withDescription( \"set -g\")\n                         .create( 'g' ) );\n \n-        opts.addOption( OptionBuilder.withLongOpt( \"h\" )\n+        opts.addOption( new OptionBuilder().withLongOpt( \"h\" )\n                         .hasArgs( 2 )\n                         .withDescription( \"set -h\")\n                         .create( 'h' ) );\n \n-        opts.addOption( OptionBuilder.withLongOpt( \"i\" )\n+        opts.addOption( new OptionBuilder().withLongOpt( \"i\" )\n                         .withDescription( \"set -i\")\n                         .create( 'i' ) );\n \n-        opts.addOption( OptionBuilder.withLongOpt( \"j\" )\n+        opts.addOption( new OptionBuilder().withLongOpt( \"j\" )\n                         .hasArgs( )\n                         .withDescription( \"set -j\")\n                         .withValueSeparator( '=' )\n                         .create( 'j' ) );\n \n-        opts.addOption( OptionBuilder.withLongOpt( \"k\" )\n+        opts.addOption( new OptionBuilder().withLongOpt( \"k\" )\n                         .hasArgs( )\n                         .withDescription( \"set -k\")\n                         .withValueSeparator( '=' )\n                         .create( 'k' ) );\n \n-        _option = OptionBuilder.withLongOpt( \"m\" )\n+        _option = new OptionBuilder().withLongOpt( \"m\" )\n                         .hasArgs( )\n                         .withDescription( \"set -m\")\n                         .withValueSeparator( )\nIndex: xdocs/usage.xml\n===================================================================\nretrieving revision 1.4\ndiff -u -r1.4 usage.xml\n--- xdocs/usage.xml\t13 Nov 2002 00:04:13 -0000\t1.4\n+++ xdocs/usage.xml\t11 Jan 2004 02:32:53 -0000\n@@ -146,29 +146,29 @@\n         <p> \n           The argument options are created using the OptionBuilder.\n         </p>\n-        <source>Option logfile   = OptionBuilder.withArgName( \"file\" )\n+        <source>Option logfile   = new OptionBuilder().withArgName( \"file\" )\n                                 .hasArg()\n                                 .withDescription(  \"use given file for log\" )\n                                 .create( \"file\" );\n \n-Option logger    = OptionBuilder.withArgName( \"classname\" )\n+Option logger    = new OptionBuilder().withArgName( \"classname\" )\n                                 .hasArg()\n                                 .withDescription( \"the class which it to perform \"\n                                                   + \"logging\" )\n                                 .create( \"logger\" );\n \n-Option listener  = OptionBuilder.withArgName( \"classname\" )\n+Option listener  = new OptionBuilder().withArgName( \"classname\" )\n                                 .hasArg()\n                                 .withDescription( \"add an instance of class as \"\n                                                   + \"a project listener\" )\n                                 .create( \"listener\"); \n \n-Option buildfile = OptionBuilder.withArgName( \"file\" )\n+Option buildfile = new OptionBuilder().withArgName( \"file\" )\n                                 .hasArg()\n                                 .withDescription(  \"use given buildfile\" )\n                                 .create( \"buildfile\");\n \n-Option find      = OptionBuilder.withArgName( \"file\" )\n+Option find      = new OptionBuilder().withArgName( \"file\" )\n                                 .hasArg()\n                                 .withDescription( \"search for buildfile towards\nthe \"\n                                   + \"root of the filesystem and use it\" )\n@@ -179,7 +179,7 @@\n           The last option to create is the Java property and it too is created\n           using the OptionBuilder.\n         </p>\n-        <source>Option property  = OptionBuilder.withArgName( \"property=value\" )\n+        <source>Option property  = new OptionBuilder().withArgName(\n\"property=value\" )\n                                 .hasArg()\n                                 .withValueSeparator()\n                                 .withDescription( \"use value for given property\" )\n@@ -318,7 +318,7 @@\n options.addOption( \"A\", \"almost-all\", false, \"do not list implied . and ..\" );\n options.addOption( \"b\", \"escape\", false, \"print octal escapes for nongraphic \"\n                                          + \"characters\" );\n-options.addOption( OptionBuilder.withLongOpt( \"block-size\" )\n+options.addOption( new OptionBuilder().withLongOpt( \"block-size\" )\n                                 .withDescription( \"use SIZE-byte blocks\" )\n                                 .withValueSeparator( '=' )\n                                 .hasArg()",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-53",
                "project": "Commons CLI",
                "title": "Parsing error?",
                "type": "Bug",
                "description": "Hi\n\nIf one accidentally confuses the long and short argument name styles, then the value of the argument is \nincorrect. This is mad clear by an example:\n\nIf I have a program that I call as follows:\n\nmy_prog --file my_file.txt\n\nor\n\nmy_prog -f my_file.txt\n\nbut I make a typo and write\n\nmy_prog -file my_file.txt\n\nthen getOptionValue('f') will return \"ile\" (i.e. it thinks the remainder of the argument's name is the \nargument). \"my_file.txt\" will be ignored.\n\nThis is clearly an error that the user has made, but I think that CLI should be able to detect such an \nerror and throw an appropriate exception.",
                "resolved": "2010-06-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-52",
                "project": "Commons CLI",
                "title": "Add support for stuff like [target [target2 [target3] ...]]",
                "type": "Bug",
                "description": "I do not know the correct term for the feature, but something like: \"anonymous options\" that is \nalways listed at the end of the commandline.\n\nCurrently one access these options via \ncmdline.getArgList(), but e.g. the\nHelpFormatter does not include these in its usage print \nand they are not verified by the parser. e.g. man command line is required to have at least one page \nargument, but that is not checkked by the parser - that should be possible.",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-51",
                "project": "Commons CLI",
                "title": "[cli] Parameter value \"-something\" misinterpreted as a parameter",
                "type": "Bug",
                "description": "If a parameter value is passed that contains a hyphen as the (delimited) first \ncharacter, CLI parses this a parameter. For example using the call\njava myclass -t \"-something\"\nResults in the parser creating the invalid parameter -o (noting that it is \nskipping the 's')\n\nMy code is using the Posix parser as follows\nOptions options = buildCommandLineOptions();\nCommandLineParser parser = new PosixParser();\nCommandLine commandLine = null;\ntry {\n\t\t\t\n\tcommandLine = parser.parse(options, args);\n}\ncatch (ParseException e) {\n\t\t\t\n\tSystem.out.println(\"Invalid parameters. \" + e.getMessage() + NEW_LINE);\n\tSystem.exit(EXIT_CODE_ERROR);\n}\n\nThis has been tested against the nightly build dated 20050503.",
                "resolved": "2007-05-22",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-50",
                "project": "Commons CLI",
                "title": "[cli] TestHelpFormatter.testAutomaticUsage unit test failure",
                "type": "Bug",
                "description": "I am seing the following error:\n\njunit.framework.ComparisonFailure: simple auto usage expected:<...b] [-a...> \nbut was:<...a] [-b...>\n\tat junit.framework.Assert.assertEquals(Assert.java:81)\n\tat org.apache.commons.cli.TestHelpFormatter.testAutomaticUsage\n(TestHelpFormatter.java:168)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke\n(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke\n(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests\n(RemoteTestRunner.java:392)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run\n(RemoteTestRunner.java:276)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main\n(RemoteTestRunner.java:167)\n\nSince HashMaps are used in the Options class the order or Option instances \ncannot be guaranteed.\n\nFYI, I am running the tests from Eclipse 2.1 on top of Java 1.4.1_02. Will the \ncurrent pending \"v2\" changes from John K will solve this?",
                "resolved": "2007-03-15",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-49",
                "project": "Commons CLI",
                "title": "[cli] MissingArgumentException is thrown",
                "type": "Bug",
                "description": "For the options: -22 p -23 -22\nfor the option -22, I'd like to get the value p and for the option -23 , I \nwant to get the value -22.\nWhen I run the program, the exception is thrown.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-48",
                "project": "Commons CLI",
                "title": "HelpFormatter is only able to print last option that has a longOpt and no shortOpt.",
                "type": "Bug",
                "description": "When having more that one option that only has a longOpt and no shortOpt, only\nthe last option of these will be printed by the HelpFormatter.\n\nin Options.java this should fix the problem:\n\n212c212,214\n<         return new ArrayList( shortOpts.values() );\n---\n>         Set tmpSet = new HashSet(longOpts.values());\n>         tmpSet.addAll(shortOpts.values());\n>         return new ArrayList( tmpSet );",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-47",
                "project": "Commons CLI",
                "title": "[cli] CLI does not support long parameter names on command-line.",
                "type": "Bug",
                "description": "The documentation of CLI says that CLI supports short (single character) and \nlong parameter names (string).  It even gives as example the ANT java \napplication.  However, after doing several tests and reviewing the JavaDoc \nthoroughly, I am left to conclude that the assumption is false.  I checked the \nANT application source code to find out that ANT DOES NOT USE CLI as command-\nline parser.\n\nThe code for CLI needs to be reviewed and updated to support long parameter \nnames on the command-line.  I would also suggest to use an XML approach to \ndeclare the various command-line parameters and formats.  A more declarative \napproach would certainly makes things easier.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-46",
                "project": "Commons CLI",
                "title": "java.lang.StringIndexOutOfBoundsException",
                "type": "Bug",
                "description": "java.lang.StringIndexOutOfBoundsException: String index out of range: -1\n\tat java.lang.String.charAt(Unknown Source)\n\tat org.apache.commons.cli.HelpFormatter.rtrim(HelpFormatter.java:505)\n\tat org.apache.commons.cli.HelpFormatter.renderWrappedText(HelpFormatter.java:416)\n\tat org.apache.commons.cli.HelpFormatter.printWrapped(HelpFormatter.java:324)\n\tat org.apache.commons.cli.HelpFormatter.printWrapped(HelpFormatter.java:318)\n\tat org.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:212)",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-45",
                "project": "Commons CLI",
                "title": "[CLI][PATCH] Documentation errors",
                "type": "Bug",
                "description": "I've been learning how to use commons-cli and found a few errors in the\ndocumentation. There are some links go to the wrong place, some spelling\nmistakes and more importantly some errors in the example code. I'll be attaching\npatches shortly.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-44",
                "project": "Commons CLI",
                "title": "[cli] Document enhancement",
                "type": "Bug",
                "description": "On Usage Scenarios page http://jakarta.apache.org/commons/cli/usage.html\n\nin the \"Argument Options\" of the ant section,\n\nOption logfile   = OptionBuilder.withArgName( \"file\" )\n.......\n.create( \"file\" );  should be .create(\"logfile\")\n\nOption find      = OptionBuilder.withArgName( \"file\" )\n.......\n.create( \"file\" );  should be .create(\"find\")",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-42",
                "project": "Commons CLI",
                "title": "[PATCH][CLI] Remove dependency on commons-logging",
                "type": "Bug",
                "description": "Just a reminder:\n\nhttp://www.mail-archive.com/commons-dev@jakarta.apache.org/msg20453.html",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-41",
                "project": "Commons CLI",
                "title": "HelpFormatter shouldn't throw IOException",
                "type": "Bug",
                "description": "Hi there,\n\nAttached is a patch which implements the changes discussed on commons-dev:\n\nhttp://tinyurl.com/85334 (link to the archives)\n\nEssentially, HelpFormatter need not throw IOExceptions due to its use of\nPrintWriter. It also updates regression tests so that they don't fail to test\nthe protected pad() method (which now accepts a PrintWriter rather than a Writer).\n\nThank you.",
                "resolved": "2010-06-15",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-40",
                "project": "Commons CLI",
                "title": "DateValidatorTest & FileValidatorTest problems",
                "type": "Bug",
                "description": "The DateValidatorTest always fails with validation errors. It looks like the \ntest itself might be invalid but since I don't know the history of the code I \ndon't know which one is right.\n\nThe FileValidatorTest tests might sometimes fail if executed for the very first \ntime on Windows. There is a missing .waitFor() call to ensure the process \nfinishes before the test is executed.",
                "resolved": "2006-06-08",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-39",
                "project": "Commons CLI",
                "title": "MissingArgumentException not being caught.",
                "type": "Bug",
                "description": "Reported on behalf of Pete Maddocks.\n\nWe ran across a bug in the case where a missing required argument for an\noption was only caught if the option was at the end of command line.\n\nSo for the command:\n-----------------\nSYNOPSIS\nndmp [ options ]\n-o, --old-password oldPassword\nUse this option to specify the old password. \n\n-n, --new-password newPassword\nUse this option to specify the new password\n-----------------\n1. If the user types:\n   ndmp -o oldpassword -n \n   Then the Parser class correctly throws a MissingArgumentException.\n\n2. However, if the user types:\n   ndmp -o -n newpassword\n   Then the Parser class does not throw the Missing ArgumentException.",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CLI-38",
                "project": "Commons CLI",
                "title": "[cli] HelpFormatter doesn't function correctly for options with only LongOpt",
                "type": "Bug",
                "description": "The following doesn't work (org.apache.commons.cli.HelpFormatter\n)correctly and doesn't print out the help menu of options\nthat only specify LongOpt.\n\n\nThe output is:\n [java] usage: -a | -d | --shutdown  |  -s | -h [-r <email>] [-f <flight>] [-t]\n     [java] VendMore - Email Management System\n     [java]  -t,--test       test mode - makes no permanent changes.\n     [java]     --shutdown   shutdown rpc server.\n     [java]  -a,--add        add user to email queue.\n     [java]  -d,--delete     delete user from email queue.\n     [java]  -f,--flight     flight which is the index into the email being sent\n     [java]  -h,--help       Print this usage information.\n     [java]  -r              recipient's email\n     [java]  -s,--send       send email command\n     [java]  For more information, see Steve Morin\n     [java] Java Result: 1\n\n\n\n\nit is missing the following options when printing the help display.\n\n\n\n\n   options.addOption(OptionBuilder.withDescription(\"hostname for the XmlRpc\nclient to connect to.\").withLongOpt(\"hostname\").create());\n        options.addOption(OptionBuilder.withDescription(\"port for the xmlrpc\nclient to use.\").withLongOpt(\"port\").create());\n        options.addOption(OptionBuilder.withDescription(\"additional xmlrpc\nconnection\").withLongOpt(\"urlpath\").create());\n             options.addOption(OptionBuilder.withDescription(\"add a parameter\nform name=value.\").hasArg().withLongOpt(\"params\").create());\n\n\n\n\nexample of the offending code\n\n    private CommandLineParser cmd;\n    private Options options;\n    private OptionGroup ogmain;\n    \n    public CmdLineArg() {\n        super();\n        cmd = new BasicParser();\n        options = new Options();\n        ogmain = new OptionGroup();\n        ogmain.setRequired(true);\n        localinit();\n        init();\n    }\n\n\n public CommandLine run(String[] args) {\n        \n        try {\n             options.addOption(OptionBuilder.withDescription(\"add a parameter\nform name=value.\").hasArg().withLongOpt(\"params\").create());\n             options.addOption(OptionBuilder.withDescription(\"recipient's\nemail\").hasArg().create('r'));\n             options.addOption(OptionBuilder.withDescription(\"flight which is\nthe index into the email being sent\").withLongOpt(\"flight\").hasArg().create('f'));\n             options.addOption(OptionBuilder.withDescription(\"test mode - makes\nno permanent changes.\").withLongOpt(\"test\").create('t'));\n\n        \n        \n             ogmain.addOption(OptionBuilder.withDescription(\"Print this usage\ninformation.\").withLongOpt(\"help\").create('h'));\n             ogmain.addOption(OptionBuilder.withDescription(\"send email\ncommand\").withLongOpt(\"send\").hasArg().create('s'));\n\n        ogmain.addOption(OptionBuilder.withDescription(\"add user to email\nqueue.\").withLongOpt(\"add\").create('a'));\n        ogmain.addOption(OptionBuilder.withDescription(\"delete user from email\nqueue.\").withLongOpt(\"delete\").create('d'));\n        ogmain.addOption(OptionBuilder.withDescription(\"shutdown rpc\nserver.\").withLongOpt(\"shutdown\").create());\n        \n        options.addOption(OptionBuilder.withDescription(\"hostname for the XmlRpc\nclient to connect to.\").withLongOpt(\"hostname\").create());\n        options.addOption(OptionBuilder.withDescription(\"port for the xmlrpc\nclient to use.\").withLongOpt(\"port\").create());\n        options.addOption(OptionBuilder.withDescription(\"additional xmlrpc\nconnection\").withLongOpt(\"urlpath\").create());\n\n\n            options.addOptionGroup(this.ogmain);\n            return cmd.parse(options,args);\n        } catch (ParseException e) {\n            printUsage();\n            System.exit(1);\n            return null;\n        }\n    }\n    \n    protected void printUsage(){\n        HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.printHelp(getUSAGE(),getHEADER(),options,getFOOTER());\n    }",
                "resolved": "2007-05-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-37",
                "project": "Commons CLI",
                "title": "HelpFormatter does not wrap lines correctly after the second line",
                "type": "Bug",
                "description": "The HelpFormatter does not wrap the option lines correctly because the logic in renderWrappedText seems to be doubled up. on one side, padding is inserted of length nextLineTabStop for every line after the first, but then in findWrapPos this nextLineTabStop is ADDED to the width, resulting in lines rendered not of width, but nextLineTabStop + width.\n\nthe following patch fixes this:\n\n{noformat}\n--- old/HelpFormatter.java  Wed Mar  5 18:02:18 2003\n+++ new/HelpFormatter.java Wed Mar  5 17:59:47 2003\n@@ -802,7 +802,7 @@\n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+            pos = findWrapPos(text, width, 0);\n\n             if (pos == -1)\n             {\n{noformat}\n\nhowever, this reduces the usage of findWrapPos to always using the third argument = 0 which makes most of its logic obsolete. it could be rewritten to be MUCH shorter. but maybe i'm just missing something.\n\nthe output is fully satisfactory now.",
                "resolved": "2008-07-25",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CLI-36",
                "project": "Commons CLI",
                "title": "Option.hasArgName() has a bug",
                "type": "Bug",
                "description": "I noticed a bug.   \nNullPointerException is occured, with helpFormatter.printHelp()  \n  \nThis is a patch. \n  \n--- Option.java.orig    2002-10-18 18:27:53.000000000 +0900  \n+++ Option.java 2002-10-19 16:48:35.000000000 +0900  \n@@ -395,7 +395,7 @@  \n       * set.  \n       */  \n      public boolean hasArgName() {  \n-         return (this.argName != null || this.argName.length() > 0 );  \n+         return (this.argName != null && this.argName.length() > 0 );  \n      }  \n   \n      /**   \n \nOr just \n           return (this.argName != null); \n??",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CLI-35",
                "project": "Commons CLI",
                "title": "HelpFormatter doesn't sort options properly",
                "type": "Bug",
                "description": "HelpFormatter is using an inner class Comparator implementation to sort Option \nobjects, however it seems to be a bit confused about what types of object it is \nsorting. The inner class is called StringBufferComparator, although it's \nactually sorting Option objects. Further, it simply compares the object's \ntoString() values rather than using the getKey() method which would perform the \nsort that the comments seem to indicate is desired. The sort that is actually \nperformed doesn't appear to modify the ordering of the list at all.",
                "resolved": "2007-03-15",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-34",
                "project": "Commons CLI",
                "title": "Problem in printUsage for OptionGroup",
                "type": "Bug",
                "description": "The printUsage method, when used with an OptionGroup in the Options, will print \nevery option in that group past the first more than once (once as a group \noption, and once as a non-group option).  This is due to a bug in the logic of \nprintUsage, at line 267.  Alteration required:\n\n\n\n\n// if the Option is not part of an OptionGroup\n\n\nelse {\n\n\n\n\nchange to:\n\n\n\n\n// if the Option is not part of an OptionGroup\n\n\nelse if (group == null) {\n\n\n\n\n\n\nI've built a unit test for this:\n\n\n\n\n\tpublic void testMultiOptionPrintUsage() throws Exception\n\n\n\t{\n\n\n\t\tString firstOption = \"FirstOption\";\n\n\n\t\tString secondOption = \"SecondOption\";\n\n\n\n\n\t\tOptions options = new Options();\n\n\n\t\tOptionGroup optGroup = new OptionGroup();\n\n\n\t\toptGroup.addOption(OptionBuilder.create(firstOption));\n\n\n\t\toptGroup.addOption(OptionBuilder.create(secondOption));\n\n\n\t\toptions.addOptionGroup(optGroup);\n\n\n\t\t\n\n\n\t\tByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n\n\n\t\tHelpFormatter help = new HelpFormatter();\n\n\n\t\thelp.printUsage(new PrintWriter(byteStream, true), 80, \"Test\", options);\n\n\n\t\t\n\n\n\t\tString usageString = byteStream.toString();\n\n\n\t\tassertTrue(\"Should not find multiple copies of \"+firstOption, \nusageString.indexOf(firstOption, \nusageString.indexOf(firstOption)+firstOption.length()) == -1);\n\n\n\t\tassertTrue(\"Should not find multiple copies of \"+secondOption, \nusageString.indexOf(secondOption, \nusageString.indexOf(secondOption)+secondOption.length()) == -1);\n\n\n\t}",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-33",
                "project": "Commons CLI",
                "title": "stopAtNonOption not working for GnuParser",
                "type": "Bug",
                "description": "Submitted by Parag Thakur (parag at veritas.com):\n\nHere are the arguments i expect:\n\ncmd -exec -exec_opt1 -exec_opt2\ncmd -rep -rep_opt1 -rep_opt2\n\nThus, depending on the first argument (-exec or -rep), i would like to parse\nthe remaining arguments. So, here is the code snippet that i have:\n\n    // create the main options object which will handle the first parameter\n    Options mainOptions = new Options();\n    // There can be 2 main exclusive options:  -exec|-rep\n\n    // Therefore, place them in an option group\n\n    OptionGroup grp = new OptionGroup();\n\n    grp.addOption(new Option(\"exec\",false,\"description for this option\"));\n\n    grp.addOption(new Option(\"rep\",false,\"description for this option\"));\n\n    mainOptions.addOptionGroup(grp);\n\n    // for the exec option, there are 2 options...\n    execOptions = new Options();\n    execOptions.addOption(\"exec_opt1\",false,\" desc\");\n    execOptions.addOption(\"exec_opt2\",false,\" desc\");\n\n    // similarly, for rep there are 2 options...\n    repOptions = new Options();\n    repOptions.addOption(\"rep_opt1\",\"false\",\"desc\");\n    repOptions.addOption(\"rep_opt2\",\"false\",\"desc\");\n\n    // create the parser\n    CommandLineParser parser =\nCommandLineParserFactory.newParser(\"org.apache.commons.cli.GnuParser\");\n\n    // finally, parse the arguments:\n\n    // first parse the main options to see what the user has specified\n    // We set stopAtNonOption to true so it does not touch the remaining\n    // options\n    CommandLine cmd = parser.parse(mainOptions,argv,true);\n    // get the remaining options...\n    argv = cmd.getArgs();\n\n    if(cmd.hasOption(\"exec\")){\n        cmd = parser.parse(execOptions,argv,false);\n        // process the exec_op1 and exec_opt2...\n    }\n    else if(cmd.hasOption(\"rep\")){\n        cmd = parser.parse(repOptions,argv,false);\n        // process the rep_op1 and rep_opt2...\n    }\n    else {\n        printUsage();\n    }",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CLI-32",
                "project": "Commons CLI",
                "title": "[cli] ant test needs resources copied.",
                "type": "Bug",
                "description": "When running \"ant test\" org.apache.commons.cli2.resource.ResourceHelperTest was\nfailing as it needs a .properties file copying from src/test to\ntarget/test-classes/\n\nI have created a patch to build.xml (attached) which has a <copy> which copies\n.properties files for tests in much the same way as the existing one for\nsrc/java",
                "resolved": "2006-06-07",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-31",
                "project": "Commons CLI",
                "title": "readme lists deprecate maven goal and old maven URL",
                "type": "Bug",
                "description": "I have created a patch that updates the maven URL and changes the maven goal to\nthe undeprecated equivalent.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-30",
                "project": "Commons CLI",
                "title": "[cli] Really strange parsing behaviour",
                "type": "Bug",
                "description": "I'm just wondering, who came to glorious idea of storing parsed\noption values on option object itself, while presence of those\noptions is stored on command line? \n\nMy scenario: I have static class defining options I would like \nin several related command line applications.  \n\nSometimes I call those applications from \"wrapper\" - more than one\nin a live of JVM, and then I fake differrent parameters. \n\nBut cool feature of appending option values to array list inside option \nleads to very unexpected results...",
                "resolved": "2006-07-10",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-29",
                "project": "Commons CLI",
                "title": "Options should not be able to be added more than once",
                "type": "Bug",
                "description": "One should not be able to add the same Option (by unique ID) to the Options\nobject multiple times. Specifically, this causes a problem with required options.\n\nI performed the following set of steps, which resulted in the behavior that the\noption I specified was not marked as set in the Parser.requiredOptions List:\n\nOption o = OptionBuilder.isRequired().withDescription(\"test\").create(\"test\");\nOptions opts = new Options();\nopts.addOption(o);\nopts.addOption(o);\n\nNow, if I parse a command line like this:\n\n{program} -test\n\nI get an MissingArgumentException thrown from Parser.checkRequiredOptions that\nthe option was not found. This is because the option has been added to\nrequiredOptions twice.\n\nI believe that one should not be able to add the same option twice (or this\nbehavior should be ... er .... optional).",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-28",
                "project": "Commons CLI",
                "title": "[CLI] Infinite Loop in Command-Line processing",
                "type": "Bug",
                "description": "In some cases, CLI-2 hangs in an infinite loop. I've created the following Group:\n\n-- snip --\nOption inputFormatOption = optionBuilder.withLongName(\"input-format\")\n        .create();\nArgument argument = argumentBuilder.withName(\"file\")\n        .create();\nGroup children = groupBuilder.withName(\"options\")\n        .withOption(inputFormatOption)\n        .create();\nCommand command = commandBuilder.withName(\"convert\")\n        .withChildren(children)\n        .withArgument(argument)\n        .create();\nGroup root = groupBuilder.withName(\"commands\")\n        .withOption(createConvertCommand())\n        .create();\n-- snip --\n\nWhen I use the group:\n--snip--\nParser parser = new Parser();\nparser.setGroup(root);\nparser.parse(args);\n-- snip\n\nand use the following command line:\nconvert test.txt --input-format a\n\nthe parser hangs in an infinite loop.",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-27",
                "project": "Commons CLI",
                "title": "[cli] options group cannot have long options",
                "type": "Bug",
                "description": "if i create an option witch just a long name, it won't be parsed (will create an\nerror if used) since the OptionGroup class only maintains a hash by option.getOpt().\n\nthis goes throughout every piece of the code: options are always assumed to have\na short name, which is not true for applications with many cli options.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-26",
                "project": "Commons CLI",
                "title": "[cli] Only long options without short option seems to be noticed",
                "type": "Bug",
                "description": "I've got the following code. The only long option that seems to be noticed after parsing (PosixParser) is \nthe one (kOptionConfigFile) that does not have a short option. However, long options without short \noptions are ignored by help (except the last one. See COM-690).\n\n\t\tOption help = new Option(\"h\", kOptionHelp, false, \"print this message\");\n\t\tOption version = new Option(\"v\", kOptionVersion, false, \"print version information\");\n\t\tOption newRun = new Option(\"n\", kOptionNew, false, \"Create NLT cache entries only for new \nitems\");\n\t\tOption trackerRun = new Option(\"t\", kOptionTracker, false, \"Create NLT cache entries only \nfor tracker items\");\n\t\t\n\t\tOption timeLimit = OptionBuilder.withLongOpt(kOptionTimeLimit)\n\t\t\t\t\t\t\t\t\t\t.hasArg()\n\t\t\t\t\t\t\t\t\t\t.withValueSeparator()\n\t\t\t\t\t\t\t\t\t\t.withDescription(\"Set time limit for execution, in \nmintues\")\n\t\t\t\t\t\t\t\t\t\t.create(\"l\");\n\t\t\n\t\tOption age = OptionBuilder.withLongOpt(kOptionAge)\n\t\t\t\t\t\t\t\t\t\t.hasArg()\n\t\t\t\t\t\t\t\t\t\t.withValueSeparator()\n\t\t\t\t\t\t\t\t\t\t.withDescription(\"Age (in days) of cache item \nbefore being recomputed\")\n\t\t\t\t\t\t\t\t\t\t.create(\"a\");\n\t\t\n\t\tOption server = OptionBuilder.withLongOpt(kOptionNLTServer)\n\t\t\t\t\t\t\t\t\t\t.hasArg()\n\t\t\t\t\t\t\t\t\t\t.withValueSeparator()\n\t\t\t\t\t\t\t\t\t\t.withDescription(\"The NLT server address\")\n\t\t\t\t\t\t\t\t\t\t.create(\"s\");\n\t\t\n\t\tOption numResults = OptionBuilder.withLongOpt(kOptionNumResults)\n\t\t\t\t\t\t\t\t\t\t.hasArg()\n\t\t\t\t\t\t\t\t\t\t.withValueSeparator()\n\t\t\t\t\t\t\t\t\t\t.withDescription(\"Number of results per item\")\n\t\t\t\t\t\t\t\t\t\t.create(\"r\");\n\t\t\n\t\tOption configFile = OptionBuilder.withLongOpt(kOptionConfigFile)\n\t\t\t\t\t\t\t\t\t\t.hasArg()\n\t\t\t\t\t\t\t\t\t\t.withValueSeparator()\n\t\t\t\t\t\t\t\t\t\t.withDescription(\"Use the specified configuration \nfile\")\n\t\t\t\t\t\t\t\t\t\t.create();\n\t\t\n\t\tmOptions = new Options();\n\t\tmOptions.addOption(help);\n\t\tmOptions.addOption(version);\n\t\tmOptions.addOption(newRun);\n\t\tmOptions.addOption(trackerRun);\n\t\tmOptions.addOption(timeLimit);\n\t\tmOptions.addOption(age);\n\t\tmOptions.addOption(server);\n\t\tmOptions.addOption(numResults);\n\t\tmOptions.addOption(configFile);",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-25",
                "project": "Commons CLI",
                "title": "[PATCH] [CLI] Default Values for Arguments at definition stage",
                "type": "Bug",
                "description": "Sorry, I don't have CVS access at my current work and therefore this may not \nbe the right way to submit this patch, but I wanted to get this out before the \nweekend.\n\n[CLI2 - B1]\nThe functionality of using default values for Arguments at definition stage \ndoes not work. I looked at the test cases and the test cases relating to this \nfunctionality have been commented out, so my guess is that it may have been \nleft for a later release. I have done a quick fix, which may or may not be the \nbest way, but it doesn't break any existing functionality and seems to fulfill \nthe requirement.\n\nChanges are in three files, ArgumentImpl.java (in method processValues), in \nWriteableCommandLine.java (added a new method called addDefaults in this \ninterface) and WriteableCommandLineImpl.java (implemented the addDefaults \nmethod).\n\nI will attach the three files after submitting the bug.\n\n-- \nVikram",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-24",
                "project": "Commons CLI",
                "title": "options.parse(args) will throw AlreadySelectedException which is not public",
                "type": "Bug",
                "description": "options.parse(args) will throw AlreadySelectedException which is not public",
                "resolved": "2007-03-15",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CLI-23",
                "project": "Commons CLI",
                "title": "[cli] Passing properties in Parser does not work for options with a single argument",
                "type": "Bug",
                "description": "processProperties(Properties properties) in Parser.java calls opt.hasArgs().  \nThe hasArgs() function in Option.java returns true if the option has multiple \nvalues (this.numberOfArgs > 1). So for options with a single argument this \nreturns false. \nA simple fix is to change the opt.hasArgs() call to opt.hasArg() in Parser.java.",
                "resolved": "2007-03-15",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-22",
                "project": "Commons CLI",
                "title": "Quoted strings as a single argument.",
                "type": "Bug",
                "description": "---\nConsider the template\n\n userAdd -u <username> -s <shellname> -m <message>\n\nand the actual usage:\n\n # userAdd -u prabu -s /usr/bin/bash -m \"User Prabu\"\n---\n\n In the above, '\"User' and 'Prabu\"' are considered as\n two separate values by the Posix parser. Also, the\n option value against '-m' is obtained as '&quot;User'.\n\n I feel this should not be the case. Quoted strings \n should be considered as one argument.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-21",
                "project": "Commons CLI",
                "title": "[cli] clone method in Option should use super.clone()",
                "type": "Bug",
                "description": "In\norg.apache.commons.cli.Option\npublic method clone is implemented by creating a new instance through one of \nthe class Constructors, and then assigning values as required through the \nsetter methods.\n\nThis means that any subclasses of the Option class will not return a true \nclone, but a new Option instance instead.\n\nA proper implementation of clone should use super.clone() to create a new \ninstance, rather than calling the class constructor.  This allows shallows \nclones to propogate correctly down to subclasses.",
                "resolved": "2007-06-30",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-20",
                "project": "Commons CLI",
                "title": "MissingArgumentException: no argument for <option> is thrown when the option's parameter equals to an existing option.",
                "type": "Bug",
                "description": "MissingArgumentException: no argument for <option> is thrown when the option's\nparameter equals to an existing option. Example:\n-l option1\n-m option2\n\n//this will throw exception\n$app -l m\n\nTest case follows:\nimport junit.framework.*;\nimport org.apache.log4j.*;\nimport org.apache.commons.cli.*;\n\npublic class CliTest extends TestCase {\n\tCommandLineParser parser;\n\t\n\tpublic CliTest(String name) {\n\t\tsuper(name);\n\t}\n\tprotected void setUp() throws Exception {\n\t\tparser = new PosixParser();\n\t}\n\tpublic void testParamNamedAsOption() throws Exception {\n\t\tfinal String[] CLI_ARGS = new String[] {\"-z\", \"c\"};\n\t\tOption option = new Option(\"z\", \"timezone\", true, \n\t\t\t\"affected option\");\n\t\tOptions cliOptions = new Options();\n\t\tcliOptions.addOption(option);\n\t\tparser.parse(cliOptions, CLI_ARGS);\n\t\t\n\t\t//now add conflicting option\n\t\tcliOptions.addOption(\"c\", \"conflict\", true, \"conflict option\");\n\t\tparser.parse(cliOptions, CLI_ARGS);\n\t}\n}",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-19",
                "project": "Commons CLI",
                "title": "[cli] Broken link report (13 404s)",
                "type": "Bug",
                "description": "ht://Check (http://htcheck.sf.net/) detected 13 broken links in the cli\nsection. These broken links are listed below in this format:\n\nReferencing URL\n404: Referenced URL\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/ApplicationTest.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/ApplicationTest.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/BugsTest.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/BugsTest.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/BuildTest.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/BuildTest.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/GnuParseTest.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/GnuParseTest.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/HelpFormatterExamples.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/HelpFormatterExamples.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/OptionBuilderTest.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/OptionBuilderTest.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/OptionGroupTest.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/OptionGroupTest.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/ParseRequiredTest.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/ParseRequiredTest.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/ParseTest.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/ParseTest.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/PatternOptionBuilderTest.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/PatternOptionBuilderTest.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/TestHelpFormatter.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/TestHelpFormatter.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/ValueTest.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/ValueTest.html\n\nhttp://jakarta.apache.org/commons/cli/xref/org/apache/commons/cli/ValuesTest.html\n404:\nhttp://jakarta.apache.org/commons/cli/apidocs/org/apache/commons/cli/ValuesTest.html",
                "resolved": "2007-03-15",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-18",
                "project": "Commons CLI",
                "title": "HelpFormatter.printHelp(String cmdLineSyntax, String header, Options options, String footer) throws exception if footer contains CR LF",
                "type": "Bug",
                "description": "If String footer contains windows new line, printHelp throws exception.\nIf it contains only LF line endings, it works fine on Linux and Windows platforms.",
                "resolved": "2008-09-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-17",
                "project": "Commons CLI",
                "title": "Interrogation using switch statement",
                "type": "Bug",
                "description": "It should be possible to interrogate options using a simple a switch in a \nloop.  This requires a unique integer id for each option.\n\n(got to keep the features that were available in the original)",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-16",
                "project": "Commons CLI",
                "title": "[cli] CommandLine getArgList() serves no options but args, only",
                "type": "Bug",
                "description": "If i have some options set and want to know if the user specified some options \nwhich i do not support, i use method getArgList of CommandLine instance to \nretrieve those unsupported or unparsed options.\nJavadoc says: <i>Retrieve any left-over non-recognized options and \narguments.</i>\n\nIf i do so, i do get the args of the unparsed options, only.\nI do not get the options of that args.\nFor example:\nThe following commandline is given:\n-u paul -i id1 -i id2 -v -K XXX1 -L XXXXX2 -P\noptions -K, -L and -P are unknown as the usage shows:\nusage: CliExample\n -f,--id-file <id-filename>   filename specifying ids\n -h,--help                    show help\n -i,--id <id>                 id to manipulate\n -u,--user <username>         username to login\n -v,--verbose                 be more verbose\n\nbut getArgList shows XXX1 and XXXXX2, only.\nThere is no way to get the unparsed options -K, -L and -P.\n<b>If the user specifies unsupported options without any arguments (as option -\nP in this example), there is no chance to find those boolean unsupported \noptions.</b>\n\nI suggest to either add two methods:\nOption[]getNotRecognizedOptions() and \nList getNotRecognizedOptionList()\nor to fix \ngetArgList() and getArgs() to perform as Javadoc suggests.",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CLI-15",
                "project": "Commons CLI",
                "title": "HelpFormatter does not handle groups properly",
                "type": "Bug",
                "description": "The HelpFormatter repeats Options that have previously been printed with the group.\n\nThe problem is in the else block where options not belonging to a group are\nprinted.  The code gets executed if it does not belong to a group -OR- if the\ngroup has already been printed.\n\n   if( group != null && !list.contains(group)) {\n// this gets executed when a new group is found\n...\n} else {\n  // this gets executed if the group is OR ISN'T null, and if group is in list.  \n ....\n}\n\nThe else statement on line 267 should be as follows:\n\n} else if (group == null) {\n// This will make sure that options that have not been printed as part of a group\n// will not get printed again.\n...\n}\n\nI believe this change fixes the problem.\n\nAlso, the append on line 264 should add an extra space after the ] to make sure\nthat there will be a space between the ] and the next option.",
                "resolved": "2008-07-25",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-14",
                "project": "Commons CLI",
                "title": "Usage Scenario help page misleading",
                "type": "Bug",
                "description": "The CLI Usage Scenario text is misleading in the Ant example.\nSpecifically the Boolean option code example seems wrong - instead it should \nsurely be:\n\nOption help = new Option( null, \"help\", \"print this message\" );\nOption projecthelp = new Option( null, \"projecthelp\", \"print project help \ninformation\" );\nOption version = new Option( null, \"version\", \"print the version information \nand exit\" );\nOption quiet = new Option( null, \"quiet\", \"be extra quiet\" );\nOption verbose = new Option( null, \"verbose\", \"be extra verbose\" );\nOption debug = new Option( null, \"debug\", \"print debugging information\" );\nOption emacs = new Option( null, \"emacs\",\n                           \"produce logging information without adornments\" );\n\nSince these are Long Options, not short ?\nTook me ages to figure out why my code didn't behave properly!",
                "resolved": "2010-06-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-13",
                "project": "Commons CLI",
                "title": "[cli] CommandLine.getOptionValue() behaves contrary to docs",
                "type": "Bug",
                "description": "Hi\n\nIf I have:\n\nfinal String debugOpt = \"debug\";\n\tOption debug = OptionBuilder\n\t    .withArgName(debugOpt)\n\t    .withDescription(\"turn on debugging\")\n\t    .withLongOpt(debugOpt)\n\t    .create('d');\n\nand then later I do:\n\nString dbg = commandLine.getOptionValue(debugOpt);\n\nthen dbg will be null. Instead, I have to use getOptionValue('d'). This seems\ncontrary to the docs (see bottom of\nhttp://jakarta.apache.org/commons/cli/usage.html), which implies that I should\nbe able to query the commandLine object using a full string, rather than just\nthe string's first character.\n\nCan I suggest that the API of OptionBuilder be made clearer so that it is\nobvious that you can have long and short option names---perhaps make the\ncreate() method take no arguments (thus forcing long and short arg names to be\nset explicitly). (Also, there seems to be some confusion between the terms\n'argument' and 'option' in the API, but perhaps that is just me).\n\nAlso, I would hop to be able to query commandLine by either a single char or an\nentire string, as suggested by the docs.\n\nThanks,\n\nChris",
                "resolved": "2007-05-22",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-12",
                "project": "Commons CLI",
                "title": "[cli] Not handling property=value followed by 'remaining' args",
                "type": "Bug",
                "description": "If you have a command line args similar to\n\ndomything -Dmyprop1=myval1 -Dmyprop2=myval2 myfile\n\nI would expect to be able to set up the 'D' option so that \n\n String[] opts = line.getOptionValues( \"D\" );\n assertEquals( \"myprop1\", opts[0] );\n assertEquals( \"myval1\", opts[1] );\n assertEquals( \"myprop2\", opts[2] );\n assertEquals( \"myval2\", opts[3] );\n\n String[] xtraArgs = line.getArgs();\n assertEquals( \"myfile\", xtraArgs[0]);\n\nBut, setting up similar to the ApplicationTest.java I get 'myfile' as opts\n[4].  Since we have set up the 'D' option with hasArgs, it will only stop \nadding args to 'D' when it runs into another valid option, not an extra arg.  \nIf you set up the 'D' option with hasArg (singular) then it myprop1=myval1 \ngets reported as an invalid option.\n\nI've glanced at the source but didn't see an obvious fix that wouldn't \njeopardize the combinations and permutations that Option.addValue() must deal \nwith.",
                "resolved": "2006-07-12",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-11",
                "project": "Commons CLI",
                "title": "HelpFormatter throws NullPointerException",
                "type": "Bug",
                "description": "java.lang.NullPointerException\n\tat org.apache.commons.cli.Option.hasArgName(Option.java:398)\n\tat org.apache.commons.cli.HelpFormatter.renderOptions(HelpFormatter.java:368)\n\tat org.apache.commons.cli.HelpFormatter.printOptions(HelpFormatter.java:312)\n\tat org.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:209)\n\tat org.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:165)\n\tat org.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:145)\n\tat org.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:136)\n\nThis can be fixed by applying the following:\n\nIndex: Option.java\n===================================================================\nRCS file:\n/home/cvspublic/jakarta-commons/cli/src/java/org/apache/commons/cli/Option.java,v\nretrieving revision 1.14\ndiff -u -r1.14 Option.java\n--- Option.java\t8 Oct 2002 21:24:11 -0000\t1.14\n+++ Option.java\t15 Oct 2002 19:45:29 -0000\n@@ -395,7 +395,7 @@\n       * set.\n       */\n      public boolean hasArgName() {\n-         return (this.argName != null || this.argName.length() > 0 );\n+         return (this.argName != null && this.argName.length() > 0 );\n      }\n \n      /**",
                "resolved": "2007-03-15",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CLI-10",
                "project": "Commons CLI",
                "title": "[cli] testNewMessage1Param fails",
                "type": "Bug",
                "description": "[junit] Testcase: testOverridden took 0.031 sec\n    [junit] Testcase: testNewMessage1Param took 0 sec\n    [junit]     Caused an ERROR\n    [junit] Can't find resource for bundle java.util.PropertyResourceBundle, key\n test.message\n    [junit] java.util.MissingResourceException: Can't find resource for bundle j\nava.util.PropertyResourceBundle, key test.message\n    [junit]     at java.util.ResourceBundle.getObject(ResourceBundle.java:325)\n    [junit]     at java.util.ResourceBundle.getString(ResourceBundle.java:285)\n    [junit]     at org.apache.commons.cli2.resource.ResourceHelper.getMessage(Re\nsourceHelper.java:154)\n    [junit]     at org.apache.commons.cli2.resource.ResourceHelper.getMessage(Re\nsourceHelper.java:99)\n    [junit]     at org.apache.commons.cli2.resource.ResourceHelperTest.testNewMe\nssage1Param(ResourceHelperTest.java:61)\n    [junit]     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    [junit]     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAcces\nsorImpl.java:39)\n    [junit]     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMet\nhodAccessorImpl.java:25)\n\n    [junit] Testcase: testNewMessage1Param",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-9",
                "project": "Commons CLI",
                "title": "CLI cant parse ANT option set as claimed in official usage guide",
                "type": "Bug",
                "description": "In the main usage guide to the CLI tool, it goes through a long example of how \nto create the rules to parse the option set of ANT. Unfortunately:\n\n1. If you follow the instructions given, the resultant parser with not be able \nto parse the option set example given in the docs. The docs are simply wrong \nand could not have been validated.\n\n2. No matter what you do, the CLI software is too inflexible to *ever* parse \nthe ANT option set (How dumb is that??), because it insists that all options \nthat have a \"-\" prefix are one character long. \n\n3. The help formater doesnt work as documented on the usage page either - (due \nto a bug it took just a minute to find) it only prints usage help for options \nwhich have a single character descriptions, despite single char descriptions \nnot being mandatory.\n\n\nIn all, Ive been extremely dissappointed and surprised that marginally tested \nsoftware of such poor quality and design, whose own scant docs blatantly dont \nwork as described, can make it into such a position of influence.\n\nI spent about an hour comparing the 3 OS Java command line parsing libs \nyesterday, and (in part because of the (increasingly devalued) \"Jakarta \nCommons\" brand) sadly it seems I put my money on the wrong horse.",
                "resolved": "2010-06-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-8",
                "project": "Commons CLI",
                "title": "Line separator as first char for helpformatter (footer) throws exception",
                "type": "Bug",
                "description": "This might apply for more than just the footer. I only tested footer so don't \nknow.\n\ncompile and run this example and you will get an exception\n\n{code:java}\npublic class CliError\n{\n  public static void main(String[] args)\n  {\n    Options options = new Options();\n    HelpFormatter formatter = new HelpFormatter();\n    String footer = System.getProperty(\"line.separator\")+\"Hello world.\";\n    formatter.printHelp(80, \"foobar\", \"\", options, footer, true);\n  }\n}\n{code}\n\nresult is:\n\n{code}\njava.lang.StringIndexOutOfBoundsException: String index out of range: -1\n\tat java.lang.String.charAt(String.java:582)\n\tat org.apache.commons.cli.HelpFormatter.rtrim(HelpFormatter.java:505)\n\tat org.apache.commons.cli.HelpFormatter.renderWrappedText(HelpFormatter.java:416)\n\tat org.apache.commons.cli.HelpFormatter.printWrapped(HelpFormatter.java:324)\n\tat org.apache.commons.cli.HelpFormatter.printWrapped(HelpFormatter.java:318)\n\tat org.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:212)\n\tat org.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:165)\n\tat com.nokia.em.bts.swupdateautomate.test.CliError.main(CliError.java:21)\n\nException in thread \"main\" Process terminated with exit code 1\n{code}",
                "resolved": "2008-09-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-7",
                "project": "Commons CLI",
                "title": "[cli][PATCH] Javadoc warning",
                "type": "Bug",
                "description": "[javadoc]\n/home/sjr/jakarta-commons/cli/src/java/org/apache/commons/cli2/resource/ResourceHelper.java:86:\nwarning - @param argument \"clazz\" is not a parameter name.",
                "resolved": "2007-03-15",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-6",
                "project": "Commons CLI",
                "title": "Unknown options are ignored instead of throwing UnrecognizedOptionException",
                "type": "Bug",
                "description": "CLI does not handle unknown options, i.e. throw an 'UnrecognizedOptionException'.\nThe reason is that the logic of PosixParser.processOptionToken() is incomplete:\n\n        if (this.options.hasOption(token))\n        {\n            currentOption = this.options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n\n\nie. if the stopAtNonOption is not set and the token is unknown, it\nwill be ignored. there has to be a default case added:\n\n\n          else {\n            tokens.add(token);\n        }\n\nin which case the caller will throw the proper exception, because\nin Parse there is another check whether the option exists.\n\ni would've submitted a patch but did not find where to, sorry.\npeter",
                "resolved": "2008-07-24",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-5",
                "project": "Commons CLI",
                "title": "[cli] Dependecy on commons-lang-2.0 but commons-lang-1.0 is obtained",
                "type": "Bug",
                "description": "compile:\n    [mkdir] Created dir: D:\\development\\apache\\cli\\trunk\\target\\classes\n    [javac] Compiling 71 source files to D:\\development\\apache\\cli\\trunk\\target\\\nclasses\n    [javac] D:\\development\\apache\\cli\\trunk\\src\\java\\org\\apache\\commons\\cli\\Type\nHandler.java:25: package org.apache.commons.lang.math does not exist\n    [javac] import org.apache.commons.lang.math.NumberUtils;\n    [javac]                                     ^\n    [javac] D:\\development\\apache\\cli\\trunk\\src\\java\\org\\apache\\commons\\cli\\Type\nHandler.java:164: cannot resolve symbol\n    [javac] symbol  : variable NumberUtils\n    [javac] location: class org.apache.commons.cli.TypeHandler\n    [javac]             return NumberUtils.createNumber(str);\n    [javac]                    ^\n    [javac] 2 errors\n\nUpdating build.xml to obtain version 2.0 of commons-lang (instead of 1.0) fixes \nthe problem.",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-4",
                "project": "Commons CLI",
                "title": "Mispelled functions in DateValidator",
                "type": "Bug",
                "description": "The DateValidator class has two methods called\n\nisLeniant\nsetLeniant\n\nThese are misspelled.",
                "resolved": "2010-06-15",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-3",
                "project": "Commons CLI",
                "title": "[cli] CLI2 Group Parser skips arguments",
                "type": "Bug",
                "description": "The CLI2 group parser can skip an argument when you have more than one group \nin a set of arguments. This is caused when the shared iterator over arguments \nis passed to the GroupImpl.process method. The process method can pull more \nthan one argument from the iterator when the argument belongs to another group \nbut always does a single arguments.previous() on return. \n\nI have worked out a patch that will fix most cases but the real fix may be to \nprocess arguments in more than one passes. The first pass would burst \narguments and associate them with their groups. The argument list then needs \nto be sorted by group/argument/ordinal and processed to set values, etc.",
                "resolved": "2007-03-15",
                "versions": [],
                "fixVersions": [
                    "2.0"
                ]
            },
            {
                "issue_id": "CLI-2",
                "project": "Commons CLI",
                "title": "[cli] Wrong usage summary",
                "type": "Bug",
                "description": "The options of a OptionGroup appears twice in the usage summary as shown by the \nfollowing example([-c]):\n\nusage:   [-quiet] [-debug] [-ax | -c][-c] -version [-verbose]\n       [-projecthelp] [-help]\n -ax            ax or c\n -c             ax or c\n\nAlso a space is missing after the OptionGroup.\n\nI have corrected this error by modifying the file HelpFormatter.java, line up \n247. I include the modified codes for reference:\n\n           if( group != null /*&& !list.contains(group)*/ ) {\n                             =============> changed\n               if (!list.contains(group)) {\n               =============> added\n                   // add the group to the processed list\n                   list.add( group );\n\n                   // get the names of the options from the OptionGroup\n                   Collection names = group.getNames();\n\n                   buff.append( \"[\" );\n\n                   // for each option in the OptionGroup\n                   for( Iterator iter = names.iterator(); iter.hasNext(); ) {\n                       buff.append( iter.next() );\n                       if( iter.hasNext() ) {\n                           buff.append( \" | \" );\n                       }\n                   }\n                   buff.append( \"] \" );\n                   =============> changed\n               }\n               // else ignore\n           }",
                "resolved": "2007-03-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CLI-1",
                "project": "Commons CLI",
                "title": "PosixParser interupts \"-target opt\" as \"-t arget opt\"",
                "type": "Bug",
                "description": "This was posted on the Commons-Developer list and confirmed as a bug.\n\n> Is this a bug?  Or am I using this incorrectly?\n> I have an option with short and long values.  Given code that is \n> essentially what is below, with a PosixParser I see results as \n> follows:\n> \n> A command line with just \"-t\" prints out the results of the catch \n> block\n> (OK)\n> A command line with just \"-target\" prints out the results of the catch\n> block (OK)\n> A command line with just \"-t foobar.com\" prints out \"processing selected\n> target: foobar.com\" (OK)\n> A command line with just \"-target foobar.com\" prints out \"processing\n> selected target: arget\" (ERROR?)\n> \n> ======================================================================\n> ==\n> =======================\n>   private static final String OPTION_TARGET = \"t\";\n>   private static final String OPTION_TARGET_LONG = \"target\";\n>   // ...\n>   Option generateTarget = new Option(OPTION_TARGET, \n>                                      OPTION_TARGET_LONG, \n>                                      true, \n>                                      \"Generate files for the specified\n> target machine\");\n>   // ...\n>   try {\n>         parsedLine = parser.parse(cmdLineOpts, args);\n>       } catch (ParseException pe) {\n>         System.out.println(\"Invalid command: \" + pe.getMessage() +\n> \"\\n\");\n>         HelpFormatter hf = new HelpFormatter();\n>         hf.printHelp(USAGE, cmdLineOpts);\n>         System.exit(-1);\n>       }\n> \n>   if (parsedLine.hasOption(OPTION_TARGET)) {\n>     System.out.println(\"processing selected target: \" +\n> parsedLine.getOptionValue(OPTION_TARGET));        \n>   }\n\nIt is a bug but it is due to well defined behaviour (so that makes me feel a\nlittle better about myself ;).  To support *special* \n(well I call them special anyway) like -Dsystem.property=value we need to be\nable to examine the first character of an option.  If the first character is\nitself defined as an Option then the remainder of the token is used as the\nvalue, e.g. 'D' is the token, it is an option so 'system.property=value' is the\nargument value for that option.  This is the behaviour that we are seeing for\nyour example.  \n't' is the token, it is an options so 'arget' is the argument value.  \n\nI suppose a solution to this could be to have a way to specify properties for\nparsers.  In this case 'posix.special.option == true' for turning \non *special* options. I'll have a look into this and let you know.\n\nJust to keep track of this and to get you used to how we operate, can you log a\nbug in bugzilla for this.\n\nThanks,\n-John K",
                "resolved": "2007-03-15",
                "versions": [
                    "Nightly Builds"
                ],
                "fixVersions": []
            }
        ]
    }
}