{
    "bugs info": {
        "bug counter": 100,
        "bugs": [
            {
                "issue_id": "CSV-314",
                "project": "Commons CSV",
                "title": "Missing OSGi Import-Package versions in Manifest can make commons-csv unusable in OSGi environments",
                "type": "Bug",
                "description": "Since commons-csv 1.11.0, this library depends on *commons-codec* and on {*}commons-io{*}. Up to version 1.10.0, there were no (compile) dependencies.\r\n\r\nSince 1.11.0, the MANIFEST.MF contains *OSGi Import-Package headers* in the MANIFEST.MF, to import the required packages when running in an OSGi environment.\r\n\r\nHowever, those Import-Package headers don't define a (minimal) version of those commons-codec or commons-io packages.\r\nAs a consequence, depending on the exact OSGi environment and bundle loading order, someone may be unlucky and commons-csv may happily resolve against an _older_ commons-codec or commons-io, even though some of its code requires more recent commons-codec or commons-io API. This will result in runtime errors, later at runtime, whenever commons-csv tries to call such \"recent\" commons-io or commons-codec code.\r\n\r\nThis is similar to this commons-text issue: TEXT-233\r\n\r\nThe Apache maven-bundle-plugin calculates and generates the following Import-Package headers (commons-csv 1.12.0) :\r\n{code:java}\r\nImport-Package: org.apache.commons.codec.binary,org.apache.commons.io,or\r\n\u00a0g.apache.commons.io.function,org.apache.commons.io.input,org.apache.com\r\n\u00a0mons.io.output {code}\r\nUnfortunately, the maven-bundle-plugin currently doesn't add an explicit (minimal) version number directive to these header. So while loading commons-csv, OSGi may resolve this against older commons-codec or commons-io jars (if it sees those older versions first, for whatever reason).\r\n\r\nHowever, on a few places, commons-csv relies on code that only exists since specific versions of those dependencies. E.g. the CSVParser ctor refers UnsynchronizedBufferedReader, which only exists since commons-io 2.17.0.\r\n\r\nWe had a case where in the OSGi environment commons-csv was resolved against an older commons-io (2.15.1 or 2.11.0 or so), which then resulted in an exception the 1st time commons-csv tried to parse a csv :\r\n{code:java}\r\nCaused by: java.lang.NoClassDefFoundError: org/apache/commons/io/input/UnsynchronizedBufferedReader\r\n\u00a0 \u00a0 at org.apache.commons.csv.CSVParser.<init>(CSVParser.java:444) ~[?:?]\r\n\u00a0 \u00a0 at org.apache.commons.csv.CSVParser.<init>(CSVParser.java:412) ~[?:?]\r\n\u00a0 \u00a0 at org.apache.commons.csv.CSVParser.parse(CSVParser.java:311) ~[?:?] {code}\r\nSimilar issues may pop up elsewhere where commons-io or commons-codec gets called.\r\n\r\nI suppose that the solution would be similar to the solution of the commons-text issue:\r\n\r\ni.e. in the pom.xml :\r\n * define properties for the commons-codec and commons-io version\r\n * define a property {_}commons.osgi.import{_},\r\nwhere all the required import-packages need to be specified explicitly, with the required version directive.\r\n(This property is then picked up by the maven-bundle-plugin in the commons-parent pom)",
                "resolved": "2024-11-18",
                "versions": [
                    "1.11.0"
                ],
                "fixVersions": [
                    "1.13.0"
                ]
            },
            {
                "issue_id": "CSV-311",
                "project": "Commons CSV",
                "title": "OutOfMemory for very long rows despite using column value of type Reader",
                "type": "Bug",
                "description": "Our application makes use of commons-csv (great software, thanks!) .\r\n\r\nRecently, we got a support request because someone had unexpectedly large column values in one CSV row - so large that our explicitly chosen limits on the java heap did not suffice.\r\n\r\nWe analyzed the heap dump and found that a huge row was the culprit; the stack trace in question is\r\n{noformat}\r\nCaused by -> \u00a0java.lang.OutOfMemoryError: Java heap space \u00a0\r\n\u00a0Arrays.copyOf:3537 \u00a0\r\n\u00a0AbstractStringBuilder.ensureCapacityInternal:228 \u00a0\r\n\u00a0AbstractStringBuilder.append:802 \u00a0\r\n\u00a0StringBuilder.append:246 \u00a0\r\n\u00a0CSVFormat.printWithQuotes:2127 \u00a0\r\n\u00a0CSVFormat.print:1834 \u00a0\r\n\u00a0CSVFormat.print:1783 \u00a0\r\n\u00a0CSVPrinter.print:166 \u00a0\r\n\u00a0CSVPrinter.printRecord:259 \u00a0\r\n\u00a0CSVPrinter.printRecord:278   {noformat}\r\nNote that we provide column values of type java.io.Reader as accepted by org.apache.commons.csv.CSVFormat.print(Object, Appendable, boolean) .\r\n\r\nThe problem is that CSVFormat.print really supports java.io.Reader, but despite just piping characters (possibly escaped/quoted) into the appendable output stream, it reads everything into a StringBuilder which is then copied to the appendable output stream.\r\n\r\nIs there a way to improve this situation? We are working in a setup in which java heap cannot be spend arbitrarily and we would rather have an approach which works out of the box.\r\n\r\nThanks for looking into it!",
                "resolved": "2024-03-11",
                "versions": [
                    "1.10.0"
                ],
                "fixVersions": [
                    "1.11.0"
                ]
            },
            {
                "issue_id": "CSV-306",
                "project": "Commons CSV",
                "title": "The User Guide examples use deprecated methods",
                "type": "Bug",
                "description": "Hello.\r\n\r\nThe [User Guide|https://commons.apache.org/proper/commons-csv/user-guide.html] is using deprecated methods such as\u00a0\r\n\r\n{{withFirstRecordAsHeader()}}\r\n\r\nThanks!",
                "resolved": "2023-04-30",
                "versions": [
                    "1.9.0"
                ],
                "fixVersions": [
                    "1.11.0"
                ]
            },
            {
                "issue_id": "CSV-300",
                "project": "Commons CSV",
                "title": "CSVRecord.toList() does not give write access to the new List",
                "type": "Bug",
                "description": "{{CSVRecord.toList()}} converts the values to a list by calling {{Arrays.asList}} which writes to the private array in calls to {{{}Arrays.ArrayList.set(int, E){}}}.",
                "resolved": "2022-08-10",
                "versions": [
                    "1.9.0"
                ],
                "fixVersions": [
                    "1.10.0"
                ]
            },
            {
                "issue_id": "CSV-299",
                "project": "Commons CSV",
                "title": "get unexpected results when setting the delimiter to \u2018||\u2019",
                "type": "Bug",
                "description": "a simple but strange problem\r\n\r\nthe csv file is like\u00a0\r\n\r\n!image-2022-07-26-11-24-43-484.png|width=497,height=51!\r\n\r\nand the parse code is\u00a0\r\n\r\n\u00a0\r\n{code:java}\r\nFile csv = new File(\"src/main/resources/test.csv\");\r\nCSVFormat format = CSVFormat.Builder.create()\r\n        .setDelimiter(\"||\")\r\n        .setRecordSeparator(\"\\n\")\r\n        .build();\r\nIterable<CSVRecord> records = format.parse(new FileReader(csv));\r\nfor (CSVRecord record : records) {\r\n    System.out.println(record);\r\n} {code}\r\nthe output should be\u00a0\r\n\r\nYW-20210402-Z3N9X\r\n\r\n0\r\n\r\n13500900001|*|\\{\"name\":\"Mr.Chen13500900001\"}\r\n----\r\nbut I get the wrong result\r\n\r\n!image-2022-07-26-11-27-23-629.png|width=557,height=36!\r\n----\r\nif I add a space after the 0 like this\u00a0\r\n\r\n!image-2022-07-26-11-29-15-281.png|width=546,height=35!\r\n\r\nI can get the result I want\r\n\r\n!image-2022-07-26-11-29-54-455.png|width=552,height=31!\r\n----\r\nif I change the number >=10\u00a0 without a space it works just fine\r\n\r\n!image-2022-07-26-11-31-57-920.png|width=519,height=30!\r\n\r\n!image-2022-07-26-11-32-25-643.png|width=528,height=26!\r\n----\r\nHope I can get reply from you, thx!\r\n\r\n\u00a0",
                "resolved": "2023-05-31",
                "versions": [
                    "1.9.0"
                ],
                "fixVersions": [
                    "1.10.0"
                ]
            },
            {
                "issue_id": "CSV-297",
                "project": "Commons CSV",
                "title": "setHeader() does not consider the separator while parse header row",
                "type": "Bug",
                "description": "If you try to parse a file like this:\r\n{code:java}\r\nname$value\r\na$1\r\nb$0\r\nc$3{code}\r\nwith a CSVFormat defined like this:\r\n{code:java}\r\nCSVFormat.DEFAULT.builder()\r\n  \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .setRecordSeparator(\"$\")\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .setHeader()\r\n  \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .build();\u00a0\r\n{code}\r\nand then try to retrieve a field by name with:\r\n{code:java}\r\nrecord.get(\"name\"){code}\r\ni get the following error:\r\n\r\n\u00a0\r\n{code:java}\r\njava.lang.IllegalArgumentException: Mapping for name not found, expected one of [name$value]\r\n\u00a0 \u00a0 at org.apache.commons.csv.CSVRecord.get(CSVRecord.java:121)\r\n\u00a0\r\n{code}\r\nLooks like the parser does not consider the separator when auto detects headers.\r\n\r\nIf I modify the source file using comma as separator and\u00a0\r\n{code:java}\r\nformat.setRecordSeparator(\",\"){code}\r\n\u00a0it works.",
                "resolved": "2022-05-27",
                "versions": [
                    "1.9.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-296",
                "project": "Commons CSV",
                "title": "Delimiter followed by Whitespace then by Quotes Failing with setTrim(true)",
                "type": "Bug",
                "description": "I have my CSVFormat initialized such that *{{withTrim(true)}}*\u00a0has been set {_}(see attached ZIP file){_}:\r\n{code:java}\r\nCSVFormat csvFormat = CSVFormat.DEFAULT.withFirstRecordAsHeader()\r\n\u00a0 \u00a0 \u00a0 \u00a0 .withIgnoreEmptyLines(true).withTrim(true);{code}\r\n\u00a0\r\n\r\nHowever, a quoted string that begins after a delimiter followed by preceding whitespace is not properly parsed.\u00a0For example:\r\n{code:java}\r\nGIVEN_NAME,SURNAME,ADDRESS,PHONE_NUMBER\r\n\"Joe\",  \"Schmoe\",\"101 Main Street; Las Vegas, NV 89101\",\"702-555-1212\"\r\n\"John\",\"Doe\",  \"201 First Street; Las Vegas, NV 89102\", \"702-555-1313\"\r\n\"Jane\",\"Doe\",\"301 Second Street; Las Vegas, NV 89103\",\"702-555-1414\"\r\n{code}\r\n\u00a0\r\n * Notice the whitespace preceding {color:#0747a6}*{{\"Schmoe\"}}*{color} on the first record? \u00a0This leads to the actual value containing the quotation marks instead of them being stripped off.\r\n * The whitespace preceding {color:#0747a6}*{{\"201 First Street; Las Vegas, NV 89102\"}}*{color} on the second record leads to it to being parsed as two values: {color:#0747a6}*{{\"201 First Street; Las Vegas}}*{color} and {*}{{NV 89102\"}}{*}.\r\n * The third record is the only one that parses as expected.\r\n\r\nI believe that this is because the trimming is done *after* the value is being parsed rather than consuming the whitespace following the delimiter during parsing. \u00a0 Either that, or the check for a quoted string is occurring *before* the whitespace is being consumed.\r\n\r\n\u00a0\r\n\r\n*NOTE:* I have attached a ZIP file that easily reproduces the problem with the CSV file given above.\r\n\r\nTo build the attached project use Apache Maven and then execute using using Java 11:\r\n{code:java}\r\n> unzip csvfail.zip\r\n> cd csvfail\r\n> mvn package\r\n> java -jar target/csv-fail-1.0-SNAPSHOT.jar{code}",
                "resolved": "2022-11-01",
                "versions": [
                    "1.8"
                ],
                "fixVersions": [
                    "1.9.0"
                ]
            },
            {
                "issue_id": "CSV-294",
                "project": "Commons CSV",
                "title": "CSVFormat does not support explicit \" as escape char",
                "type": "Bug",
                "description": "Reading data that contains \" does not work if escape character is *manually set to {{'\"'}}* as specified in [RFC 4180|https://datatracker.ietf.org/doc/html/rfc4180].\r\n\r\n*It works for other escape characters or if no escape character is explicitly defined in the format.*\r\n\r\nThis line in {{Lexer.java}} is responsible for the originally quite erroneous ticket:\r\n\r\n{{this.escape = mapNullToDisabled(format.getEscapeCharacter());}}\r\n\r\nFrom this line I (wrongly) deduced that an unspecified escape character would actually disable escaping. Because of that I wanted to enable it by setting it to {{'\"'}} which causes exceptions in the Lexer for perfectly valid input. That in turn convinced my that this is a way bigger issue than it is. Sorry about that.\r\n\r\nI don't think that the current situation is ideal, though.\r\n\r\nI would not have been this confused if {{CSVFormat}} would be more explicit about the escape char that will be used, i.e. if {{toString()}} would show the implicitly used quote character or print - in case of {{null}} - that this means it's using the quote character. It is currently omitted from the output if it is not set explicitly.\r\n\r\nThere is also no documentation about what {{null}} as escape character actually means - it may be documented somewhere but isn't documented for {{CSVFormat.getEscapeCharacter()}} or {{CSVFormat.Builder.set/getEscape()}} methods.\r\n\r\nAnd setting the escape character explicitly to the value specified in the RFC should certainly not fail, even if setting it to that value is superfluous since {{null}} behaves exactly the same. \r\n\r\nh4. Relevant part of the RFC:\r\n\r\n7. If double-quotes are used to enclose fields, then a double-quote\r\nappearing inside a field must be escaped by preceding it with\r\nanother double quote. For example:\r\n\r\n\"aaa\",\"b\"\"bb\",\"ccc\"\r\n\r\nh4. Related issue:\r\n\r\nhttps://issues.apache.org/jira/browse/CSV-150",
                "resolved": "2024-09-14",
                "versions": [
                    "1.9.0"
                ],
                "fixVersions": [
                    "1.12.0"
                ]
            },
            {
                "issue_id": "CSV-292",
                "project": "Commons CSV",
                "title": "No Automatic-Module-Name prevents usage in JPMS projects without repacking the JAR",
                "type": "Bug",
                "description": "Currently the Commons CSV release JAR does not include an {{Automatic-Module-Name}} meaning it cannot be used in JPMS based projects, any attempt to do so results in errors like the following:\r\n\r\n{noformat}\r\nError occurred during initialization of boot layer\r\njava.lang.module.FindException: Module org.apache.commons.csv not found, required by com.github.rvesse.airline.examples\r\n{noformat}\r\n\r\nWhereas other Commons modules e.g. Lang, do have {{Automatic-Module-Name}} present and can be used in a JPMS based project.\r\n\r\nDigging into the {{pom.xml}} it looks like the difference between the two modules is that Lang adds JAR plugin configuration to add the {{Automatic-Module-Name}} whereas CSV does not.  Copying the configuration across between the modules should be sufficient to resolve this issue.",
                "resolved": "2021-12-15",
                "versions": [
                    "1.8",
                    "1.9.0"
                ],
                "fixVersions": [
                    "1.10.0"
                ]
            },
            {
                "issue_id": "CSV-291",
                "project": "Commons CSV",
                "title": "CSVRecord.values() accessor is package-private instead of public",
                "type": "Bug",
                "description": "Of all the methods in the\u00a0CSVRecord class, the\u00a0CSVRecord#value() accessor is package private. Because this accessor in never used by any other class in the commons-csv library, it can be concluded that it was not meant to be used only by the library itself. And because the class itself is private it can be concluded that it was not meant to be used only be derived classes. Thus it was certainly meant to provide access to the internal values array to a client or an decorator implementation. Unfortunately since it is package-private it is inaccessible.\r\n\r\nPlease make it public.",
                "resolved": "2021-11-02",
                "versions": [
                    "1.9.0"
                ],
                "fixVersions": [
                    "1.10.0"
                ]
            },
            {
                "issue_id": "CSV-290",
                "project": "Commons CSV",
                "title": "Produced CSV using PostgreSQL format cannot be read",
                "type": "Bug",
                "description": "{code:java}\r\n// code placeholder\r\n{code}\r\nCSV, produced using printer:\r\n\r\n\u00a0\r\n\r\nCSVPrinter printer = new CSVPrinter(sw, CSVFormat.POSTGRESQL_CSV.withFirstRecordAsHeader());\r\n\r\n\u00a0\r\n\r\ncannot be be read with same format parser:\r\n\r\n\u00a0\r\n\r\nCSVParser parser = new CSVParser(new StringReader(sw.toString()), CSVFormat.POSTGRESQL_CSV.withFirstRecordAsHeader());\r\n\r\n\u00a0\r\n\r\nTo reproduce:\u00a0\r\n\r\n\u00a0\r\n{code:java}\r\nStringWriter sw = new StringWriter(); \r\n\r\nCSVPrinter printer = new CSVPrinter(sw, CSVFormat.POSTGRESQL_CSV.withFirstRecordAsHeader());  \r\n\r\nprinter.printRecord(\"column1\", \"column2\"); \r\nprinter.printRecord(\"v11\", \"v12\"); \r\nprinter.printRecord(\"v21\", \"v22\");  \r\nprinter.close();  \r\n\r\nCSVParser parser = new CSVParser(new StringReader(sw.toString()), CSVFormat.POSTGRESQL_CSV.withFirstRecordAsHeader());  \r\n\r\nSystem.out.println(\"headers: \" + Arrays.equals(parser.getHeaderNames().toArray(), new String[] {\"column1\", \"column2\"}));  \r\n\r\nIterator<CSVRecord> i = parser.iterator(); \r\nSystem.out.println(\"row: \" + Arrays.equals(i.next().toList().toArray(), new String[] {\"v11\", \"v12\"})); \r\nSystem.out.println(\"row: \" + Arrays.equals(i.next().toList().toArray(), new String[] {\"v21\", \"v22\"}));{code}\r\nI'd expect the above code to work, but it fails:\r\n{code:java}\r\njava.io.IOException: (startline 1) EOF reached before encapsulated token finishedjava.io.IOException: (startline 1) EOF reached before encapsulated token finished \r\n\r\nat org.apache.commons.csv.Lexer.parseEncapsulatedToken(Lexer.java:371) \r\nat org.apache.commons.csv.Lexer.nextToken(Lexer.java:285) \r\nat org.apache.commons.csv.CSVParser.nextRecord(CSVParser.java:701) \r\nat org.apache.commons.csv.CSVParser.createHeaders(CSVParser.java:480) \r\nat org.apache.commons.csv.CSVParser.<init>(CSVParser.java:432) \r\nat org.apache.commons.csv.CSVParser.<init>(CSVParser.java:398) \r\nat Test.main(Test.java:25)\r\n{code}\r\n\u00a0",
                "resolved": "2022-10-15",
                "versions": [
                    "1.6",
                    "1.9.0"
                ],
                "fixVersions": [
                    "1.10.0"
                ]
            },
            {
                "issue_id": "CSV-288",
                "project": "Commons CSV",
                "title": "String delimiter (||) is not working as expected.",
                "type": "Bug",
                "description": "Steps to reproduce\u00a0 :\u00a0\r\n1. Parse CSV file with || as delimiter and having empty columns\r\n2. Print the CSVRecord resulting from CSVParser\r\n\r\n\r\n\u00a0\r\n//Expected : a,b,c,d,,f,g \r\n// Actual : a,b|c,d,|f,g\r\n\r\n\r\npublic static void main(String[] args) throws Exception\\{\r\n     String row = \"a||b||c||d||||f||g\";\r\n     StringBuilder stringBuilder = new StringBuilder();\r\n     try (CSVPrinter csvPrinter = new CSVPrinter(stringBuilder, CSVFormat.EXCEL);\r\n          CSVParser csvParser = CSVParser.parse(new StringInputStream(row), StandardCharsets.UTF_8, CSVFormat.Builder.create().setDelimiter(\"||\").build())) {\r\n         for (CSVRecord csvRecord : csvParser) {\r\n             for (int i = 0; i < csvRecord.size(); i++) {\r\n                 csvPrinter.print(csvRecord.get(i));\r\n             }\r\n             System.out.println(stringBuilder.toString());\r\n             //Expected : a,b,c,d,,f,g\r\n            // Actual : a,b|c,d,|f,g\r\n         }\r\n     }\r\n }\r\n\r\nWith the snippet provided above, actual value is not same as expected value",
                "resolved": "2022-02-19",
                "versions": [],
                "fixVersions": [
                    "1.10.0"
                ]
            },
            {
                "issue_id": "CSV-274",
                "project": "Commons CSV",
                "title": "CSVParser.iterator() does not iterate over result set as expected.",
                "type": "Bug",
                "description": "To return a stream of `CSVRecords` in a Spliterators, I need to call `CSVParser.getRecords().iterator()`. I worry that the `getRecords()` will load the records from the parser into memory, before creating the iterator which can be a problem with large CSV files.\r\n\r\nMy code:\u00a0\r\n{code:java}\r\n    public Stream<CSVRecord> convertFileToMaps(Path path) throws IOException {\r\n        try (CSVParser parser = CSVParser.parse(path, Charset.defaultCharset(), CSVFormat.RFC4180\r\n            .withFirstRecordAsHeader())) {\r\n            return StreamSupport.stream(Spliterators.spliteratorUnknownSize(parser.iterator(), 0), false);\r\n        }\r\n}\r\n{code}\r\nand:\r\n{code:java}\r\n    public Stream<CSVRecord> convertFileToMaps(Path path) throws IOException {\r\n        try (CSVParser parser = CSVParser.parse(path, Charset.defaultCharset(), CSVFormat.RFC4180\r\n            .withFirstRecordAsHeader())) {\r\n            return StreamSupport.stream(parser.spliterator(), false);\r\n        }\r\n}\r\n{code}\r\nWhen I collect the results of my method, it gives me\r\n{code:java}\r\n[]\r\n{code}\r\n\u00a0\r\n\r\nIf I replace `parser.iterator()` with `parser.getRecords().iterator()` then I get the desired results. Is the iterator not meant to be an iterator of the list of `CSVRecord`.",
                "resolved": "2022-10-15",
                "versions": [
                    "1.8"
                ],
                "fixVersions": [
                    "1.10.0"
                ]
            },
            {
                "issue_id": "CSV-271",
                "project": "Commons CSV",
                "title": "Missing separator with \"print(object)\" followed by \"printRecord(Object[])\"",
                "type": "Bug",
                "description": "Hello,\r\n\r\nthe following code produces CSV with a missing separator:\r\n{code:java}\r\nCSVPrinter csv=new CSVPrinter(new OutputStreamWriter(System.out,StandardCharsets.UTF_8),CSVFormat.DEFAULT);\r\n\r\ncsv.print(\"a\");\r\ncsv.printRecord(\"b\",\"c\");{code}\r\nThis produces \"ab,c\".\r\n\r\nThe corresponding function that takes a list, works properly:\r\n{code:java}\r\ncsv.print(\"a\");\r\ncsv.printRecord(Arrays.asList(\"b\",\"c\"));{code}\r\nProduces \"a,b,c\" as expected",
                "resolved": "2022-03-10",
                "versions": [
                    "1.8"
                ],
                "fixVersions": [
                    "1.9.0"
                ]
            },
            {
                "issue_id": "CSV-269",
                "project": "Commons CSV",
                "title": "CSVRecord.get(Enum) should use Enum.name() instead of Enum.toString()",
                "type": "Bug",
                "description": "I updated from 1.7 to 1.8 which breaks retrieving a value from CSVRecord using an Enum.\r\n\r\nIt is caused by this piece of code:\r\n{code:java}\r\npublic String get(final Enum<?> e) {\r\n    return get(Objects.toString(e, null));\r\n}\r\n{code}\r\nThis now uses Enum.toString() instead of Enum.name(). This works so long as the toString() method of the enum class has not been overridden. However, whereas Enum.name() is final and returns the correct value for this use case, toString() may be overridden to provide a human friendly desciption of the enum value.\r\n\r\nIf the toString() method of the enum class is non-default, this results in\r\n\r\n\r\n{code:java}\r\njava.lang.IllegalArgumentException: Mapping for [toString value] not found, expected one of [enum names]\r\n{code}\r\n\r\nPlease change this method to use the enum name instead of toString.\r\n\r\n\u00a0",
                "resolved": "2022-02-19",
                "versions": [
                    "1.8"
                ],
                "fixVersions": [
                    "1.10.0"
                ]
            },
            {
                "issue_id": "CSV-265",
                "project": "Commons CSV",
                "title": "CSV comments break CSVRecord#getCharacterPosition",
                "type": "Bug",
                "description": "The CSVRecord#getCharacterPosition method returns an incorrect value after the CSVParser has encountered a comment in the CSV file.\r\n\r\nExample:\r\n\r\n\u00a0\r\n{code:java}\r\nString csv = \"# Comment\\n\"\r\n           + \"Headers,Header2\\n\"\r\n           + \"Value1,Value2\\n\";\r\nCSVFormat format = CSVFormat.EXCEL.withCommentMarker('#').withFirstRecordAsHeader();\r\nCSVParser parser = new CSVParser(new StringReader(csv), format);\r\nlong expectedPosition = csv.indexOf(\"Value1\");\r\nlong actualPosition = parser.iterator().next().getCharacterPosition();\r\nassertEquals(expectedPosition, actualPosition);{code}\r\n\u00a0",
                "resolved": "2021-07-21",
                "versions": [
                    "1.8"
                ],
                "fixVersions": [
                    "1.9.0"
                ]
            },
            {
                "issue_id": "CSV-264",
                "project": "Commons CSV",
                "title": "Duplicate empty header names are allowed even with `.withAllowDuplicateHeaderNames(false)`",
                "type": "Bug",
                "description": "I'm trying to parse to parse a csv like this:\r\n\r\n\u00a0\r\n\r\n{{CSVFormat.DEFAULT}}\r\n{{ .withHeader()}}\r\n{{ .withAllowDuplicateHeaderNames(false)}}\r\n{{ .withAllowMissingColumnNames()}}\r\n{{ .parse(InputStreamReader(FileInputStream(fl)))}}\r\n\r\n\u00a0\r\n\r\nOne would expect this code to throw an error if the following csv is given as input:\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n{{\"\",\"a\",\"\"}}\r\n\r\n{{\"1\",\"X\",\"3\"}}\r\n\r\n{{\"3\",\"Y\",\"4\"}}\r\n\r\n\u00a0\r\n\r\nBut it doesn't, and asking for `record.get(\"\")` gives the value from the second column. The first column is ignored.",
                "resolved": "2022-02-19",
                "versions": [
                    "1.8"
                ],
                "fixVersions": [
                    "1.10.0"
                ]
            },
            {
                "issue_id": "CSV-263",
                "project": "Commons CSV",
                "title": "Print from Reader with embedded quotes generates incorrect output",
                "type": "Bug",
                "description": "I have found a problem in v1.8 where output with embedded quotes supplied from Reader is incorrectly escaping. When data read from the Reader starts with an embedded quote, output quote escaping is unbalanced and cannot be subsequently parsed/loaded. Subsequent embedded quotes are correctly escaped.\r\n\r\ninput data:\r\n {{\"A\" ASKED \"B\" ANOTHER QUESTION.}}\r\n\r\noutput:\r\n {{\"\"\"\"A\"\" ASKED \"\"B\"\" ANOTHER QUESTION.\"}}\r\n\r\nexpected output:\r\n {{\"\"\"A\"\" ASKED \"\"B\"\" ANOTHER QUESTION.\"}}\r\n\r\nSee attached patches.",
                "resolved": "2021-07-08",
                "versions": [
                    "1.8"
                ],
                "fixVersions": [
                    "1.9.0"
                ]
            },
            {
                "issue_id": "CSV-262",
                "project": "Commons CSV",
                "title": "Which version of Commons csv is supported with AEM 6.5",
                "type": "Bug",
                "description": "Which version of Commons csv is supported with AEM 6.5. I am migrating my project from AEM6.1 to AEM 6.5\r\n\r\n\u00a0\r\n\r\nIn AEM 6.1 i am using csv commons\u00a0 1.6. With AEM 6.5, I have tried 1. 7 and 1.8. but got error.\r\n\r\n\u00a0\r\n\r\n\u00a0",
                "resolved": "2022-02-19",
                "versions": [
                    "1.8"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-259",
                "project": "Commons CSV",
                "title": "CSVFormat.printWithEscapes throws StringIndexOutOfBoundsException when value is Reader",
                "type": "Bug",
                "description": "{code:java}\r\n//\u4ee3\u7801\u5360\u4f4d\u7b26\r\n@Test\r\npublic void testPrintWithEscapeReader() throws IOException {\r\n    final StringWriter sw = new StringWriter();\r\n    final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\r\n    Reader reader = new FileReader(\"src/test/resources/testPrintWithReader.txt\");\r\n    try (final CSVPrinter printer = new CSVPrinter(sw, format)) {\r\n        printer.print(reader);\r\n        assertEquals(\"q!,w!,e\", sw.toString());\r\n    }\r\n}\r\n{code}\r\nand the values in testPrintWithReader.txt is\r\n{code:java}\r\n//\u4ee3\u7801\u5360\u4f4d\u7b26\r\nq,w,e\r\n{code}\r\nafter tracing the code I think the problem cause by here\r\n{code:java}\r\n//\u4ee3\u7801\u5360\u4f4d\u7b26\r\nprivate void printWithEscapes(final Reader reader, final Appendable out) throws IOException {\r\n    int start = 0;\r\n    int pos = 0;\r\n\r\n    final char delim = getDelimiter();\r\n    final char escape = getEscapeCharacter().charValue();\r\n    final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\r\n\r\n    int c;\r\n    while (-1 != (c = reader.read())) {\r\n        builder.append((char) c);\r\n        if (c == CR || c == LF || c == delim || c == escape) {\r\n            // write out segment up until this char\r\n            if (pos > start) {\r\n                out.append(builder.substring(start, pos));\r\n                builder.setLength(0);\r\n            }\r\n            if (c == LF) {\r\n                c = 'n';\r\n            } else if (c == CR) {\r\n                c = 'r';\r\n            }\r\n\r\n            out.append(escape);\r\n            out.append((char) c);\r\n\r\n            start = pos + 1; // start on the current char after this one\r\n        }\r\n        pos++;\r\n    }\r\n\r\n    // write last segment\r\n    if (pos > start) {\r\n        out.append(builder.substring(start, pos));\r\n    }\r\n}\r\n{code}\r\nthat line\u00a0\r\n{code:java}\r\n//\u4ee3\u7801\u5360\u4f4d\u7b26\r\nbuilder.setLength(0);\r\n{code}\r\nwill cause the exception. After delete that line , the testcase will passed.\r\n\r\nis that a bug? may be I could contribute to it",
                "resolved": "2020-03-17",
                "versions": [
                    "1.8"
                ],
                "fixVersions": [
                    "1.9.0"
                ]
            },
            {
                "issue_id": "CSV-258",
                "project": "Commons CSV",
                "title": "Error on read of special characters with little endian encoding",
                "type": "Bug",
                "description": "Under certain scenarios, super-csv will blow up when consuming special characters. To make this error appear:\r\n # Copy/paste the following CSV data into an empty file:\r\n\r\n\u00a0\r\n{quote}{{CONLANG, LOCAL}}\r\n\r\n{{ONE, 1}}\r\n\r\n{{TWO, 2}}\r\n\r\n{{THREE, 3}}\r\n\r\n{{FOUR\u00e1\u00e1\u00e7\u00f5, 4}}\r\n{quote} # Save this file with encoding: UTF-16 Little Endian\r\n\r\n # Try to parse the file with super-csv\r\n\r\nHere is the top stack trace I got while using it:\r\n\r\n\u00a0\r\n{quote}{{MalformedInputException reading next record: java.nio.charset.MalformedInputException: Input length = 1-java.lang.IllegalStateException\r\njava.nio.charset.MalformedInputException: Input length = 1\r\n\tat java.base/java.nio.charset.CoderResult.throwException(CoderResult.java:274)\r\n\tat java.base/sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:352)\r\n\tat java.base/sun.nio.cs.StreamDecoder.read(StreamDecoder.java:188)\r\n\tat java.base/java.io.InputStreamReader.read(InputStreamReader.java:181)\r\n\tat java.base/java.io.BufferedReader.read1(BufferedReader.java:210)\r\n\tat java.base/java.io.BufferedReader.read(BufferedReader.java:287)\r\n\tat java.base/java.io.BufferedReader.fill(BufferedReader.java:161)\r\n\tat java.base/java.io.BufferedReader.read(BufferedReader.java:182)\r\n\tat org.apache.commons.csv.ExtendedBufferedReader.read(ExtendedBufferedReader.java:58)\r\n\tat org.apache.commons.csv.Lexer.nextToken(Lexer.java:95)\r\n\tat org.apache.commons.csv.CSVParser.nextRecord(CSVParser.java:664)\r\n\tat org.apache.commons.csv.CSVParser$CSVRecordIterator.getNextRecord(CSVParser.java:142)\r\n\tat org.apache.commons.csv.CSVParser$CSVRecordIterator.hasNext(CSVParser.java:155)}}\r\n{quote}\r\nLet me know if there are any other details I can git to help!",
                "resolved": "2020-02-25",
                "versions": [
                    "1.8"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-256",
                "project": "Commons CSV",
                "title": "CSVRecord implements Serializable however one of it's fields does not",
                "type": "Bug",
                "description": "I was using this library when I realized that the CSVRecord class implements Serializable, however, one of its fields does not (CSVParser). Doesn't this effectively mean that CSVRecord should not implement that? It's a bit misleading.",
                "resolved": "2020-01-24",
                "versions": [
                    "1.8"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-250",
                "project": "Commons CSV",
                "title": "Cannot locate field mapping on class org.apache.commons.csv.CSVRecord",
                "type": "Bug",
                "description": "After upgrading from 1.6 to 1.7, parser invocations started to throw IllegalArgumentException:\r\n\r\n\"Cannot locate field mapping on class org.apache.commons.csv.CSVRecord\"\r\n\r\nReverting the project back to 1.6 resolved the problem.\r\n\r\njavac 11.0.4\u00a0\r\n\r\nopenjdk version \"11.0.4\" 2019-07-16\r\nOpenJDK Runtime Environment (build 11.0.4+11-post-Ubuntu-1ubuntu218.04.3)\r\nOpenJDK 64-Bit Server VM (build 11.0.4+11-post-Ubuntu-1ubuntu218.04.3, mixed mode, sharing)\r\n\r\n\u00a0",
                "resolved": "2019-09-01",
                "versions": [
                    "1.7"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-249",
                "project": "Commons CSV",
                "title": "ArrayIndexOutOfBoundsException when trying to read record written by CSVPrinter using CSVParser with same format",
                "type": "Bug",
                "description": "The following code will fail with the exception\u00a0\r\n\r\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\r\n{noformat}\r\nimport org.apache.commons.csv.*;\r\n\r\nimport java.io.StringReader;\r\nimport java.io.StringWriter;\r\nimport java.util.List;\r\n\r\npublic class Poc {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        CSVFormat csvFormat = CSVFormat.DEFAULT\r\n                .withEscape('\\\\');\r\n\r\n        StringWriter stringWriter = new StringWriter();\r\n\r\n        CSVPrinter printer = new CSVPrinter(stringWriter, csvFormat);\r\n        printer.printRecord(\"foo \\\\\", \"bar\");\r\n\r\n        StringReader stringReader = new StringReader(stringWriter.toString());\r\n        CSVParser parser = new CSVParser(stringReader, csvFormat);\r\n        List<CSVRecord> records = parser.getRecords();\r\n\r\n        records.forEach(record -> {\r\n            System.out.println(record.get(0));\r\n            System.out.println(record.get(1));\r\n        });\r\n\r\n    }\r\n}{noformat}",
                "resolved": "2019-09-28",
                "versions": [
                    "1.5",
                    "1.6",
                    "1.7"
                ],
                "fixVersions": [
                    "1.8"
                ]
            },
            {
                "issue_id": "CSV-248",
                "project": "Commons CSV",
                "title": "CSVRecord is not Serializable",
                "type": "Bug",
                "description": "CSVRecord is no longer Serializable as it stores the CSVParser and that is not serializable.\r\n\r\nThe parser contains a list of all the CSVRecords. So to serialize this would serialize a lot of extra information. The cascade of serialization eventually\u00a0includes the original BufferedReader used to read the data.\r\n\r\nThe parser is required for the header map functionality and the getParser() method. The easy fix is to not support any functionality related to the parser after deserialization. If the header map functionality is to be supported the class can store the header map (easy), or overload the serialization methods to record and load the header map (more effort), or something else.\r\n\r\n\u00a0\r\n\r\n\u00a0",
                "resolved": "2020-01-21",
                "versions": [
                    "1.7"
                ],
                "fixVersions": [
                    "1.8"
                ]
            },
            {
                "issue_id": "CSV-247",
                "project": "Commons CSV",
                "title": "A single empty header is allowed when not allowing empty column headers.",
                "type": "Bug",
                "description": "If the settings are not allowing empty columns headers you can currently use a single empty header. This is because column headers are only checked for empty when they are duplicates. So it is the second empty header (the first duplicate) that raises an error. This test should pass but does not:\r\n{code:java}\r\n@Test(expected = IllegalArgumentException.class)\r\npublic void testHeadersMissingOneColumnException() throws Exception {\r\n \u00a0\u00a0\u00a0final Reader in = new StringReader(\"a,,c,d\\n1,2,3,4\\nx,y,z,zz\"); \u00a0\u00a0\u00a0CSVFormat.DEFAULT.withHeader().parse(in).iterator(); \r\n}\r\n{code}",
                "resolved": "2019-10-06",
                "versions": [
                    "1.7"
                ],
                "fixVersions": [
                    "1.8"
                ]
            },
            {
                "issue_id": "CSV-245",
                "project": "Commons CSV",
                "title": "Post 1.7 release fixes.",
                "type": "Bug",
                "description": "* Fix checkstyle: remove tabs\r\n* Fix checkstyle: Split long line\r\n* Fix checkstyle: exclude pom.properties\r\n* Update findbugs to allow deliberate fall-through\r\n* Fix pmd: Remove ternary operator returning false\r\n* Fix pmd: Remove implicit final\r\n* Fix pmd: Ignore TooManyStaticImports.\r\n\r\nThis requires adding the default ruleset and then modifying with\r\nsuppressions.\r\n\r\n* Add tests to cover use of the IOUtils class.\r\n\r\nRequires the CSVFormat to have no quote or escape character, and the\r\nformatted value to be a java.io.Reader.\r\n\r\n* Clean-up findbugs exclude filter.\r\n* Removed unused import\r\n* Updated test comments for print tests targeting IOUtils.\r\n* Fix checkstyle: Suppress line length warning in CSVParser.",
                "resolved": "2019-06-15",
                "versions": [
                    "1.7"
                ],
                "fixVersions": [
                    "1.8"
                ]
            },
            {
                "issue_id": "CSV-241",
                "project": "Commons CSV",
                "title": "CSVFormat#valiadte() does not account for allowDuplicateHeaderNames #43",
                "type": "Bug",
                "description": "{{CSVFormat#valiadte()}} does not account for\u00a0{{allowDuplicateHeaderNames}} {color:#a3aab1}#43{color}\r\n\r\n\u00a0",
                "resolved": "2019-06-06",
                "versions": [],
                "fixVersions": [
                    "1.8"
                ]
            },
            {
                "issue_id": "CSV-240",
                "project": "Commons CSV",
                "title": "Links for JavaDoc broken on web site",
                "type": "Bug",
                "description": "The sidebar on the left of this page:\r\n\r\n[https://commons.apache.org/proper/commons-csv/]\r\n\r\n\u2026has items for `Javadoc 1.6`, `Javadoc 1.5`, and so on. The main body of the page has the same. All of these links for the numbered versions of `Javadoc` are broken, resulting in a `Not Found` error page.\r\n\r\nFor example, one such broken link:\u00a0\r\n\r\n[https://commons.apache.org/proper/commons-csv/archives/1.6/apidocs/index.html]\r\n\r\nThe only Javadoc link that works is `Javadoc Trunk`, but that is for the forthcoming release, not the current release.\r\n\r\nhttps://commons.apache.org/proper/commons-csv/apidocs/index.html\r\n\r\n\u00a0\r\n\r\n\u00a0",
                "resolved": "2019-10-07",
                "versions": [
                    "1.6"
                ],
                "fixVersions": [
                    "1.7"
                ]
            },
            {
                "issue_id": "CSV-238",
                "project": "Commons CSV",
                "title": "Escape quotes in CLOBs",
                "type": "Bug",
                "description": "CSV-234 left an issue where CLOBs with embedded quotes were not properly escaped.\r\n\r\nGiven a CLOB like:\r\n{code:java}\r\nChoose either\r\n\"Y\" or \"N\"{code}\r\nIt should be transformed to:\r\n{code:java}\r\nChoose either\r\n\"\"Y\"\" or \"\"N\"\"{code}\r\n\u00a0\r\n\r\nThis patch will fix it (the bad coverage report is from unrelated code pushed to master this past weekend)\r\n\r\n[https://github.com/apache/commons-csv/pull/39]\r\n\r\n\u00a0",
                "resolved": "2019-02-27",
                "versions": [],
                "fixVersions": [
                    "1.7"
                ]
            },
            {
                "issue_id": "CSV-235",
                "project": "Commons CSV",
                "title": "WRONG Implementation for RFC4180  ",
                "type": "Bug",
                "description": "[https://tools.ietf.org/html/rfc4180#section-2]\r\n   7.  If double-quotes are used to enclose fields, then a double-quote\r\n       appearing inside a field must be escaped by preceding it with\r\n       another double quote.  For example:\r\n\r\n       \"aaa\",\"b\"\"bb\",\"ccc\"\r\nApparently, base on a previous issue:\u00a0https://issues.apache.org/jira/browse/CSV-208, it turns out\u00a0common-csv *does not even support quote and escape to be the same character*.\r\n\r\nRFC 4180 defines that quote and escape are both DQUOTE, however in common-csv\u00a0implementation, the default escape character is not DQUOTE, and it does not work if changed to DQUOTE.\r\n\r\nThis means common csv is not rfc4180 compliant.\r\n\r\nAlso, I'm puzzled by the fact that someone\u00a0marked CSV-208 as fixed when nothing is fixed. Instead, it changed the behavior without documenting that the POSTGRESQL_CSV format does not even work out of the box with the default csv format that postgresql produces.",
                "resolved": "2019-06-16",
                "versions": [
                    "1.6"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-232",
                "project": "Commons CSV",
                "title": "Site link \"Source Repository\" does not work",
                "type": "Bug",
                "description": "The link https://commons.apache.org/proper/commons-csv/source-repository.html (which is in the menu on the left hand side of https://commons.apache.org/proper/commons-csv/) does not work. I get a 404 - Not found.\r\n\r\nFor anyone seeing this, the sources are available at https://github.com/apache/commons-csv",
                "resolved": "2018-10-23",
                "versions": [],
                "fixVersions": [
                    "1.7"
                ]
            },
            {
                "issue_id": "CSV-224",
                "project": "Commons CSV",
                "title": "Some multi-iterator parsing peek sequences incorrectly consume elements",
                "type": "Bug",
                "description": "Repeated calls to CSVParser Iterable return new Iterators that each reference the same underlying parser lexer. Within the scope of a\u00a0single Iterator, row peeking with Iterator.hasNext() works as intended. When row peeking with Iterator.hasNext()\u00a0under circumstances that create a new Iterator, an element is consumed by the iterator which cannot be\u00a0accessed by subsequent, newly created Iterators and Iterator.next()s. Effectively, the record Iterator and the lexer get out of sequence. See snippet below.\r\n\r\nThe \"right thing\" is keeping the Iterator in sequence with the lexer, and since this is reading from a buffer, there seem to me to be only two resolutions:\r\n # One lexer, one Iterator.\r\n # New Iterators, but peeking with hasNext doesn't advance the lexer.\r\n\r\n\u00a0\r\n\r\nIf there's a consensus on one of these, I can put up a PR.\r\n\r\n\u00a0\r\n{code:java}\r\n\u00a0 @Test\r\n\r\n\u00a0 public void newIteratorSameLexer() throws Exception {\r\n\r\n\r\n\r\n\u00a0 \u00a0 String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\r\n\r\n\r\n\r\n\u00a0 \u00a0 System.out.println(\"Enhanced for loop, no peeking:\");\r\n\r\n\u00a0 \u00a0 CSVParser parser =\r\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 new CSVParser(new BufferedReader(new StringReader(fiveRows)), CSVFormat.DEFAULT);\r\n\r\n\u00a0 \u00a0 int recordNumber = 0;\r\n\r\n\u00a0 \u00a0 for (CSVRecord record : parser) {\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 \u00a0 if (recordNumber >= 2) {\r\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 break;\r\n\r\n\u00a0 \u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // CSVParser.iterator() returns a new iterator, but the lexer isn't reset so we can pick up\r\n\r\n\u00a0 \u00a0 // where we left off.\r\n\r\n\u00a0 \u00a0 for (CSVRecord record : parser) {\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // Enhanced for loop, no peeking:\r\n\r\n\u00a0 \u00a0 // 1 -> 1\r\n\r\n\u00a0 \u00a0 // 2 -> 2\r\n\r\n\u00a0 \u00a0 // 3 -> 3\r\n\r\n\u00a0 \u00a0 // 4 -> 4\r\n\r\n\u00a0 \u00a0 // 5 -> 5\r\n\r\n\r\n\r\n\r\n\r\n\u00a0 \u00a0 System.out.println(\"\\nEnhanced for loop, with peek:\");\r\n\r\n\u00a0 \u00a0 parser = new CSVParser(new BufferedReader(new StringReader(fiveRows)), CSVFormat.DEFAULT);\r\n\r\n\u00a0 \u00a0 recordNumber = 0;\r\n\r\n\u00a0 \u00a0 for (CSVRecord record : parser) {\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 \u00a0 if (recordNumber >= 2) {\r\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 break;\r\n\r\n\u00a0 \u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // CSVParser.iterator() returns a new iterator, but we call hasNext before next, so we queue\r\n\r\n\u00a0 \u00a0 // one element for consumption. This element is discarded by the new iterator, even though the\r\n\r\n\u00a0 \u00a0 // lexer has advanced a row, so we've consumed an element with the peek!\r\n\r\n\u00a0 \u00a0 System.out.println(\"hasNext(): \" + parser.iterator().hasNext());\r\n\r\n\u00a0 \u00a0 for (CSVRecord record : parser) {\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // Enhanced for loop, with peek:\r\n\r\n\u00a0 \u00a0 // 1 -> 1\r\n\r\n\u00a0 \u00a0 // 2 -> 2\r\n\r\n\u00a0 \u00a0 // hasNext(): true\r\n\r\n\u00a0 \u00a0 // 3 -> 4\r\n\r\n\u00a0 \u00a0 // 4 -> 5\r\n\r\n\r\n\r\n\r\n\r\n\u00a0 \u00a0 System.out.println(\"\\nIterator while, with peek:\");\r\n\r\n\u00a0 \u00a0 parser = new CSVParser(new BufferedReader(new StringReader(fiveRows)), CSVFormat.DEFAULT);\r\n\r\n\u00a0 \u00a0 recordNumber = 0;\r\n\r\n\u00a0 \u00a0 Iterator<CSVRecord> iter = parser.iterator();\r\n\r\n\u00a0 \u00a0 while (iter.hasNext()) {\r\n\r\n\u00a0 \u00a0 \u00a0 CSVRecord record = iter.next();\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 \u00a0 if (recordNumber >= 2) {\r\n\r\n\u00a0 \u00a0 \u00a0 \u00a0 break;\r\n\r\n\u00a0 \u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // When we use the same iterator, iterator and lexer are in sequence.\r\n\r\n\u00a0 \u00a0 System.out.println(\"hasNext(): \" + iter.hasNext());\r\n\r\n\u00a0 \u00a0 while (iter.hasNext()) {\r\n\r\n\u00a0 \u00a0 \u00a0 CSVRecord record = iter.next();\r\n\r\n\u00a0 \u00a0 \u00a0 recordNumber++;\r\n\r\n\u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n\r\n\u00a0 \u00a0 }\r\n\r\n\u00a0 \u00a0 // Iterator while, with peek:\r\n\r\n\u00a0 \u00a0 // 1 -> 1\r\n\r\n\u00a0 \u00a0 // 2 -> 2\r\n\r\n\u00a0 \u00a0 // hasNext(): true\r\n\r\n\u00a0 \u00a0 // 3 -> 3\r\n\r\n\u00a0 \u00a0 // 4 -> 4\r\n\r\n\u00a0 \u00a0 // 5 -> 5\r\n\r\n\u00a0 }{code}",
                "resolved": "2018-05-18",
                "versions": [
                    "1.5"
                ],
                "fixVersions": [
                    "1.6"
                ]
            },
            {
                "issue_id": "CSV-223",
                "project": "Commons CSV",
                "title": "Inconsistency between Javadoc of  CSVFormat DEFAULT EXCEL",
                "type": "Bug",
                "description": "According to the [Javadoc of CSVFormat|https://commons.apache.org/proper/commons-csv/archives/1.5/apidocs/index.html]\u00a0\r\n * {{CSVFormat.DEFAULT}} includes among its settings\u00a0{{withIgnoreEmptyLines(true)}}\r\n * {{CSVFormat.EXCEL}} includes among its settings\u00a0{{withIgnoreEmptyLines(false)}}\r\n * Then, the same documentation of {{CSVFormat.EXCEL}} reads that \r\n{quote}Note: this is currently like RFC4180 plus withAllowMissingColumnNames(true).{quote}\r\n\r\nOne of these three must be wrong (both ignore empty lines, or neither ignores empty lines, or there is another difference that needs to be mentioned).\r\nEdit: after checking the source code, I conclude that the latest sentence is incomplete, and should also mention {{withIgnoreEmptyLines(false)}} as a difference with {{DEFAULT}}",
                "resolved": "2018-04-03",
                "versions": [],
                "fixVersions": [
                    "1.6"
                ]
            },
            {
                "issue_id": "CSV-219",
                "project": "Commons CSV",
                "title": "The behavior of quote char using is not similar as Excel does when the first string contains CJK char(s)",
                "type": "Bug",
                "description": "When using CSVFormat.EXCEL to print a CSV file, the behavior of quote char using is not similar as Microsoft Excel does when the first string contains Chinese, Japanese or Korean (CJK) char(s).\r\n\r\ne.g.\r\nThere are 3 data members in a record, with Japanese chars: \"\u3042\", \"\u3044\", \"\u3046\":\r\n  Microsoft Excel outputs:\r\n  \u3042,\u3044,\u3046\r\n  Apache Common CSV outputs:\r\n  \"\u3042\",\u3044,\u3046\r\n",
                "resolved": "2017-12-11",
                "versions": [
                    "1.5"
                ],
                "fixVersions": [
                    "1.6"
                ]
            },
            {
                "issue_id": "CSV-217",
                "project": "Commons CSV",
                "title": "Add autoFlush option for CSVPrinter",
                "type": "Bug",
                "description": "CsvPrinter doesn't flush data on close. Looks like a bug, for me.\r\n\r\nUpdated: Add an option \"autoFlush\" to CSVFormat to be used by CSVPrinter.",
                "resolved": "2017-10-09",
                "versions": [],
                "fixVersions": [
                    "1.6"
                ]
            },
            {
                "issue_id": "CSV-213",
                "project": "Commons CSV",
                "title": "CSVParser#iterator()#hasNext() fails",
                "type": "Bug",
                "description": "Hello,\nwith class sample below and attached fail the program fails. Problem is that iterator wrongly computes the records. If hasNext is true then next record should be fetched.\n+ wouldn't it be better to provide currentRecord also?\n\n{code:java}\npublic class Test {\n\n    private static final CSVFormat csvFormat =\n            CSVFormat.DEFAULT\n                    .withDelimiter(';')\n                    .withFirstRecordAsHeader()\n                    .withRecordSeparator('\\n')\n                    .withQuoteMode(QuoteMode.ALL);\n\n\n    private static Optional<String[]> createEndChannel(File csvFile) {\n        try (Reader reader = new InputStreamReader(new FileInputStream(csvFile), StandardCharsets.UTF_8);\n             CSVParser parser = new CSVParser(reader, csvFormat)) {\n            if (parser.iterator().hasNext()) {\n                System.out.println(parser.getCurrentLineNumber());\n                System.out.println(parser.getRecordNumber());\n                // get only first record we don't need other's\n                CSVRecord firstRecord = parser.iterator().next(); // this fails\n\n                return Optional.of(null);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error while adding end channel to csv\", e);\n        }\n\n        return Optional.empty();\n    }\n\n\n    public static void main(String[] args) {\n        createEndChannel(new File(\"/tmp/999751170.patch.csv\"));\n        //createEndChannel(new File(\"/tmp/129441.csv\"));\n    }\n}\n{code}\n",
                "resolved": "2019-06-15",
                "versions": [
                    "1.4"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-212",
                "project": "Commons CSV",
                "title": "Empty dataframe being written as an empty CSV, without header",
                "type": "Bug",
                "description": "On Spark 2.1. \n\nHow to reproduce:\n\n{{> $SPARK_HOME/bin/spark-shell\n...\n\nscala> import spark.implicits._\nimport spark.implicits._\n\nscala> val emptyDF = Seq[(Int)]().toDF(\"foo\")\nemptyDF: org.apache.spark.sql.DataFrame = [foo: int]\n\nscala> emptyDF.write.option(\"header\",\"true\").csv(\"/tmp/emptyDF\")\n\n\nscala> spark.read.option(\"header\", \"true\").csv(\"/tmp/emptyDF\")\njava.lang.UnsupportedOperationException: empty collection\n  at org.apache.spark.rdd.RDD$$anonfun$first$1.apply(RDD.scala:1369)\n  at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:151)\n  at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:112)\n  at org.apache.spark.rdd.RDD.withScope(RDD.scala:362)\n  at org.apache.spark.rdd.RDD.first(RDD.scala:1366)\n  at org.apache.spark.sql.execution.datasources.csv.CSVFileFormat.findFirstLine(CSVFileFormat.scala:206)\n  at org.apache.spark.sql.execution.datasources.csv.CSVFileFormat.inferSchema(CSVFileFormat.scala:60)\n  at org.apache.spark.sql.execution.datasources.DataSource$$anonfun$7.apply(DataSource.scala:184)\n  at org.apache.spark.sql.execution.datasources.DataSource$$anonfun$7.apply(DataSource.scala:184)\n  at scala.Option.orElse(Option.scala:289)\n  at org.apache.spark.sql.execution.datasources.DataSource.org$apache$spark$sql$execution$datasources$DataSource$$getOrInferFileFormatSchema(DataSource.scala:183)\n  at org.apache.spark.sql.execution.datasources.DataSource.resolveRelation(DataSource.scala:387)\n  at org.apache.spark.sql.DataFrameReader.load(DataFrameReader.scala:152)\n  at org.apache.spark.sql.DataFrameReader.csv(DataFrameReader.scala:415)\n  at org.apache.spark.sql.DataFrameReader.csv(DataFrameReader.scala:352)\n  ... 48 elided\n\nscala> :quit\n\n> ls -lh /tmp/emptyDF                                                                                                                                                                                         \ntotal 0\n-rw-r--r-- 1 konrad konrad 0 Jun 19 12:00 part-00000-523374b7-b117-4f36-a428-f43bcb405077.csv\n-rw-r--r-- 1 konrad konrad 0 Jun 19 12:00 _SUCCESS}}",
                "resolved": "2017-06-19",
                "versions": [
                    "2.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-211",
                "project": "Commons CSV",
                "title": "CSVFormat.format trims last delimiter if the delimiter is a white space",
                "type": "Bug",
                "description": "The function CSVFormat.format() trims off the last delimiter if the delimiter is a white space character and the value in the last column is null.\n\n{code:java}\n    public String format(Object... values) {\n        StringWriter out = new StringWriter();\n\n        try {\n            (new CSVPrinter(out, this)).printRecord(values);\n            return out.toString().trim();\n        } catch (IOException var4) {\n            throw new IllegalStateException(var4);\n        }\n    }\n{code}\n\nFor example, consider the following records (\\t = tab)-\n\nID{color:red}\\t{color}Name{color:red}\\t{color}Country{color:red}\\t{color}Age\n1{color:red}\\t{color}John Doe{color:red}\\t{color}USA{color:red}\\t{color}20\n2{color:red}\\t{color}Jane Doe{color:red}\\t{color}USA{color:red}\\t{color}\n\nThe CSVFormat.format() on both the rows returns the following -\n\nID{color:red}\\t{color}Name{color:red}\\t{color}Country{color:red}\\t{color}Age\n1{color:red}\\t{color}John Doe{color:red}\\t{color}USA{color:red}\\t{color}20\n2{color:red}\\t{color}Jane Doe{color:red}\\t{color}USA\n\nNote that there is a missing delimiter for the last column in the second record.\n\nThis usually causes schema mismatch when we try and read back the CSV file as there is one less column in all the rows which have a null at the end.\n\nI feel the trim() is unnecessary while returning *out.toString()*",
                "resolved": "2020-05-24",
                "versions": [
                    "1.4"
                ],
                "fixVersions": [
                    "1.9.0"
                ]
            },
            {
                "issue_id": "CSV-208",
                "project": "Commons CSV",
                "title": "Fix escape character for POSTGRESQL_TEXT and POSTGRESQL_CSV formats.",
                "type": "Bug",
                "description": "Cannot parse PostgreSQL CSV and Text formats.\n\nWe cannot seem to parse the stock PostgreSQL Text format, see \n\n- org.apache.commons.csv.CSVPrinterTest.testRandomPostgreSqlCsv()\n- org.apache.commons.csv.CSVPrinterTest.testRandomPostgreSqlText()\n- org.apache.commons.csv.CSVPrinterTest.testPostgreSqlCsvNullOutput()\n- org.apache.commons.csv.CSVPrinterTest.testPostgreSqlCsvTextOutput()\n\nI am guessing that the issue is that in PostgreSQL, the escape character is the same as the quote character:\n\n{quote}\nQUOTE\nSpecifies the quoting character to be used when a data value is quoted. The default is double-quote. This must be a single one-byte character. This option is allowed only when using CSV format.\n\nESCAPE\nSpecifies the character that should appear before a data character that matches the QUOTE value. The default is the same as the QUOTE value (so that the quoting character is doubled if it appears in the data). This must be a single one-byte character. This option is allowed only when using CSV format.\n{quote}\n",
                "resolved": "2018-10-20",
                "versions": [],
                "fixVersions": [
                    "1.7"
                ]
            },
            {
                "issue_id": "CSV-203",
                "project": "Commons CSV",
                "title": "withNullString value is printed without quotes when QuoteMode.ALL is specified; add QuoteMode.ALL_NON_NULL",
                "type": "Bug",
                "description": "When setting QuoteMode.ALL is set we expect all values to be quoted, even those set as a default. This works in Commons 1.2 but doesn't in 1.4.\n\nConsider the following program:\n{code}\nimport org.apache.commons.csv.QuoteMode;\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVPrinter;\n\npublic class CommonsCsvIsSlightlyBroken {\n    \n    public static void main(String[] args) throws Exception {\n        CSVFormat format = CSVFormat.EXCEL\n            .withNullString(\"N/A\")\n            .withIgnoreSurroundingSpaces(true)\n            .withQuoteMode(QuoteMode.ALL);\n        CSVPrinter printer = new CSVPrinter(System.out, format);\n        printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });\n    }\n}\n{code}\n\nFor 1.2 we get quoted output:\n{code}\nrichard@kichemaru:~/$ java -cp ~/.m2/repository/org/apache/commons/commons-csv/1.2/commons-csv-1.2.jar:. CommonsCsvIsSlightlyBroken\n\"N/A\",\"Hello\",\"N/A\",\"World\"\n{code}\n\nWhen run with 1.4 we get unquoted output for default fields:\n{code}\nrichard@kichemaru:~/$ java -cp ~/.m2/repository/org/apache/commons/commons-csv/1.4/commons-csv-1.4.jar:. CommonsCsvIsSlightlyBroken\nN/A,\"Hello\",N/A,\"World\"\n{code}\n",
                "resolved": "2017-03-27",
                "versions": [
                    "1.3",
                    "1.4"
                ],
                "fixVersions": [
                    "1.5"
                ]
            },
            {
                "issue_id": "CSV-202",
                "project": "Commons CSV",
                "title": "Can't parse Excel file",
                "type": "Bug",
                "description": "I was excited to discover CSV could parse excel files, allowing me to skip a tedious step in processing files I receive. Sadly, it seems to be unable to parse the .xls file I'm given.\n\nI've included a simplified file with just the header row. When I try to parse it with {{CSVParser csv = CSVFormat.EXCEL.withHeader().parse(reader)}} and {{String customerID = rec.get(\"Customer ID\")}} (inside a loop), I get this mess:\n\n{code}\njava.lang.IllegalArgumentException: Mapping for Customer ID not found, expected one of [\ufffd\ufffd\u0871\ufffd>\ufffd\ufffd\t#%\ufffd\ufffd\ufffd\ufffd&\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd    \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\\p                                                                                                             B\ufffda=\ufffd@\ufffd\"\ufffd\ufffd\ufffd`\ufffd\ufffd\ufffd\ufffd\ufffd=-X>\ufffd78X1, \ufffdHelvetica Neue1\ufffd\t\ufffdArial1@\ufffd\ufffdVerdana1@\ufffd\ufffdVerdanam/d/yyyy\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd \ufffd \ufffd \ufffd+\ufffd\ufffd \ufffd\ufffd \ufffd)\ufffd\ufffd \ufffd\ufffd \ufffd, \ufffd\ufffd \ufffd\ufffd \ufffd*\ufffd\ufffd \ufffd\ufffd \ufffd\t\ufffd\ufffd \ufffd\ufffd \ufffd \ufffd \ufffd!|!\ufffd\ufffd]\n\tat org.apache.commons.csv.CSVRecord.get(CSVRecord.java:104){code}\n\nFile attached.",
                "resolved": "2016-11-13",
                "versions": [
                    "1.4"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-198",
                "project": "Commons CSV",
                "title": "Cannot parse file by header with custom delimiter on Java 1.6",
                "type": "Bug",
                "description": "Reading a CSV file from the parser using the header line results in \"IllegalArgumentException: Mappng for <column> not found\" - even when the column exists in the file. In this case, we are using Java 1.6 and the file uses the ^ symbol to delimit columns. This works correctly in Java 7 & Java 8.\n\nThe code required to reproduce the issue is below. You can find the optd_por_public.csv file referenced at https://raw.githubusercontent.com/opentraveldata/opentraveldata/master/opentraveldata/optd_por_public.csv\n\nIt will need to be on the classpath to run the unit test.  Hope that helps, Tadhg\n\nYou should get the following output\n\n--------------------------------------\n{code}\njava.lang.IllegalArgumentException: Mapping for location_type not found, expected one of [iata_code,icao_code,faa_code,is_geonames,geoname_id,envelope_id,name,asciiname,latitude,longitude,fclass,fcode,page_rank,date_from,date_until,comment,country_code,cc2,country_name,continent_name,adm1_code,adm1_name_utf,adm1_name_ascii,adm2_code,adm2_name_utf,adm2_name_ascii,adm3_code,adm4_code,population,elevation,gtopo30,timezone,gmt_offset,dst_offset,raw_offset,moddate,city_code_list,city_name_list,city_detail_list,tvl_por_list,state_code,location_type,wiki_link,alt_name_section,wac,wac_name]\n\tat org.apache.commons.csv.CSVRecord.get(CSVRecord.java:104)\n\tat com.amadeus.ui.CSVRecordTest.test(CSVRecordTest.java:31)\n{code}\n\n------------\n{code:java}\nimport static org.junit.Assert.assertNotNull;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\n\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVParser;\nimport org.apache.commons.csv.CSVRecord;\nimport org.junit.Test;\n\npublic class CSVRecordTest {\n\n\tprivate static final CSVFormat CSV_FORMAT = CSVFormat.EXCEL.withDelimiter('^').withFirstRecordAsHeader();\n\t\n\t@Test\n\tpublic void test() throws UnsupportedEncodingException, IOException {\n\t\tInputStream pointsOfReference = getClass().getResourceAsStream(\"/optd_por_public.csv\");\n\t\tCSVParser parser = CSV_FORMAT.parse(new InputStreamReader(pointsOfReference, \"UTF-8\"));\n\t\tfor (CSVRecord record : parser) {\n\t\t\tString locationType = record.get(\"location_type\");\n\t\t\tassertNotNull(locationType);\n\t\t}\n\t}\n\n}\n{code}\n",
                "resolved": "2019-06-15",
                "versions": [
                    "1.4"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-197",
                "project": "Commons CSV",
                "title": "CSVParser doesn't close the underlying handle after iteration",
                "type": "Bug",
                "description": "The following code leaks file handles:\n{code}\nCSVParser parser = // setup parser\nfor (CSVRecord rec: parser) {\n}\n// leak\n{code}\n\nI'd expect the underlying iterator to close() if it's finished iterating. ",
                "resolved": "2019-06-15",
                "versions": [],
                "fixVersions": [
                    "Patch Needed",
                    "Discussion",
                    "1.x"
                ]
            },
            {
                "issue_id": "CSV-195",
                "project": "Commons CSV",
                "title": "Parser iterates over the last CSV Record twice.",
                "type": "Bug",
                "description": "{code:java}\nclass CSVParserSpecification extends Specification {\n   def \"TEst CSVParser\"() {\n      setup:\n         URL url = new URL(\"https://....../csv_with_28_lines_header_plus_ 27_records\");\n         BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n         def CSVParser parser = CSVFormat.RFC4180.withFirstRecordAsHeader().withIgnoreEmptyLines().withTrim().parse(reader);\n      when:\n         def count = 0\n         for (CSVRecord record: parser)\n            { println(\"Processing \" + parser.getCurrentLineNumber()) count++ }\n         println(count);\n         parser.close()\n      then:\n         count == 27\n   }\n}\n{code}",
                "resolved": "2020-06-01",
                "versions": [
                    "1.4"
                ],
                "fixVersions": [
                    "1.9.0"
                ]
            },
            {
                "issue_id": "CSV-194",
                "project": "Commons CSV",
                "title": "Fix outdated comments about FileReader in CSVParser #13",
                "type": "Bug",
                "description": "See https://github.com/apache/commons-csv/pull/13.",
                "resolved": "2016-08-23",
                "versions": [
                    "1.4"
                ],
                "fixVersions": [
                    "1.5"
                ]
            },
            {
                "issue_id": "CSV-193",
                "project": "Commons CSV",
                "title": "Fix incorrect method name 'withFirstRowAsHeader' in user guide",
                "type": "Bug",
                "description": "In src/site/xdoc/user-guide.xml, on line 146, the method name 'withFirstRecordAsHeader' is incorrectly written as 'withFirstRowAsHeader'.",
                "resolved": "2016-08-11",
                "versions": [],
                "fixVersions": [
                    "1.5"
                ]
            },
            {
                "issue_id": "CSV-171",
                "project": "Commons CSV",
                "title": "Negative numeric values in the first column are always quoted in minimal mode",
                "type": "Bug",
                "description": "Negative Numeric values are always quoted in minimal mode if (and only if) they are in the first column.\n\ni.e.\nlong,lat,data\n\"-92.222\",43.333,3\n\nLooking at the code, this is by design but seem to be for an unknown reason.\n\nFrom v1.2 CSVPrinter line 230:\n\n// TODO where did this rule come from?\nif (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n    quote = true;\n} else ...\n   \n\nI propose this rule to either be remove or at a minimum be changed to:\n// TODO where did this rule come from?\nif (newRecord && (c !='-' && c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n    quote = true;\n} else ...\n   \n\n",
                "resolved": "2016-07-31",
                "versions": [],
                "fixVersions": [
                    "1.5"
                ]
            },
            {
                "issue_id": "CSV-170",
                "project": "Commons CSV",
                "title": "CSVFormat.MYSQL nullString should be \"\\N\"",
                "type": "Bug",
                "description": "{{CSVFormat.MYSQL}}'s {{nullString}} should be:\n\n{noformat}\n\"\\N\"\n{noformat}",
                "resolved": "2016-01-19",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CSV-169",
                "project": "Commons CSV",
                "title": "The null string should be case-sensitive when reading records",
                "type": "Bug",
                "description": "The null string should be case-sensitive when reading records. In 1.2 the null string is checked with {{String.equalsIgnoreCase()}}, it should use plain {{equals()}}",
                "resolved": "2016-01-18",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CSV-168",
                "project": "Commons CSV",
                "title": "CsvFormat.nullString should not be escaped",
                "type": "Bug",
                "description": "Hello,\n\nUse case: I'm generating MySQL dump files (text format) - for more details check this - http://dev.mysql.com/doc/refman/5.7/en/select-into.html. \n\nIssue: The value null is represented as \"\\N\". Also by default the escape char is '\\N'. The CsvPrinter.printAndEscape method will convert this value into {noformat}\"\\\\N\"{noformat}\n\nI suggest to modify the CsvPrinter in order to not escape the nullString value  - it should be written as it is. I can create a pull request if you want.\n\nI consider it a minor issue because it can be mitigated by making sure that the escape character is not a part of the nullString - however in my case it means that the LOAD commands should be modified accordingly.",
                "resolved": "2016-01-19",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CSV-167",
                "project": "Commons CSV",
                "title": "Comment line hides next record",
                "type": "Bug",
                "description": "1. First CSV record after the comment line is not processed at all (record #2 and #7)\n2. Second/Third line after the first comment line are not recognized as comment lines (record #5 and #6)\n\nSee attached example!",
                "resolved": "2016-01-31",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CSV-164",
                "project": "Commons CSV",
                "title": "Support duplicate header names",
                "type": "Bug",
                "description": "nothing prevents a CSV to have the same time the same header name so validation at the end of org.apache.commons.csv.CSVFormat#validate should likely disappear or should support a flag to disable it",
                "resolved": "2022-05-22",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.10.0"
                ]
            },
            {
                "issue_id": "CSV-162",
                "project": "Commons CSV",
                "title": "Two qoute characters in a row cause error ",
                "type": "Bug",
                "description": "Hello!\nI've recently noticed a some bug, I think. I have the following csv file:\n{quote}\n DATA_SERVICE_ID,\"\"DATA_SPEED_APID\"\",COMPONENT_ID,SPEED,SYNCHRONOUS \n2120000,\"\"1596\"\",4240000,9600,true\n{quote}\n(The first line is a header)\n\nI'm trying to parse it via this configuration:\n{{CSVFormat format = CSVFormat.newFormat(',').withQuote('\"').withHeader();}}\n\n*Expected result*: all headers and values without quotes\n*Actual result*: {quote}Exception in thread \"main\" java.io.IOException: (line 1) invalid char between encapsulated token and delimiter\n\tat org.apache.commons.csv.Lexer.parseEncapsulatedToken(Lexer.java:275)\n\tat org.apache.commons.csv.Lexer.nextToken(Lexer.java:152)\n\tat org.apache.commons.csv.CSVParser.nextRecord(CSVParser.java:498)\n\tat org.apache.commons.csv.CSVParser.initializeHeader(CSVParser.java:386)\n\tat org.apache.commons.csv.CSVParser.<init>(CSVParser.java:283)\n\tat org.apache.commons.csv.CSVParser.<init>(CSVParser.java:251)\n\tat Runner.main(Runner.java:20)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:497)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:140){quote}",
                "resolved": "2015-11-11",
                "versions": [
                    "1.2"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-161",
                "project": "Commons CSV",
                "title": "Fix Javadoc to say CSVFormat with() methods return a new CSVFormat",
                "type": "Bug",
                "description": "The quoting mode depends on the order of format declaration.",
                "resolved": "2016-01-19",
                "versions": [
                    "1.2"
                ],
                "fixVersions": [
                    "1.3"
                ]
            },
            {
                "issue_id": "CSV-158",
                "project": "Commons CSV",
                "title": "Fix EOL checking for read array in ExtendedBufferedReader",
                "type": "Bug",
                "description": "Placeholder for https://github.com/apache/commons-csv/pull/5:\n\nbq. Characters in buffer before offset are unspecified",
                "resolved": "2021-07-07",
                "versions": [],
                "fixVersions": [
                    "1.9.0"
                ]
            },
            {
                "issue_id": "CSV-156",
                "project": "Commons CSV",
                "title": "Incorrect Javadoc on QuoteMode.NONE",
                "type": "Bug",
                "description": "The JavaDoc for {{QuoteMode.NONE}} says:\n{quote}\nNever quotes fields. When the delimiter occurs in data, it is preceded by the current escape character. If the escape character is not set, printing will throw an exception if any characters that require escaping are encountered.\n{quote}\n\nHowever, the {{CSVFormat.validate()}} method will throw an {{IllegalArgumentException}} if there is no escape character.\n\nI was expecting the documented behaviour. I guess I will need to use {{QuoteMode.MINIMAL}} instead.",
                "resolved": "2015-08-10",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CSV-150",
                "project": "Commons CSV",
                "title": "Escaping is not disableable",
                "type": "Bug",
                "description": "h6. Problem\nIf escaping is disabled the Lexer maps the NULL Character to the magic char  '\\ufffe'.  I currently hit this char randomly with data. This leads to a RuntimeException inside of org.apache.commons.csv.Lexer.parseEncapsulatedToken(Token) with the message \"invalid char between encapsulated token and delimiter\". \n\nh6. Solution\nDon't map the Character object and use it. \n\n{code:title=Lexer.java|borderStyle=solid}\n    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n        this.reader = reader;\n        this.delimiter = format.getDelimiter();\n        this.escape = format.getEscapeCharacter();\n        .\n        .\n        .\n    }\n\n    boolean isEscape(final int ch) {\n        return null != this.escape && escape.charValue() == ch;\n    }\n{code}\n\nh6. Hint\nThis pattern is used in other cases to. It seem to be a systematic error. This cases should be refactored also.\n",
                "resolved": "2024-09-14",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.12.0"
                ]
            },
            {
                "issue_id": "CSV-149",
                "project": "Commons CSV",
                "title": "Line number is not proper at EOF",
                "type": "Bug",
                "description": "CSVParser.getCurrentLineNumber() is returning wrong line number (actual line number - 1) when EOF file is reached without record delimiter (\\r\\n).\n",
                "resolved": "2020-06-01",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.9.0"
                ]
            },
            {
                "issue_id": "CSV-148",
                "project": "Commons CSV",
                "title": "Add test cases for withIgnoreSurroundingSpaces() and withTrim() #70",
                "type": "Bug",
                "description": "It seems that {{CSVFormat}}'s property {{ignoreSurroundingSpaces}} is not taken into consideration while printing out values using {{CSVPrinter}}.\n\nGiven:\n{code}\nSystem.out.println(\n\tCSVFormat.DEFAULT\n\t\t\t.withIgnoreSurroundingSpaces(true)\n\t\t\t.format(\"\",\n\t\t\t\t\" \",\n\t\t\t\t\" Single space on the left\",\n\t\t\t\t\"Single space on the right \",\n\t\t\t\t\" Single spaces on both sides \",\n\t\t\t\t\"   Multiple spaces on the left\",\n\t\t\t\t\"Multiple spaces on the right    \",\n\t\t\t\t\"  Multiple spaces on both sides     \")\n);\n{code}\n\nActual result:\n{code}\n\"\",\" \",\" Single space on the left\",\"Single space on the right \",\" Single spaces on both sides \",\"   Multiple spaces on the left\",\"Multiple spaces on the right    \",\"  Multiple spaces on both sides     \"\n{code}\n\nExpected result:\n{code}\n\"\",\"\",\"Single space on the left\",\"Single space on the right\",\"Single spaces on both sides\",\"Multiple spaces on the left\",\"Multiple spaces on the right\",\"Multiple spaces on both sides\"\n{code}",
                "resolved": "2021-07-03",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.9.0"
                ]
            },
            {
                "issue_id": "CSV-145",
                "project": "Commons CSV",
                "title": "CSVFormat.with* methods clear the header comments",
                "type": "Bug",
                "description": "Some of the CSVFormat.with* methods clear the header comments by just passing null to the constructor. Using header comments works only with set at last.",
                "resolved": "2014-11-26",
                "versions": [
                    "1.1"
                ],
                "fixVersions": [
                    "1.2"
                ]
            },
            {
                "issue_id": "CSV-144",
                "project": "Commons CSV",
                "title": "Broken link on project's nav panel, for item \"Javadoc 1.1\"",
                "type": "Bug",
                "description": "The item \"Javadoc 1.1\" in the project's web page's nav panel has this URL:\n\nhttp://commons.apache.org/proper/commons-csv/archives/1.1/apidocs/index.html\n\nFollowing that link generates page saying:\n[\nNot Found\n\nThe requested URL /proper/commons-csv/archives/1.1/apidocs/index.html was not found on this server.\n\nApache/2.4.10 (Unix) OpenSSL/1.0.1i Server at commons.apache.org Port 80\n]",
                "resolved": "2014-11-26",
                "versions": [
                    "1.1"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-140",
                "project": "Commons CSV",
                "title": "QuoteMode.NON_NUMERIC doesn't work with CSVPrinter.printRecords(ResultSet)",
                "type": "Bug",
                "description": " CSVPrinter.printRecords(final ResultSet resultSet) retrieves all fields from the ResultSet using ResultSet.getString(), which makes QuoteMode.NON_NUMERIC unnecessarily quote numbers.\n\nResultSet.getObject() could be used instead. Any reason why it wasn't?\n",
                "resolved": "2014-11-10",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CSV-138",
                "project": "Commons CSV",
                "title": "CSVPrinter.printRecords(ResultSet) skips first row with SQLServer",
                "type": "Bug",
                "description": "WIth SQLServer's 2012 jdbc driver 4.0, when I call CSVPrinter#printRecords with a java.sql.ResultSet, the first row is not printed. It appears that the line\n{code}\nfinal int columnCount = resultSet.getMetaData().getColumnCount();\n{code} \npositions the cursor on the first row and then when\n{code}\n while (resultSet.next()) { ...\n{code}\nis called, the 2nd row onwards is what is getting outputted.\n\nAs a workaround, I used :\n{code}\nfinal int columnCount = rs.getMetaData().getColumnCount();\ndo {\n    for (int i = 1; i <= columnCount; i++) {\n        csvPrinter.print(rs.getString(i));\n    }\n    csvPrinter.println();\n} while (rs.next());\n{code}\n",
                "resolved": "2014-10-28",
                "versions": [
                    "1.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-135",
                "project": "Commons CSV",
                "title": "Char escape doesn't work properly with quoting",
                "type": "Bug",
                "description": "Following code:\n{code}\nCSVFormat format = CSVFormat.DEFAULT\n\t.withRecordSeparator('\\n')\n\t.withQuote('\"')\n\t.withEscape('\\\\');\n\nCSVPrinter printer = new CSVPrinter(System.out, format);\nList<String> l = new LinkedList<String>();\nl.add(\"\\\"\");\nl.add(\"\\n\");\nl.add(\"\\\\\");\nprinter.printRecord(l);\n{code}\nproduces\n{code}\n\"\"\"\",\"\n\",\"\\\"\n{code}\ninstead of\n{code}\n\"\\\"\",\"\\n\",\"\\\\\"\n{code}",
                "resolved": "2019-06-16",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "Patch Needed"
                ]
            },
            {
                "issue_id": "CSV-132",
                "project": "Commons CSV",
                "title": "Incorrect Javadoc referencing org.apache.commons.csv.CSVFormat withQuote()",
                "type": "Bug",
                "description": "Hi folks,\n\nthe Javadoc for org.apache.commons.csv.CSVFormat seems to be inconsistent since there are some references to a non-existing method *withQuoteChar*. The method name should be replaced by *withQuote*.\n",
                "resolved": "2014-09-10",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CSV-128",
                "project": "Commons CSV",
                "title": "CSVFormat.EXCEL should ignore empty header names",
                "type": "Bug",
                "description": "I have an Excel file with a first row with N column names\nIf there are additional columns that are not labeled, Excel exports empty columns. For example:\nA,B,C,,\na,b,c,d,e\n\nThis causes an IAE like:\n\n{noformat}\njava.lang.IllegalArgumentException: The header contains a duplicate name: \"\" in [A, B, C, , ]\n\tat org.apache.commons.csv.CSVParser.initializeHeader(CSVParser.java:368)\n\tat org.apache.commons.csv.CSVParser.<init>(CSVParser.java:248)\n\tat org.apache.commons.csv.CSVParser.parse(CSVParser.java:206)\n{noformat}\t\n\nIt seems like the simplest solution is to ignore empty column names, such that they cannot be addressable and not attempt to index them.",
                "resolved": "2014-08-27",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.1"
                ]
            },
            {
                "issue_id": "CSV-125",
                "project": "Commons CSV",
                "title": "No longer works with Java 6",
                "type": "Bug",
                "description": "Hi,\n\nCommons-csv doesn't have a release yet, and this week the snapshot builds stopped working on java 6. Digging into the documentation I become aware that project only works with java 7. It worked fine on java 6 last week.\nI understand that for some reason the project needs java 7 code.\n\nSaid all this, I ask if it is possible to make a release based on last week code as a milestone for java 6? Or if not possible, delay requirement for java 7, make the 1.0 release and then make the next version java 7?\n\nBest regards,\n\nBruno Marinho\n",
                "resolved": "2014-07-17",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-122",
                "project": "Commons CSV",
                "title": "NullPointerException when empty header string and and null string of \"\"",
                "type": "Bug",
                "description": "When setting the format to have a nullString of \"\" and having an empty header value, a nullPointerException is thrown.",
                "resolved": "2014-07-11",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-121",
                "project": "Commons CSV",
                "title": "IllegalArgumentException thrown when the header contains duplicate names when the column names are empty.",
                "type": "Bug",
                "description": "When having a header like a,,c,d,, an IllegalArgumentException(\"The header contains duplicate names: \" +Arrays.toString(header) is thrown because empty header names are treated as a header with name. I sended in a pullrequest at github: https://github.com/apache/commons-csv/pull/2",
                "resolved": "2014-06-12",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-120",
                "project": "Commons CSV",
                "title": "CSVFormat#withHeader doesn't work with CSVPrinter",
                "type": "Bug",
                "description": "In the current version [CSVFormat#withHeader|https://commons.apache.org/proper/commons-csv/apidocs/org/apache/commons/csv/CSVFormat.html#withHeader(java.lang.String...)] is only used by CSVParser. It would be nice if CSVPrinter also supported it. Ideally, the following line of code\n\n{code:java}\nCSVPrinter csvPrinter\n  = CSVFormat.TDF\n    .withHeader(\"x\")\n    .print(Files.newBufferedWriter(Paths.get(\"data.csv\")));\ncsvPrinter.printRecord(42);\ncsvPrinter.close();\n{code}\n\nshould produce\n\n{code}\nx\n42\n{code}\n\nIf you're alright with the idea of automatically inserting headers, I can attach a patch.",
                "resolved": "2014-06-09",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-118",
                "project": "Commons CSV",
                "title": "CSVRecord.toMap() throws NPE on formats with no headers.",
                "type": "Bug",
                "description": "The method toMap() on CSVRecord throws a NullPointerExcpetion when called on records derived using a format with no headers.\n\nThe method documentation states a null map should be returned instead.\n",
                "resolved": "2014-05-15",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-114",
                "project": "Commons CSV",
                "title": "CSVFormat constructor should reject a header array with duplicate entries",
                "type": "Bug",
                "description": "CSVFormat currently accepts whatever header String[] is provided.\nIt cannot be used if there are duplicate entries so these should be rejected.",
                "resolved": "2014-05-07",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-112",
                "project": "Commons CSV",
                "title": "HeaderMap is inconsistent when it is parsed from an input with duplicate columns names",
                "type": "Bug",
                "description": "Given a parser format for csv files with a header line:\n{code}\nCSVFormat myFormat = CSVFormat.RFC4180.withDelimiter(\",\").withQuoteChar('\"').withQuotePolicy(Quote.MINIMAL)\n\t\t\t\t.withIgnoreSurroundingSpaces(true).withHeader().withSkipHeaderRecord(true);\n{code}\n\nAnd given a file with duplicate header names:\n \nCol1,Col2,Col2,Col3,Col4\n1,2,3,4,5\n4,5,6,7,8 \n\nThe HeaderMap returned by the parser misses an entry because of the Column name being used as a key, leading to wrong behavior when we rely on it.\n\nIf this is not supposed to happen in the file regarding the CSV format, at least this should raise an error. If not we should come up with a more clever way to store and access the headers.\n",
                "resolved": "2014-05-04",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-111",
                "project": "Commons CSV",
                "title": "CSVRecord.toMap() fails if row length shorter than header length",
                "type": "Bug",
                "description": "Similar to CSV-96, if .toMap() is called on a record that has fewer fields than we have header columns we'll get an ArrayOutOfBoundsException.\n\n{code}\n@Test\npublic void testToMapWhenHeaderTooLong() throws Exception {\n   final CSVParser parser = new CSVParser(\"a,b\", CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").build());\n   final CSVRecord record = parser.iterator().next();\n   record.toMap();\n}\n{code}",
                "resolved": "2014-04-22",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-108",
                "project": "Commons CSV",
                "title": "Header is not detected",
                "type": "Bug",
                "description": "The heaer of the csv file is not detected.\n\nName; Firstname\nMustermann; Thomas\nMusterfrau; Petra\n\nReader in = new FileReader(\"c:/test.csv\");\nCSVFormat format = CSVFormat.DEFAULT;      \nformat = format.newFormat( ';' );   \n\n",
                "resolved": "2014-03-27",
                "versions": [
                    "1.0"
                ],
                "fixVersions": []
            },
            {
                "issue_id": "CSV-106",
                "project": "Commons CSV",
                "title": "CSVFormat.format allways append null",
                "type": "Bug",
                "description": "When I now call\nCSVFormat.newFormat(';').withSkipHeaderRecord(true).withHeader(\"H1\",\"H2\").format(\"A\",\"B\")\nI get the output A;Bnull\n\nThe expected output would be \n\nA;B\n",
                "resolved": "2014-03-13",
                "versions": [
                    "1.x"
                ],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-100",
                "project": "Commons CSV",
                "title": "CSVParser: getHeaderMap throws NPE ",
                "type": "Bug",
                "description": "title nearly says it all :-) \n\nGiven a CSVParser parser, the following line throws an NPE:\n\n{code}\nMap<String, Integer> header = parser.getHeaderMap();\n{code}\n\nStacktrace: \n\n{noformat}\nCaused by: java.lang.NullPointerException\nat java.util.HashMap.<init>(HashMap.java:318)\nat java.util.LinkedHashMap.<init>(LinkedHashMap.java:212)\nat org.apache.commons.csv.CSVParser.getHeaderMap(CSVParser.java:288)\n{noformat}\n\nhappens if the format doesn't have a headerMap.\n\nto fix, check if the parser's headerMap is null before trying to create the returned map:\n\n{code}\npublic Map<String, Integer> getHeaderMap() {\n    return this.headerMap != null ?\n       new LinkedHashMap<String, Integer>(this.headerMap)\n       : null;\n}\n\n{code}\n",
                "resolved": "2013-09-18",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-97",
                "project": "Commons CSV",
                "title": "Allow the String value for null to be customized for the CSV printer",
                "type": "Bug",
                "description": "Allow String value for null to be customized for CSV printer.\n\nEnhance builder and printer with a nullToString String.",
                "resolved": "2013-04-08",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-96",
                "project": "Commons CSV",
                "title": "CSVRecord does not verify that the length of the header mapping matches the number of values",
                "type": "Bug",
                "description": "CSVRecord does not verify that the size of the header mapping matches the number of values. The following test will produce a ArrayOutOfBoundsException:\n\n{code}\n@Test\npublic void testInvalidHeaderTooLong() throws Exception {\n   final CSVParser parser = new CSVParser(\"a,b\", CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").build());\n   final CSVRecord record = parser.iterator().next();\n   record.get(\"C\");\n}\n{code}",
                "resolved": "2013-06-24",
                "versions": [
                    "1.0"
                ],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-88",
                "project": "Commons CSV",
                "title": "Not possible to create a CSVFormat from scratch",
                "type": "Bug",
                "description": "It's not possible to create a CSVFormat except by modifying an existing format.\n\nCould either make the PRISTINE format public, or provide a constructor with a single parameter (the delimiter).\n\nCould provide a no-args ctor instead, but there seems little point in that.\n\n",
                "resolved": "2012-10-15",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-64",
                "project": "Commons CSV",
                "title": "CSVPrinter does not distinguish null and the empty string",
                "type": "Bug",
                "description": "CSVPrinter does not distinguish null and the empty string.\n\nThere should be a way to denote that a string is null rather than empty.",
                "resolved": "2013-06-21",
                "versions": [],
                "fixVersions": [
                    "1.x"
                ]
            },
            {
                "issue_id": "CSV-54",
                "project": "Commons CSV",
                "title": "Confusing semantic of the ignore leading/trailing spaces parameters",
                "type": "Bug",
                "description": "{{CSVFormat}} has two parameters to control how the leading and trailing spaces around values are handled, but the actual behavior depends on the value being enclosed in quotes or not.\n\nIf the value is not enclosed in quotes, setting {{leading/trailingSpacesIgnored}} to {{true}} will left or right trim the value. For example with this input (using the default format):\n\n{code}a,  b  ,c{code}\n\nthe second value will be equal to {{'b'}}.\n\n\nBut if the value is enclosed into quotes, the value is no longer trimmed:\n\n{code}a,\" b \",c{code}\n\nthis will give {{' b '}}.\n\n\nWith quoted values the parser actually ignores the spaces between the delimiter and the quote. Thus with this input:\n\n{code}a, \" b \" ,c{code}\n\nThe value returned is {{' b '}}.\n\n\nIf {{leading/trailingSpacesIgnored}} is set to {{false}}, we get instead {{' \" b \" '}} which is consistent with RFC 4180.\n\n",
                "resolved": "2012-03-26",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-41",
                "project": "Commons CSV",
                "title": "CSV Parser loops inifinitely if last line starts with a comment char",
                "type": "Bug",
                "description": "Behaviour:\n\nWhenever the last non-empty line of the CSV file starts with a comment, the CSVParser loops infinitely!\n\nExamplary CSV file:\n\n{code}\nsome\n# comment OK\nline\n# comment OK\nvalue\n# problematic comment\n{code}\n\nExcerpt of Java code:\n\n{code:java}\n   private static final char COMMENT = '#';\n   private static final char QUOTE = '\"';\n   private static final char SEPARATOR = ';';\n\n   CSVStrategy csvStrategy = new CSVStrategy(SEPARATOR, QUOTE, COMMENT);\n   CSVParser parser = new CSVParser(reader, csvStrategy);\n\n   String[] line = parser.getLine();\n\n   while (line != null) {\n      Log.debug(\"Line: \" + line[0]);\n      // Do something\n      line = parser.getLine();\n   }\n{code}\n\nUsed Maven Dependency:\n\n{code:xml}\n <dependency>\n    <groupId>org.apache.solr</groupId>\n    <artifactId>solr-commons-csv</artifactId>\n    <version>1.4.0</version>\n </dependency>\n{code}\n",
                "resolved": "2012-03-05",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-39",
                "project": "Commons CSV",
                "title": "CSVWriter ignores fieldHeader setting from CSVConfig",
                "type": "Bug",
                "description": "Setting fieldHeader to true has no impact on CSVWriter - it just never generates headers.",
                "resolved": "2012-03-06",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-38",
                "project": "Commons CSV",
                "title": "in CSVPrinter a null check is missing",
                "type": "Bug",
                "description": "In CSVPrinter, there is the print method:\n\npublic void print(String value) {\n    boolean quote = false;\n    if (value.length() > 0) {\n      char c = value.charAt(0);\n      if (newLine\n        && (c < '0'\n\nyou should do null check as well before the if (value.length)\n\n",
                "resolved": "2012-03-05",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-36",
                "project": "Commons CSV",
                "title": "Endless loops in CSV parser",
                "type": "Bug",
                "description": "If the input file ends with comment lines, the parser runs into an endless loop. The example shows, that the CSV parser runs into an endless loop, if the input is one comment line. '#' is the comment character here:\n\n{noformat}\nimport org.apache.commons.csv.CSVStrategy;\nimport org.apache.commons.csv.CSVParser;\nimport java.io.StringReader;\nimport java.io.IOException;\n\npublic class TestCSV {\n    public static void main(String [] args) throws IOException {\n        CSVStrategy strategy=new CSVStrategy(',','\"','#','\\\\',false,false,false,false);\n        \n        CSVParser parser = new CSVParser(new StringReader(\"# A, B\\n\"), strategy);\n        \n        System.out.println(\"Go into an endless loop...\");\n        String []line=parser.getLine();\n    }\n}\n{noformat} ",
                "resolved": "2010-07-15",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-34",
                "project": "Commons CSV",
                "title": "CSVFormat describes itself as immutable, but it is not - in particular it is not thread-safe",
                "type": "Bug",
                "description": "CSVFormat describes itself as immutable, but it is not @Immutable - the class fields are all mutable.\n\nThe methods that change the fields do so by creating a clone, and returning the changed clone.\nSo in a sense the class is immutable.\n\nHowever, the normal expectation is that @Immutable classes are @ThreadSafe.\nCSVFormat is not thread-safe, because the fields are not volatile, and the fields are not written & read using a common lock.\n\nThe comment needs to be clarified or removed.",
                "resolved": "2012-03-09",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-33",
                "project": "Commons CSV",
                "title": "The CSVPrinter ecapsing inconsistant with CSVParser",
                "type": "Bug",
                "description": "The CSVPrinter ecapses new line and return character to \"\\n\" and \"\\r\" if these occur within the encapsulators (this is within the CSVPrinter.escapeAndQuote(String) method).  However, the CSVParser do not convert these back to new line and return characters in the same fashion.  So if you use the CSVPrinter to create a delimited file containing new line or return characters within an entry and then read this file using the CSVParser the text read in by the CSVParser will not match the text written by the CSVPrinter (the difference being that every new line and return character will be replaced by \"\\n\" and \"\\r\" respectively).\n\nA possible fix for this would be to add two extra 'else if' statements to CSVParser.encapsulatedTokenLexer(Token, int) starting at line 49, as detailed below (the _ehampsised_ text indicated the changes):\n\nelse if (c == '\\\\' && in.lookAhead() == '\\\\')\n                {\n                    // doubled escape char, it does not escape itself, only encapsulator\n                    // -> add both escape chars to stream\n                    tkn.content.append((char) c);\n                    c = in.read();\n                    tkn.content.append((char) c);\n                }\n                _else if (c == '\\\\' && in.lookAhead() == 'n')_\n                _{_\n                   _ // escaped java new line character, append a new line character_\n                    _tkn.content.append('\\n');_\n                    _c = in.read();_\n                _}_\n                _else if (c == '\\\\' && in.lookAhead() == 'r')_\n                _{_\n                 _// escaped java return character, append a return character_\n                    _tkn.content.append('\\r');_\n                    _c = in.read();_\n                _}_\n                else if (strategy.getUnicodeEscapeInterpretation() && c == '\\\\'\n                        && in.lookAhead() == 'u')\n                {\n                    // interpret unicode escaped chars (like \\u0070 -> p)\n                    tkn.content.append((char) unicodeEscapeLexer(c));\n                }\n",
                "resolved": "2010-07-15",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-32",
                "project": "Commons CSV",
                "title": "CSVParser.nextValue() does not handle a CSV file with a single value correctly",
                "type": "Bug",
                "description": "For a CSV file with a single value in it (like if your entire file is just \"test\"), CSVParser.nextValue() returns null the first time it is called instead of the value.\n\nCSVParser.getLine() and CSVParser.getAllValues() do not value this problem.  The problem seems to be that getLine() has special handling for the \"TT_EOF\" tokens that nextValue() does not have.",
                "resolved": "2012-03-05",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-31",
                "project": "Commons CSV",
                "title": "CSVParser hangs (goes into infinite loop) on getLine() if it's a \"comment\" line that doesn't contain a delimiter",
                "type": "Bug",
                "description": "if you call CSVParser.getLine() or nextToken() with a line that is a comment as defined by the CSVStrategy but it doesn't contain the delimiter character, the call hangs in an infinite loop\n\nThis code will hang:\n{code}\n        parser = new CSVParser(new StringReader(\"# abc\\n\"), new CSVStrategy('\\t', '\\'', '#'));\n        tokens = parser.getLine();\n{code}\n\nHowever, if you insert a delimiter char into the incoming string, it'll come through and return an empty string as a result:\n{code}\n        CSVParser parser = new CSVParser(new StringReader(\"#\\tabc\"), new CSVStrategy('\\t', '\\'', '#'));\n        String[] tokens = parser.getLine();\n        System.out.println(\"result: \"+Arrays.toString(tokens));\n{code}\n\nIt gets stuck in an infinite loop in CSVParser.nextToken() in the loop around line 347",
                "resolved": "2011-11-10",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-25",
                "project": "Commons CSV",
                "title": "CSVParser.nextValue() seems pointless",
                "type": "Bug",
                "description": "The nextValue method really doesn't seem very useful. There's no concept of end of line, so your csv file could be 1xn or nx1 and you wouldn't know.",
                "resolved": "2011-11-09",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-23",
                "project": "Commons CSV",
                "title": "Excel strategy uses wrong separator",
                "type": "Bug",
                "description": "The Excel strategy is defined as follows.\n{code}\n    public static CSVStrategy EXCEL_STRATEGY   = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, false, \n                                                                 false, false, false);\n{code}\n\nHowever, when I do a \"Save as\" in Excel the separator used is actually {{';'}}. Thus, parsing the CSV file as suggested in the JavaDoc of {{CSVParser}} fails.\n\n{code}\nString[][] data =\n   (new CSVParser(new StringReader(\"a;b\\nc;d\"), CSVStrategy.EXCEL_STRATEGY)).getAllValues();\n{code}\n\nSimple test to reproduce:\n{code}\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport org.apache.commons.csv.CSVParser;\nimport org.apache.commons.csv.CSVStrategy;\n\npublic class CSVExcelStrategyBug {\n\n\tpublic static void main(final String[] args) {\n\t\ttry {\n\t\t\tSystem.out.println(\"Using ;\");\n\t\t\tparse(\"a;b\\nc;d\");\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Using ,\");\n\t\t\tparse(\"a,b\\nc,d\");\n\t\t} catch (final IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tprivate static void parse(final String input) throws IOException {\n\t\tfinal String[][] data = (new CSVParser(new StringReader(input), CSVStrategy.EXCEL_STRATEGY)).getAllValues();\n\t\tfor (final String[] row : data) {\n\t\t\tSystem.out.print(\"[\");\n\t\t\tfor (final String cell : row) {\n\t\t\t\tSystem.out.print(\"(\" + cell + \")\");\n\t\t\t}\n\t\t\tSystem.out.println(\"]\");\n\t\t}\n\t}\n\n}\n{code}\n\nActual output:\n{noformat}\nUsing ;\n[(a;b)]\n[(c;d)]\n\nUsing ,\n[(a)(b)]\n[(c)(d)]\n{noformat}\n\nExpected output:\n{noformat}\nUsing ;\n[(a)(b)]\n[(c)(d)]\n\nUsing ,\n[(a,b)]\n[(c,d)]\n{noformat}",
                "resolved": "2012-03-06",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-22",
                "project": "Commons CSV",
                "title": "CSV reader doesn't handle older Mac line endings",
                "type": "Bug",
                "description": "Older Mac OS line endings which just have \\r don't get treated as line endings by the current CSV parser.\n\nMost likely the simplest way to get around this is to delegate to a BufferedReader to reuse its line ending code.\n",
                "resolved": "2011-02-01",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-21",
                "project": "Commons CSV",
                "title": "CSVWriter.writeValue() not using value delimiter",
                "type": "Bug",
                "description": "CSVWriter.writeValue() only uses value delimiter if field values are fixed width.\n\nHere is the existing method:\n{code:title=CSVWriter.writeValue() error|borderStyle=solid}\nprotected String writeValue(CSVField field, String value) throws Exception {\n        if (config.isFixedWidth()) {\n            if (value.length() < field.getSize()) {\n                int fillPattern = config.getFill();\n                if (field.overrideFill()) {\n                    fillPattern = field.getFill();\n                }\n                StringBuffer sb = new StringBuffer();\n                int fillSize = (field.getSize() - value.length());\n                char[] fill = new char[fillSize];\n                Arrays.fill(fill, config.getFillChar());\n                if (fillPattern == CSVConfig.FILLLEFT) {\n                    sb.append(fill);\n                    sb.append(value);\n                    value = sb.toString();\n                } else {\n                    // defaults to fillpattern FILLRIGHT when fixedwidth is used\n                    sb.append(value);\n                    sb.append(fill);\n                    value = sb.toString();\n                }\n            } else if (value.length() > field.getSize()) {\n                // value to big..\n                value = value.substring(0, field.getSize());\n            }\n            if (!config.isValueDelimiterIgnored()) {\n                // add the value delimiter..\n                value = config.getValueDelimiter()+value+config.getValueDelimiter();\n            }\n        }\n        return value;\n   }\n{code}\n\nThe {color:blue}{{if (!config.isValueDelimiterIgnored())}}{color} block should be removed from the {color:blue}{{if (config.isFixedWidth())}}{color} block, like so:\n\n{code:title=CSVWriter.writeValue() corrected|borderStyle=solid}\nprotected String writeValue(CSVField field, String value) throws Exception {\n        if (config.isFixedWidth()) {\n            if (value.length() < field.getSize()) {\n                int fillPattern = config.getFill();\n                if (field.overrideFill()) {\n                    fillPattern = field.getFill();\n                }\n                StringBuffer sb = new StringBuffer();\n                int fillSize = (field.getSize() - value.length());\n                char[] fill = new char[fillSize];\n                Arrays.fill(fill, config.getFillChar());\n                if (fillPattern == CSVConfig.FILLLEFT) {\n                    sb.append(fill);\n                    sb.append(value);\n                    value = sb.toString();\n                } else {\n                    // defaults to fillpattern FILLRIGHT when fixedwidth is used\n                    sb.append(value);\n                    sb.append(fill);\n                    value = sb.toString();\n                }\n            } else if (value.length() > field.getSize()) {\n                // value to big..\n                value = value.substring(0, field.getSize());\n            }\n        }\n        if (!config.isValueDelimiterIgnored()) {\n            // add the value delimiter..\n            value = config.getValueDelimiter()+value+config.getValueDelimiter();\n        }\n        return value;\n   }\n{code}\n",
                "resolved": "2010-11-22",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-15",
                "project": "Commons CSV",
                "title": "Commons CSV EXCELL_STRATEGY is reading CSV files with double quote and comma properly but not writing them back the same way",
                "type": "Bug",
                "description": "original line: My line is containing \", symbols\nline in CSV file after \"Save as CSV\" in Excell: \"My line containing \"\", symbols\"\nline is CSV file as output from CSVPrinter with EXCELL_STRATEGY: \"My line containing \\\", symbols\"\n\nas a result when you will try to open that file in the excell you see text inside two cells:\n1 cell: My line containing \\\n2 cell: symbols\n\nis it again Microsoft \"features\", that are \"improving\" RFC?",
                "resolved": "2010-07-15",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-13",
                "project": "Commons CSV",
                "title": "NullPointerException in CSVPrinter.print()/println()",
                "type": "Bug",
                "description": "If\npublic void print(String value) method of CSVPrinter class gets null parameter it throws NullPointerException.",
                "resolved": "2012-03-05",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-11",
                "project": "Commons CSV",
                "title": "CSVWriter does not escape commas and quotes",
                "type": "Bug",
                "description": "When CSVWriter is provided a field value of \"Hello, \\\"Bob\\\"!\", it writes it out directly instead of wrapping it in quotes and escaping the internal quotes.  See the Wikipedia entry on CSV:\nhttp://en.wikipedia.org/wiki/Comma-separated_values",
                "resolved": "2012-03-06",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-3",
                "project": "Commons CSV",
                "title": "CSVPrinter#escapeAndQuote(String) doesn't adhere to CSV standard",
                "type": "Bug",
                "description": "All the descriptions of the CSV format that I've seen state that:\n\n- Double quotes (\") are escaped using two double quotes (\"\"), rather than a backslash (\\\").\n- Embedded line breaks are allowed and don't need to be escaped... just enclose the field in double quotes.\n- Because backslashes are not used to escape double quotes or line breaks, the backslashes themselves do not need to be escaped.\n\nCSVPrinter#escapeAndQuote(String) breaks these rules. Why?\n\nhttp://www.creativyst.com/Doc/Articles/CSV/CSV01.htm\nhttp://en.wikipedia.org/wiki/Comma-separated_values\n",
                "resolved": "2011-02-01",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            },
            {
                "issue_id": "CSV-1",
                "project": "Commons CSV",
                "title": "Delimiter should be never recognized as whitespace",
                "type": "Bug",
                "description": "The CSV-Parser ignores whitespaces at the beginning of a token. If the delimiter is a tabspace and data has no encapsulator the parser loses the empty tokens. The parser should never recognize a delimiter as a whitespace. A possible solution for the class CSVParser is to change the method isWhitespace(int) :\n\n  private boolean isWhitespace(int c) {\n    return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());\n  }",
                "resolved": "2012-03-09",
                "versions": [],
                "fixVersions": [
                    "1.0"
                ]
            }
        ]
    }
}